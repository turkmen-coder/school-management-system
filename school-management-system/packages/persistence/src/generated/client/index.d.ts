
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model Campus
 * 
 */
export type Campus = $Result.DefaultSelection<Prisma.$CampusPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model StudentParent
 * 
 */
export type StudentParent = $Result.DefaultSelection<Prisma.$StudentParentPayload>
/**
 * Model Prospect
 * 
 */
export type Prospect = $Result.DefaultSelection<Prisma.$ProspectPayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model Conversion
 * 
 */
export type Conversion = $Result.DefaultSelection<Prisma.$ConversionPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamSession
 * 
 */
export type ExamSession = $Result.DefaultSelection<Prisma.$ExamSessionPayload>
/**
 * Model ExamApplication
 * 
 */
export type ExamApplication = $Result.DefaultSelection<Prisma.$ExamApplicationPayload>
/**
 * Model AdmissionTicket
 * 
 */
export type AdmissionTicket = $Result.DefaultSelection<Prisma.$AdmissionTicketPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model FeeItem
 * 
 */
export type FeeItem = $Result.DefaultSelection<Prisma.$FeeItemPayload>
/**
 * Model ContractItem
 * 
 */
export type ContractItem = $Result.DefaultSelection<Prisma.$ContractItemPayload>
/**
 * Model ContractDiscount
 * 
 */
export type ContractDiscount = $Result.DefaultSelection<Prisma.$ContractDiscountPayload>
/**
 * Model Installment
 * 
 */
export type Installment = $Result.DefaultSelection<Prisma.$InstallmentPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.campus`: Exposes CRUD operations for the **Campus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campuses
    * const campuses = await prisma.campus.findMany()
    * ```
    */
  get campus(): Prisma.CampusDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs>;

  /**
   * `prisma.studentParent`: Exposes CRUD operations for the **StudentParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParent.findMany()
    * ```
    */
  get studentParent(): Prisma.StudentParentDelegate<ExtArgs>;

  /**
   * `prisma.prospect`: Exposes CRUD operations for the **Prospect** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prospects
    * const prospects = await prisma.prospect.findMany()
    * ```
    */
  get prospect(): Prisma.ProspectDelegate<ExtArgs>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs>;

  /**
   * `prisma.conversion`: Exposes CRUD operations for the **Conversion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversions
    * const conversions = await prisma.conversion.findMany()
    * ```
    */
  get conversion(): Prisma.ConversionDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.examSession`: Exposes CRUD operations for the **ExamSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamSessions
    * const examSessions = await prisma.examSession.findMany()
    * ```
    */
  get examSession(): Prisma.ExamSessionDelegate<ExtArgs>;

  /**
   * `prisma.examApplication`: Exposes CRUD operations for the **ExamApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamApplications
    * const examApplications = await prisma.examApplication.findMany()
    * ```
    */
  get examApplication(): Prisma.ExamApplicationDelegate<ExtArgs>;

  /**
   * `prisma.admissionTicket`: Exposes CRUD operations for the **AdmissionTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdmissionTickets
    * const admissionTickets = await prisma.admissionTicket.findMany()
    * ```
    */
  get admissionTicket(): Prisma.AdmissionTicketDelegate<ExtArgs>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs>;

  /**
   * `prisma.feeItem`: Exposes CRUD operations for the **FeeItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeeItems
    * const feeItems = await prisma.feeItem.findMany()
    * ```
    */
  get feeItem(): Prisma.FeeItemDelegate<ExtArgs>;

  /**
   * `prisma.contractItem`: Exposes CRUD operations for the **ContractItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractItems
    * const contractItems = await prisma.contractItem.findMany()
    * ```
    */
  get contractItem(): Prisma.ContractItemDelegate<ExtArgs>;

  /**
   * `prisma.contractDiscount`: Exposes CRUD operations for the **ContractDiscount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractDiscounts
    * const contractDiscounts = await prisma.contractDiscount.findMany()
    * ```
    */
  get contractDiscount(): Prisma.ContractDiscountDelegate<ExtArgs>;

  /**
   * `prisma.installment`: Exposes CRUD operations for the **Installment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installments
    * const installments = await prisma.installment.findMany()
    * ```
    */
  get installment(): Prisma.InstallmentDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    Campus: 'Campus',
    User: 'User',
    Student: 'Student',
    Parent: 'Parent',
    StudentParent: 'StudentParent',
    Prospect: 'Prospect',
    Interaction: 'Interaction',
    Conversion: 'Conversion',
    Exam: 'Exam',
    ExamSession: 'ExamSession',
    ExamApplication: 'ExamApplication',
    AdmissionTicket: 'AdmissionTicket',
    Contract: 'Contract',
    FeeItem: 'FeeItem',
    ContractItem: 'ContractItem',
    ContractDiscount: 'ContractDiscount',
    Installment: 'Installment',
    Payment: 'Payment',
    Refund: 'Refund',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "campus" | "user" | "student" | "parent" | "studentParent" | "prospect" | "interaction" | "conversion" | "exam" | "examSession" | "examApplication" | "admissionTicket" | "contract" | "feeItem" | "contractItem" | "contractDiscount" | "installment" | "payment" | "refund" | "notification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      Campus: {
        payload: Prisma.$CampusPayload<ExtArgs>
        fields: Prisma.CampusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          findFirst: {
            args: Prisma.CampusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          findMany: {
            args: Prisma.CampusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>[]
          }
          create: {
            args: Prisma.CampusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          createMany: {
            args: Prisma.CampusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>[]
          }
          delete: {
            args: Prisma.CampusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          update: {
            args: Prisma.CampusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          deleteMany: {
            args: Prisma.CampusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CampusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampusPayload>
          }
          aggregate: {
            args: Prisma.CampusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampus>
          }
          groupBy: {
            args: Prisma.CampusGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampusGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampusCountArgs<ExtArgs>
            result: $Utils.Optional<CampusCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      StudentParent: {
        payload: Prisma.$StudentParentPayload<ExtArgs>
        fields: Prisma.StudentParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findFirst: {
            args: Prisma.StudentParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findMany: {
            args: Prisma.StudentParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          create: {
            args: Prisma.StudentParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          createMany: {
            args: Prisma.StudentParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentParentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          delete: {
            args: Prisma.StudentParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          update: {
            args: Prisma.StudentParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          aggregate: {
            args: Prisma.StudentParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParent>
          }
          groupBy: {
            args: Prisma.StudentParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentParentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentCountAggregateOutputType> | number
          }
        }
      }
      Prospect: {
        payload: Prisma.$ProspectPayload<ExtArgs>
        fields: Prisma.ProspectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProspectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProspectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          findFirst: {
            args: Prisma.ProspectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProspectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          findMany: {
            args: Prisma.ProspectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>[]
          }
          create: {
            args: Prisma.ProspectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          createMany: {
            args: Prisma.ProspectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProspectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>[]
          }
          delete: {
            args: Prisma.ProspectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          update: {
            args: Prisma.ProspectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          deleteMany: {
            args: Prisma.ProspectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProspectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProspectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProspectPayload>
          }
          aggregate: {
            args: Prisma.ProspectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProspect>
          }
          groupBy: {
            args: Prisma.ProspectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProspectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProspectCountArgs<ExtArgs>
            result: $Utils.Optional<ProspectCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      Conversion: {
        payload: Prisma.$ConversionPayload<ExtArgs>
        fields: Prisma.ConversionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findFirst: {
            args: Prisma.ConversionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          findMany: {
            args: Prisma.ConversionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          create: {
            args: Prisma.ConversionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          createMany: {
            args: Prisma.ConversionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>[]
          }
          delete: {
            args: Prisma.ConversionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          update: {
            args: Prisma.ConversionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          deleteMany: {
            args: Prisma.ConversionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConversionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionPayload>
          }
          aggregate: {
            args: Prisma.ConversionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversion>
          }
          groupBy: {
            args: Prisma.ConversionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversionCountArgs<ExtArgs>
            result: $Utils.Optional<ConversionCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamSession: {
        payload: Prisma.$ExamSessionPayload<ExtArgs>
        fields: Prisma.ExamSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          findFirst: {
            args: Prisma.ExamSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          findMany: {
            args: Prisma.ExamSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>[]
          }
          create: {
            args: Prisma.ExamSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          createMany: {
            args: Prisma.ExamSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>[]
          }
          delete: {
            args: Prisma.ExamSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          update: {
            args: Prisma.ExamSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          deleteMany: {
            args: Prisma.ExamSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamSessionPayload>
          }
          aggregate: {
            args: Prisma.ExamSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamSession>
          }
          groupBy: {
            args: Prisma.ExamSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamSessionCountAggregateOutputType> | number
          }
        }
      }
      ExamApplication: {
        payload: Prisma.$ExamApplicationPayload<ExtArgs>
        fields: Prisma.ExamApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          findFirst: {
            args: Prisma.ExamApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          findMany: {
            args: Prisma.ExamApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>[]
          }
          create: {
            args: Prisma.ExamApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          createMany: {
            args: Prisma.ExamApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>[]
          }
          delete: {
            args: Prisma.ExamApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          update: {
            args: Prisma.ExamApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ExamApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamApplicationPayload>
          }
          aggregate: {
            args: Prisma.ExamApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamApplication>
          }
          groupBy: {
            args: Prisma.ExamApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ExamApplicationCountAggregateOutputType> | number
          }
        }
      }
      AdmissionTicket: {
        payload: Prisma.$AdmissionTicketPayload<ExtArgs>
        fields: Prisma.AdmissionTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          findFirst: {
            args: Prisma.AdmissionTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          findMany: {
            args: Prisma.AdmissionTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>[]
          }
          create: {
            args: Prisma.AdmissionTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          createMany: {
            args: Prisma.AdmissionTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>[]
          }
          delete: {
            args: Prisma.AdmissionTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          update: {
            args: Prisma.AdmissionTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdmissionTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionTicketPayload>
          }
          aggregate: {
            args: Prisma.AdmissionTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmissionTicket>
          }
          groupBy: {
            args: Prisma.AdmissionTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionTicketCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionTicketCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      FeeItem: {
        payload: Prisma.$FeeItemPayload<ExtArgs>
        fields: Prisma.FeeItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeeItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeeItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          findFirst: {
            args: Prisma.FeeItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeeItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          findMany: {
            args: Prisma.FeeItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>[]
          }
          create: {
            args: Prisma.FeeItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          createMany: {
            args: Prisma.FeeItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeeItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>[]
          }
          delete: {
            args: Prisma.FeeItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          update: {
            args: Prisma.FeeItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          deleteMany: {
            args: Prisma.FeeItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeeItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeeItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeeItemPayload>
          }
          aggregate: {
            args: Prisma.FeeItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeeItem>
          }
          groupBy: {
            args: Prisma.FeeItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeeItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeeItemCountArgs<ExtArgs>
            result: $Utils.Optional<FeeItemCountAggregateOutputType> | number
          }
        }
      }
      ContractItem: {
        payload: Prisma.$ContractItemPayload<ExtArgs>
        fields: Prisma.ContractItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          findFirst: {
            args: Prisma.ContractItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          findMany: {
            args: Prisma.ContractItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>[]
          }
          create: {
            args: Prisma.ContractItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          createMany: {
            args: Prisma.ContractItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>[]
          }
          delete: {
            args: Prisma.ContractItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          update: {
            args: Prisma.ContractItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          deleteMany: {
            args: Prisma.ContractItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractItemPayload>
          }
          aggregate: {
            args: Prisma.ContractItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractItem>
          }
          groupBy: {
            args: Prisma.ContractItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractItemCountArgs<ExtArgs>
            result: $Utils.Optional<ContractItemCountAggregateOutputType> | number
          }
        }
      }
      ContractDiscount: {
        payload: Prisma.$ContractDiscountPayload<ExtArgs>
        fields: Prisma.ContractDiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractDiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractDiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          findFirst: {
            args: Prisma.ContractDiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractDiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          findMany: {
            args: Prisma.ContractDiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>[]
          }
          create: {
            args: Prisma.ContractDiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          createMany: {
            args: Prisma.ContractDiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractDiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>[]
          }
          delete: {
            args: Prisma.ContractDiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          update: {
            args: Prisma.ContractDiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          deleteMany: {
            args: Prisma.ContractDiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractDiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContractDiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractDiscountPayload>
          }
          aggregate: {
            args: Prisma.ContractDiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractDiscount>
          }
          groupBy: {
            args: Prisma.ContractDiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractDiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractDiscountCountArgs<ExtArgs>
            result: $Utils.Optional<ContractDiscountCountAggregateOutputType> | number
          }
        }
      }
      Installment: {
        payload: Prisma.$InstallmentPayload<ExtArgs>
        fields: Prisma.InstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findFirst: {
            args: Prisma.InstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          findMany: {
            args: Prisma.InstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          create: {
            args: Prisma.InstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          createMany: {
            args: Prisma.InstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>[]
          }
          delete: {
            args: Prisma.InstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          update: {
            args: Prisma.InstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          deleteMany: {
            args: Prisma.InstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallmentPayload>
          }
          aggregate: {
            args: Prisma.InstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallment>
          }
          groupBy: {
            args: Prisma.InstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstallmentCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    campuses: number
    users: number
    students: number
    parents: number
    contracts: number
    feeItems: number
    prospects: number
    exams: number
    notifications: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campuses?: boolean | TenantCountOutputTypeCountCampusesArgs
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    students?: boolean | TenantCountOutputTypeCountStudentsArgs
    parents?: boolean | TenantCountOutputTypeCountParentsArgs
    contracts?: boolean | TenantCountOutputTypeCountContractsArgs
    feeItems?: boolean | TenantCountOutputTypeCountFeeItemsArgs
    prospects?: boolean | TenantCountOutputTypeCountProspectsArgs
    exams?: boolean | TenantCountOutputTypeCountExamsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCampusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampusWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountFeeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountProspectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CampusCountOutputType
   */

  export type CampusCountOutputType = {
    students: number
    contracts: number
    exams: number
    examSessions: number
  }

  export type CampusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | CampusCountOutputTypeCountStudentsArgs
    contracts?: boolean | CampusCountOutputTypeCountContractsArgs
    exams?: boolean | CampusCountOutputTypeCountExamsArgs
    examSessions?: boolean | CampusCountOutputTypeCountExamSessionsArgs
  }

  // Custom InputTypes
  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampusCountOutputType
     */
    select?: CampusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * CampusCountOutputType without action
   */
  export type CampusCountOutputTypeCountExamSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSessionWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parentRelations: number
    contracts: number
    examApplications: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentRelations?: boolean | StudentCountOutputTypeCountParentRelationsArgs
    contracts?: boolean | StudentCountOutputTypeCountContractsArgs
    examApplications?: boolean | StudentCountOutputTypeCountExamApplicationsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountExamApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamApplicationWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    studentRelations: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentRelations?: boolean | ParentCountOutputTypeCountStudentRelationsArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountStudentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }


  /**
   * Count Type ProspectCountOutputType
   */

  export type ProspectCountOutputType = {
    interactions: number
    conversions: number
    examApplications: number
  }

  export type ProspectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | ProspectCountOutputTypeCountInteractionsArgs
    conversions?: boolean | ProspectCountOutputTypeCountConversionsArgs
    examApplications?: boolean | ProspectCountOutputTypeCountExamApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProspectCountOutputType
     */
    select?: ProspectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeCountConversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
  }

  /**
   * ProspectCountOutputType without action
   */
  export type ProspectCountOutputTypeCountExamApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamApplicationWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    sessions: number
    applications: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ExamCountOutputTypeCountSessionsArgs
    applications?: boolean | ExamCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSessionWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamApplicationWhereInput
  }


  /**
   * Count Type ExamSessionCountOutputType
   */

  export type ExamSessionCountOutputType = {
    admissionTickets: number
  }

  export type ExamSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admissionTickets?: boolean | ExamSessionCountOutputTypeCountAdmissionTicketsArgs
  }

  // Custom InputTypes
  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSessionCountOutputType
     */
    select?: ExamSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamSessionCountOutputType without action
   */
  export type ExamSessionCountOutputTypeCountAdmissionTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTicketWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    items: number
    installments: number
    payments: number
    discounts: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | ContractCountOutputTypeCountItemsArgs
    installments?: boolean | ContractCountOutputTypeCountInstallmentsArgs
    payments?: boolean | ContractCountOutputTypeCountPaymentsArgs
    discounts?: boolean | ContractCountOutputTypeCountDiscountsArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractItemWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractDiscountWhereInput
  }


  /**
   * Count Type FeeItemCountOutputType
   */

  export type FeeItemCountOutputType = {
    contractItems: number
  }

  export type FeeItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractItems?: boolean | FeeItemCountOutputTypeCountContractItemsArgs
  }

  // Custom InputTypes
  /**
   * FeeItemCountOutputType without action
   */
  export type FeeItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItemCountOutputType
     */
    select?: FeeItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeeItemCountOutputType without action
   */
  export type FeeItemCountOutputTypeCountContractItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractItemWhereInput
  }


  /**
   * Count Type InstallmentCountOutputType
   */

  export type InstallmentCountOutputType = {
    payments: number
  }

  export type InstallmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InstallmentCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InstallmentCountOutputType without action
   */
  export type InstallmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallmentCountOutputType
     */
    select?: InstallmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstallmentCountOutputType without action
   */
  export type InstallmentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    refunds: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refunds?: boolean | PaymentCountOutputTypeCountRefundsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountRefundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    settings: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    settings?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    domain: string
    settings: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campuses?: boolean | Tenant$campusesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    students?: boolean | Tenant$studentsArgs<ExtArgs>
    parents?: boolean | Tenant$parentsArgs<ExtArgs>
    contracts?: boolean | Tenant$contractsArgs<ExtArgs>
    feeItems?: boolean | Tenant$feeItemsArgs<ExtArgs>
    prospects?: boolean | Tenant$prospectsArgs<ExtArgs>
    exams?: boolean | Tenant$examsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    settings?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campuses?: boolean | Tenant$campusesArgs<ExtArgs>
    users?: boolean | Tenant$usersArgs<ExtArgs>
    students?: boolean | Tenant$studentsArgs<ExtArgs>
    parents?: boolean | Tenant$parentsArgs<ExtArgs>
    contracts?: boolean | Tenant$contractsArgs<ExtArgs>
    feeItems?: boolean | Tenant$feeItemsArgs<ExtArgs>
    prospects?: boolean | Tenant$prospectsArgs<ExtArgs>
    exams?: boolean | Tenant$examsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      campuses: Prisma.$CampusPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      students: Prisma.$StudentPayload<ExtArgs>[]
      parents: Prisma.$ParentPayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      feeItems: Prisma.$FeeItemPayload<ExtArgs>[]
      prospects: Prisma.$ProspectPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      settings: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campuses<T extends Tenant$campusesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$campusesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    students<T extends Tenant$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    parents<T extends Tenant$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany"> | Null>
    contracts<T extends Tenant$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    feeItems<T extends Tenant$feeItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$feeItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findMany"> | Null>
    prospects<T extends Tenant$prospectsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$prospectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Tenant$examsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly isActive: FieldRef<"Tenant", 'Boolean'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.campuses
   */
  export type Tenant$campusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    where?: CampusWhereInput
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    cursor?: CampusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.students
   */
  export type Tenant$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Tenant.parents
   */
  export type Tenant$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    cursor?: ParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Tenant.contracts
   */
  export type Tenant$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Tenant.feeItems
   */
  export type Tenant$feeItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    where?: FeeItemWhereInput
    orderBy?: FeeItemOrderByWithRelationInput | FeeItemOrderByWithRelationInput[]
    cursor?: FeeItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeeItemScalarFieldEnum | FeeItemScalarFieldEnum[]
  }

  /**
   * Tenant.prospects
   */
  export type Tenant$prospectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    where?: ProspectWhereInput
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    cursor?: ProspectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Tenant.exams
   */
  export type Tenant$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model Campus
   */

  export type AggregateCampus = {
    _count: CampusCountAggregateOutputType | null
    _min: CampusMinAggregateOutputType | null
    _max: CampusMaxAggregateOutputType | null
  }

  export type CampusMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampusMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampusCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    address: number
    phone: number
    email: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampusMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampusMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampusCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campus to aggregate.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campuses
    **/
    _count?: true | CampusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampusMaxAggregateInputType
  }

  export type GetCampusAggregateType<T extends CampusAggregateArgs> = {
        [P in keyof T & keyof AggregateCampus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampus[P]>
      : GetScalarType<T[P], AggregateCampus[P]>
  }




  export type CampusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampusWhereInput
    orderBy?: CampusOrderByWithAggregationInput | CampusOrderByWithAggregationInput[]
    by: CampusScalarFieldEnum[] | CampusScalarFieldEnum
    having?: CampusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampusCountAggregateInputType | true
    _min?: CampusMinAggregateInputType
    _max?: CampusMaxAggregateInputType
  }

  export type CampusGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CampusCountAggregateOutputType | null
    _min: CampusMinAggregateOutputType | null
    _max: CampusMaxAggregateOutputType | null
  }

  type GetCampusGroupByPayload<T extends CampusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampusGroupByOutputType[P]>
            : GetScalarType<T[P], CampusGroupByOutputType[P]>
        }
      >
    >


  export type CampusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    students?: boolean | Campus$studentsArgs<ExtArgs>
    contracts?: boolean | Campus$contractsArgs<ExtArgs>
    exams?: boolean | Campus$examsArgs<ExtArgs>
    examSessions?: boolean | Campus$examSessionsArgs<ExtArgs>
    _count?: boolean | CampusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campus"]>

  export type CampusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campus"]>

  export type CampusSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    students?: boolean | Campus$studentsArgs<ExtArgs>
    contracts?: boolean | Campus$contractsArgs<ExtArgs>
    exams?: boolean | Campus$examsArgs<ExtArgs>
    examSessions?: boolean | Campus$examSessionsArgs<ExtArgs>
    _count?: boolean | CampusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CampusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campus"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      students: Prisma.$StudentPayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      examSessions: Prisma.$ExamSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campus"]>
    composites: {}
  }

  type CampusGetPayload<S extends boolean | null | undefined | CampusDefaultArgs> = $Result.GetResult<Prisma.$CampusPayload, S>

  type CampusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CampusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CampusCountAggregateInputType | true
    }

  export interface CampusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campus'], meta: { name: 'Campus' } }
    /**
     * Find zero or one Campus that matches the filter.
     * @param {CampusFindUniqueArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampusFindUniqueArgs>(args: SelectSubset<T, CampusFindUniqueArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Campus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CampusFindUniqueOrThrowArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampusFindUniqueOrThrowArgs>(args: SelectSubset<T, CampusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Campus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindFirstArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampusFindFirstArgs>(args?: SelectSubset<T, CampusFindFirstArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Campus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindFirstOrThrowArgs} args - Arguments to find a Campus
     * @example
     * // Get one Campus
     * const campus = await prisma.campus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampusFindFirstOrThrowArgs>(args?: SelectSubset<T, CampusFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Campuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campuses
     * const campuses = await prisma.campus.findMany()
     * 
     * // Get first 10 Campuses
     * const campuses = await prisma.campus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campusWithIdOnly = await prisma.campus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampusFindManyArgs>(args?: SelectSubset<T, CampusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Campus.
     * @param {CampusCreateArgs} args - Arguments to create a Campus.
     * @example
     * // Create one Campus
     * const Campus = await prisma.campus.create({
     *   data: {
     *     // ... data to create a Campus
     *   }
     * })
     * 
     */
    create<T extends CampusCreateArgs>(args: SelectSubset<T, CampusCreateArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Campuses.
     * @param {CampusCreateManyArgs} args - Arguments to create many Campuses.
     * @example
     * // Create many Campuses
     * const campus = await prisma.campus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampusCreateManyArgs>(args?: SelectSubset<T, CampusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campuses and returns the data saved in the database.
     * @param {CampusCreateManyAndReturnArgs} args - Arguments to create many Campuses.
     * @example
     * // Create many Campuses
     * const campus = await prisma.campus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campuses and only return the `id`
     * const campusWithIdOnly = await prisma.campus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampusCreateManyAndReturnArgs>(args?: SelectSubset<T, CampusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Campus.
     * @param {CampusDeleteArgs} args - Arguments to delete one Campus.
     * @example
     * // Delete one Campus
     * const Campus = await prisma.campus.delete({
     *   where: {
     *     // ... filter to delete one Campus
     *   }
     * })
     * 
     */
    delete<T extends CampusDeleteArgs>(args: SelectSubset<T, CampusDeleteArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Campus.
     * @param {CampusUpdateArgs} args - Arguments to update one Campus.
     * @example
     * // Update one Campus
     * const campus = await prisma.campus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampusUpdateArgs>(args: SelectSubset<T, CampusUpdateArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Campuses.
     * @param {CampusDeleteManyArgs} args - Arguments to filter Campuses to delete.
     * @example
     * // Delete a few Campuses
     * const { count } = await prisma.campus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampusDeleteManyArgs>(args?: SelectSubset<T, CampusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campuses
     * const campus = await prisma.campus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampusUpdateManyArgs>(args: SelectSubset<T, CampusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Campus.
     * @param {CampusUpsertArgs} args - Arguments to update or create a Campus.
     * @example
     * // Update or create a Campus
     * const campus = await prisma.campus.upsert({
     *   create: {
     *     // ... data to create a Campus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campus we want to update
     *   }
     * })
     */
    upsert<T extends CampusUpsertArgs>(args: SelectSubset<T, CampusUpsertArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Campuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusCountArgs} args - Arguments to filter Campuses to count.
     * @example
     * // Count the number of Campuses
     * const count = await prisma.campus.count({
     *   where: {
     *     // ... the filter for the Campuses we want to count
     *   }
     * })
    **/
    count<T extends CampusCountArgs>(
      args?: Subset<T, CampusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampusAggregateArgs>(args: Subset<T, CampusAggregateArgs>): Prisma.PrismaPromise<GetCampusAggregateType<T>>

    /**
     * Group by Campus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampusGroupByArgs['orderBy'] }
        : { orderBy?: CampusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campus model
   */
  readonly fields: CampusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    students<T extends Campus$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany"> | Null>
    contracts<T extends Campus$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Campus$examsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    examSessions<T extends Campus$examSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Campus$examSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campus model
   */ 
  interface CampusFieldRefs {
    readonly id: FieldRef<"Campus", 'String'>
    readonly tenantId: FieldRef<"Campus", 'String'>
    readonly name: FieldRef<"Campus", 'String'>
    readonly address: FieldRef<"Campus", 'String'>
    readonly phone: FieldRef<"Campus", 'String'>
    readonly email: FieldRef<"Campus", 'String'>
    readonly isActive: FieldRef<"Campus", 'Boolean'>
    readonly createdAt: FieldRef<"Campus", 'DateTime'>
    readonly updatedAt: FieldRef<"Campus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Campus findUnique
   */
  export type CampusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus findUniqueOrThrow
   */
  export type CampusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus findFirst
   */
  export type CampusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campuses.
     */
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus findFirstOrThrow
   */
  export type CampusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campus to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campuses.
     */
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus findMany
   */
  export type CampusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter, which Campuses to fetch.
     */
    where?: CampusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campuses to fetch.
     */
    orderBy?: CampusOrderByWithRelationInput | CampusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campuses.
     */
    cursor?: CampusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campuses.
     */
    skip?: number
    distinct?: CampusScalarFieldEnum | CampusScalarFieldEnum[]
  }

  /**
   * Campus create
   */
  export type CampusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The data needed to create a Campus.
     */
    data: XOR<CampusCreateInput, CampusUncheckedCreateInput>
  }

  /**
   * Campus createMany
   */
  export type CampusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campuses.
     */
    data: CampusCreateManyInput | CampusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campus createManyAndReturn
   */
  export type CampusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Campuses.
     */
    data: CampusCreateManyInput | CampusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campus update
   */
  export type CampusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The data needed to update a Campus.
     */
    data: XOR<CampusUpdateInput, CampusUncheckedUpdateInput>
    /**
     * Choose, which Campus to update.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus updateMany
   */
  export type CampusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campuses.
     */
    data: XOR<CampusUpdateManyMutationInput, CampusUncheckedUpdateManyInput>
    /**
     * Filter which Campuses to update
     */
    where?: CampusWhereInput
  }

  /**
   * Campus upsert
   */
  export type CampusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * The filter to search for the Campus to update in case it exists.
     */
    where: CampusWhereUniqueInput
    /**
     * In case the Campus found by the `where` argument doesn't exist, create a new Campus with this data.
     */
    create: XOR<CampusCreateInput, CampusUncheckedCreateInput>
    /**
     * In case the Campus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampusUpdateInput, CampusUncheckedUpdateInput>
  }

  /**
   * Campus delete
   */
  export type CampusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
    /**
     * Filter which Campus to delete.
     */
    where: CampusWhereUniqueInput
  }

  /**
   * Campus deleteMany
   */
  export type CampusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campuses to delete
     */
    where?: CampusWhereInput
  }

  /**
   * Campus.students
   */
  export type Campus$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    cursor?: StudentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Campus.contracts
   */
  export type Campus$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Campus.exams
   */
  export type Campus$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Campus.examSessions
   */
  export type Campus$examSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    where?: ExamSessionWhereInput
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    cursor?: ExamSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * Campus without action
   */
  export type CampusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campus
     */
    select?: CampusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampusInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: string | null
    refreshToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    role: string | null
    refreshToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    phone: number
    passwordHash: number
    role: number
    refreshToken: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    phone?: true
    passwordHash?: true
    role?: true
    refreshToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string | null
    email: string | null
    phone: string
    passwordHash: string | null
    role: string
    refreshToken: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    role?: boolean
    refreshToken?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      email: string | null
      phone: string
      passwordHash: string | null
      role: string
      refreshToken: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    classLevel: number | null
  }

  export type StudentSumAggregateOutputType = {
    classLevel: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    schoolYear: string | null
    tcNo: string | null
    studentNo: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    gender: string | null
    classLevel: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    schoolYear: string | null
    tcNo: string | null
    studentNo: string | null
    firstName: string | null
    lastName: string | null
    birthDate: Date | null
    gender: string | null
    classLevel: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    tenantId: number
    campusId: number
    schoolYear: number
    tcNo: number
    studentNo: number
    firstName: number
    lastName: number
    birthDate: number
    gender: number
    classLevel: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    classLevel?: true
  }

  export type StudentSumAggregateInputType = {
    classLevel?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    tcNo?: true
    studentNo?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    gender?: true
    classLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    tcNo?: true
    studentNo?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    gender?: true
    classLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    tcNo?: true
    studentNo?: true
    firstName?: true
    lastName?: true
    birthDate?: true
    gender?: true
    classLevel?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo: string | null
    firstName: string
    lastName: string
    birthDate: Date
    gender: string
    classLevel: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    tcNo?: boolean
    studentNo?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    gender?: boolean
    classLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parentRelations?: boolean | Student$parentRelationsArgs<ExtArgs>
    contracts?: boolean | Student$contractsArgs<ExtArgs>
    examApplications?: boolean | Student$examApplicationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    tcNo?: boolean
    studentNo?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    gender?: boolean
    classLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    tcNo?: boolean
    studentNo?: boolean
    firstName?: boolean
    lastName?: boolean
    birthDate?: boolean
    gender?: boolean
    classLevel?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    parentRelations?: boolean | Student$parentRelationsArgs<ExtArgs>
    contracts?: boolean | Student$contractsArgs<ExtArgs>
    examApplications?: boolean | Student$examApplicationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      campus: Prisma.$CampusPayload<ExtArgs>
      parentRelations: Prisma.$StudentParentPayload<ExtArgs>[]
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      examApplications: Prisma.$ExamApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      campusId: string
      schoolYear: string
      tcNo: string
      studentNo: string | null
      firstName: string
      lastName: string
      birthDate: Date
      gender: string
      classLevel: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentRelations<T extends Student$parentRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany"> | Null>
    contracts<T extends Student$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Student$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany"> | Null>
    examApplications<T extends Student$examApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$examApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly tenantId: FieldRef<"Student", 'String'>
    readonly campusId: FieldRef<"Student", 'String'>
    readonly schoolYear: FieldRef<"Student", 'String'>
    readonly tcNo: FieldRef<"Student", 'String'>
    readonly studentNo: FieldRef<"Student", 'String'>
    readonly firstName: FieldRef<"Student", 'String'>
    readonly lastName: FieldRef<"Student", 'String'>
    readonly birthDate: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly classLevel: FieldRef<"Student", 'Int'>
    readonly status: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.parentRelations
   */
  export type Student$parentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Student.contracts
   */
  export type Student$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Student.examApplications
   */
  export type Student$examApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    where?: ExamApplicationWhereInput
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    cursor?: ExamApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tcNo: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    relationType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    tcNo: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    address: string | null
    relationType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    tenantId: number
    tcNo: number
    firstName: number
    lastName: number
    phone: number
    email: number
    address: number
    relationType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    tenantId?: true
    tcNo?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    relationType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    tcNo?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    relationType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    tenantId?: true
    tcNo?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    address?: true
    relationType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    tenantId: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email: string | null
    address: string | null
    relationType: string
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tcNo?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    relationType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    studentRelations?: boolean | Parent$studentRelationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    tcNo?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    relationType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>

  export type ParentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    tcNo?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    relationType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    studentRelations?: boolean | Parent$studentRelationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      studentRelations: Prisma.$StudentParentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      tcNo: string
      firstName: string
      lastName: string
      phone: string
      email: string | null
      address: string | null
      relationType: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Parents and returns the data saved in the database.
     * @param {ParentCreateManyAndReturnArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Parents and only return the `id`
     * const parentWithIdOnly = await prisma.parent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParentCreateManyAndReturnArgs>(args?: SelectSubset<T, ParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    studentRelations<T extends Parent$studentRelationsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$studentRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */ 
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly tenantId: FieldRef<"Parent", 'String'>
    readonly tcNo: FieldRef<"Parent", 'String'>
    readonly firstName: FieldRef<"Parent", 'String'>
    readonly lastName: FieldRef<"Parent", 'String'>
    readonly phone: FieldRef<"Parent", 'String'>
    readonly email: FieldRef<"Parent", 'String'>
    readonly address: FieldRef<"Parent", 'String'>
    readonly relationType: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Parent createManyAndReturn
   */
  export type ParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
  }

  /**
   * Parent.studentRelations
   */
  export type Parent$studentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model StudentParent
   */

  export type AggregateStudentParent = {
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  export type StudentParentMinAggregateOutputType = {
    studentId: string | null
    parentId: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type StudentParentMaxAggregateOutputType = {
    studentId: string | null
    parentId: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type StudentParentCountAggregateOutputType = {
    studentId: number
    parentId: number
    isPrimary: number
    createdAt: number
    _all: number
  }


  export type StudentParentMinAggregateInputType = {
    studentId?: true
    parentId?: true
    isPrimary?: true
    createdAt?: true
  }

  export type StudentParentMaxAggregateInputType = {
    studentId?: true
    parentId?: true
    isPrimary?: true
    createdAt?: true
  }

  export type StudentParentCountAggregateInputType = {
    studentId?: true
    parentId?: true
    isPrimary?: true
    createdAt?: true
    _all?: true
  }

  export type StudentParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParent to aggregate.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentMaxAggregateInputType
  }

  export type GetStudentParentAggregateType<T extends StudentParentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParent[P]>
      : GetScalarType<T[P], AggregateStudentParent[P]>
  }




  export type StudentParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithAggregationInput | StudentParentOrderByWithAggregationInput[]
    by: StudentParentScalarFieldEnum[] | StudentParentScalarFieldEnum
    having?: StudentParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentCountAggregateInputType | true
    _min?: StudentParentMinAggregateInputType
    _max?: StudentParentMaxAggregateInputType
  }

  export type StudentParentGroupByOutputType = {
    studentId: string
    parentId: string
    isPrimary: boolean
    createdAt: Date
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  type GetStudentParentGroupByPayload<T extends StudentParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>

  export type StudentParentSelectScalar = {
    studentId?: boolean
    parentId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
  }

  export type StudentParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }
  export type StudentParentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $StudentParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      studentId: string
      parentId: string
      isPrimary: boolean
      createdAt: Date
    }, ExtArgs["result"]["studentParent"]>
    composites: {}
  }

  type StudentParentGetPayload<S extends boolean | null | undefined | StudentParentDefaultArgs> = $Result.GetResult<Prisma.$StudentParentPayload, S>

  type StudentParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentParentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentParentCountAggregateInputType | true
    }

  export interface StudentParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParent'], meta: { name: 'StudentParent' } }
    /**
     * Find zero or one StudentParent that matches the filter.
     * @param {StudentParentFindUniqueArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentFindUniqueArgs>(args: SelectSubset<T, StudentParentFindUniqueArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentParent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentParentFindUniqueOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentFindFirstArgs>(args?: SelectSubset<T, StudentParentFindFirstArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParent.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParent.findMany({ take: 10 })
     * 
     * // Only select the `studentId`
     * const studentParentWithStudentIdOnly = await prisma.studentParent.findMany({ select: { studentId: true } })
     * 
     */
    findMany<T extends StudentParentFindManyArgs>(args?: SelectSubset<T, StudentParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentParent.
     * @param {StudentParentCreateArgs} args - Arguments to create a StudentParent.
     * @example
     * // Create one StudentParent
     * const StudentParent = await prisma.studentParent.create({
     *   data: {
     *     // ... data to create a StudentParent
     *   }
     * })
     * 
     */
    create<T extends StudentParentCreateArgs>(args: SelectSubset<T, StudentParentCreateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentParents.
     * @param {StudentParentCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentCreateManyArgs>(args?: SelectSubset<T, StudentParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentParents and returns the data saved in the database.
     * @param {StudentParentCreateManyAndReturnArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentParents and only return the `studentId`
     * const studentParentWithStudentIdOnly = await prisma.studentParent.createManyAndReturn({ 
     *   select: { studentId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentParentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentParentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentParent.
     * @param {StudentParentDeleteArgs} args - Arguments to delete one StudentParent.
     * @example
     * // Delete one StudentParent
     * const StudentParent = await prisma.studentParent.delete({
     *   where: {
     *     // ... filter to delete one StudentParent
     *   }
     * })
     * 
     */
    delete<T extends StudentParentDeleteArgs>(args: SelectSubset<T, StudentParentDeleteArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentParent.
     * @param {StudentParentUpdateArgs} args - Arguments to update one StudentParent.
     * @example
     * // Update one StudentParent
     * const studentParent = await prisma.studentParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentUpdateArgs>(args: SelectSubset<T, StudentParentUpdateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentDeleteManyArgs>(args?: SelectSubset<T, StudentParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentUpdateManyArgs>(args: SelectSubset<T, StudentParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentParent.
     * @param {StudentParentUpsertArgs} args - Arguments to update or create a StudentParent.
     * @example
     * // Update or create a StudentParent
     * const studentParent = await prisma.studentParent.upsert({
     *   create: {
     *     // ... data to create a StudentParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParent we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentUpsertArgs>(args: SelectSubset<T, StudentParentUpsertArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParent.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentCountArgs>(
      args?: Subset<T, StudentParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentAggregateArgs>(args: Subset<T, StudentParentAggregateArgs>): Prisma.PrismaPromise<GetStudentParentAggregateType<T>>

    /**
     * Group by StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParent model
   */
  readonly fields: StudentParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParent model
   */ 
  interface StudentParentFieldRefs {
    readonly studentId: FieldRef<"StudentParent", 'String'>
    readonly parentId: FieldRef<"StudentParent", 'String'>
    readonly isPrimary: FieldRef<"StudentParent", 'Boolean'>
    readonly createdAt: FieldRef<"StudentParent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentParent findUnique
   */
  export type StudentParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findUniqueOrThrow
   */
  export type StudentParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findFirst
   */
  export type StudentParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findFirstOrThrow
   */
  export type StudentParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findMany
   */
  export type StudentParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent create
   */
  export type StudentParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParent.
     */
    data: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
  }

  /**
   * StudentParent createMany
   */
  export type StudentParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentParent createManyAndReturn
   */
  export type StudentParentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentParent update
   */
  export type StudentParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParent.
     */
    data: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
    /**
     * Choose, which StudentParent to update.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent updateMany
   */
  export type StudentParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
  }

  /**
   * StudentParent upsert
   */
  export type StudentParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParent to update in case it exists.
     */
    where: StudentParentWhereUniqueInput
    /**
     * In case the StudentParent found by the `where` argument doesn't exist, create a new StudentParent with this data.
     */
    create: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
    /**
     * In case the StudentParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
  }

  /**
   * StudentParent delete
   */
  export type StudentParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter which StudentParent to delete.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent deleteMany
   */
  export type StudentParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentWhereInput
  }

  /**
   * StudentParent without action
   */
  export type StudentParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
  }


  /**
   * Model Prospect
   */

  export type AggregateProspect = {
    _count: ProspectCountAggregateOutputType | null
    _avg: ProspectAvgAggregateOutputType | null
    _sum: ProspectSumAggregateOutputType | null
    _min: ProspectMinAggregateOutputType | null
    _max: ProspectMaxAggregateOutputType | null
  }

  export type ProspectAvgAggregateOutputType = {
    score: number | null
  }

  export type ProspectSumAggregateOutputType = {
    score: number | null
  }

  export type ProspectMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    status: string | null
    source: string | null
    score: number | null
    stage: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProspectMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    email: string | null
    status: string | null
    source: string | null
    score: number | null
    stage: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProspectCountAggregateOutputType = {
    id: number
    tenantId: number
    firstName: number
    lastName: number
    phone: number
    email: number
    status: number
    source: number
    score: number
    stage: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProspectAvgAggregateInputType = {
    score?: true
  }

  export type ProspectSumAggregateInputType = {
    score?: true
  }

  export type ProspectMinAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    status?: true
    source?: true
    score?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProspectMaxAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    status?: true
    source?: true
    score?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProspectCountAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    phone?: true
    email?: true
    status?: true
    source?: true
    score?: true
    stage?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProspectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prospect to aggregate.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prospects
    **/
    _count?: true | ProspectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProspectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProspectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProspectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProspectMaxAggregateInputType
  }

  export type GetProspectAggregateType<T extends ProspectAggregateArgs> = {
        [P in keyof T & keyof AggregateProspect]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProspect[P]>
      : GetScalarType<T[P], AggregateProspect[P]>
  }




  export type ProspectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProspectWhereInput
    orderBy?: ProspectOrderByWithAggregationInput | ProspectOrderByWithAggregationInput[]
    by: ProspectScalarFieldEnum[] | ProspectScalarFieldEnum
    having?: ProspectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProspectCountAggregateInputType | true
    _avg?: ProspectAvgAggregateInputType
    _sum?: ProspectSumAggregateInputType
    _min?: ProspectMinAggregateInputType
    _max?: ProspectMaxAggregateInputType
  }

  export type ProspectGroupByOutputType = {
    id: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email: string | null
    status: string
    source: string | null
    score: number | null
    stage: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProspectCountAggregateOutputType | null
    _avg: ProspectAvgAggregateOutputType | null
    _sum: ProspectSumAggregateOutputType | null
    _min: ProspectMinAggregateOutputType | null
    _max: ProspectMaxAggregateOutputType | null
  }

  type GetProspectGroupByPayload<T extends ProspectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProspectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProspectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProspectGroupByOutputType[P]>
            : GetScalarType<T[P], ProspectGroupByOutputType[P]>
        }
      >
    >


  export type ProspectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    source?: boolean
    score?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    interactions?: boolean | Prospect$interactionsArgs<ExtArgs>
    conversions?: boolean | Prospect$conversionsArgs<ExtArgs>
    examApplications?: boolean | Prospect$examApplicationsArgs<ExtArgs>
    _count?: boolean | ProspectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospect"]>

  export type ProspectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    source?: boolean
    score?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prospect"]>

  export type ProspectSelectScalar = {
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    email?: boolean
    status?: boolean
    source?: boolean
    score?: boolean
    stage?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProspectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    interactions?: boolean | Prospect$interactionsArgs<ExtArgs>
    conversions?: boolean | Prospect$conversionsArgs<ExtArgs>
    examApplications?: boolean | Prospect$examApplicationsArgs<ExtArgs>
    _count?: boolean | ProspectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProspectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ProspectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prospect"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      conversions: Prisma.$ConversionPayload<ExtArgs>[]
      examApplications: Prisma.$ExamApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      firstName: string
      lastName: string
      phone: string
      email: string | null
      status: string
      source: string | null
      score: number | null
      stage: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prospect"]>
    composites: {}
  }

  type ProspectGetPayload<S extends boolean | null | undefined | ProspectDefaultArgs> = $Result.GetResult<Prisma.$ProspectPayload, S>

  type ProspectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProspectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProspectCountAggregateInputType | true
    }

  export interface ProspectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prospect'], meta: { name: 'Prospect' } }
    /**
     * Find zero or one Prospect that matches the filter.
     * @param {ProspectFindUniqueArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProspectFindUniqueArgs>(args: SelectSubset<T, ProspectFindUniqueArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prospect that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProspectFindUniqueOrThrowArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProspectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProspectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prospect that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindFirstArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProspectFindFirstArgs>(args?: SelectSubset<T, ProspectFindFirstArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prospect that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindFirstOrThrowArgs} args - Arguments to find a Prospect
     * @example
     * // Get one Prospect
     * const prospect = await prisma.prospect.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProspectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProspectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prospects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prospects
     * const prospects = await prisma.prospect.findMany()
     * 
     * // Get first 10 Prospects
     * const prospects = await prisma.prospect.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prospectWithIdOnly = await prisma.prospect.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProspectFindManyArgs>(args?: SelectSubset<T, ProspectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prospect.
     * @param {ProspectCreateArgs} args - Arguments to create a Prospect.
     * @example
     * // Create one Prospect
     * const Prospect = await prisma.prospect.create({
     *   data: {
     *     // ... data to create a Prospect
     *   }
     * })
     * 
     */
    create<T extends ProspectCreateArgs>(args: SelectSubset<T, ProspectCreateArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prospects.
     * @param {ProspectCreateManyArgs} args - Arguments to create many Prospects.
     * @example
     * // Create many Prospects
     * const prospect = await prisma.prospect.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProspectCreateManyArgs>(args?: SelectSubset<T, ProspectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prospects and returns the data saved in the database.
     * @param {ProspectCreateManyAndReturnArgs} args - Arguments to create many Prospects.
     * @example
     * // Create many Prospects
     * const prospect = await prisma.prospect.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prospects and only return the `id`
     * const prospectWithIdOnly = await prisma.prospect.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProspectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProspectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prospect.
     * @param {ProspectDeleteArgs} args - Arguments to delete one Prospect.
     * @example
     * // Delete one Prospect
     * const Prospect = await prisma.prospect.delete({
     *   where: {
     *     // ... filter to delete one Prospect
     *   }
     * })
     * 
     */
    delete<T extends ProspectDeleteArgs>(args: SelectSubset<T, ProspectDeleteArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prospect.
     * @param {ProspectUpdateArgs} args - Arguments to update one Prospect.
     * @example
     * // Update one Prospect
     * const prospect = await prisma.prospect.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProspectUpdateArgs>(args: SelectSubset<T, ProspectUpdateArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prospects.
     * @param {ProspectDeleteManyArgs} args - Arguments to filter Prospects to delete.
     * @example
     * // Delete a few Prospects
     * const { count } = await prisma.prospect.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProspectDeleteManyArgs>(args?: SelectSubset<T, ProspectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prospects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prospects
     * const prospect = await prisma.prospect.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProspectUpdateManyArgs>(args: SelectSubset<T, ProspectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prospect.
     * @param {ProspectUpsertArgs} args - Arguments to update or create a Prospect.
     * @example
     * // Update or create a Prospect
     * const prospect = await prisma.prospect.upsert({
     *   create: {
     *     // ... data to create a Prospect
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prospect we want to update
     *   }
     * })
     */
    upsert<T extends ProspectUpsertArgs>(args: SelectSubset<T, ProspectUpsertArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prospects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectCountArgs} args - Arguments to filter Prospects to count.
     * @example
     * // Count the number of Prospects
     * const count = await prisma.prospect.count({
     *   where: {
     *     // ... the filter for the Prospects we want to count
     *   }
     * })
    **/
    count<T extends ProspectCountArgs>(
      args?: Subset<T, ProspectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProspectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prospect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProspectAggregateArgs>(args: Subset<T, ProspectAggregateArgs>): Prisma.PrismaPromise<GetProspectAggregateType<T>>

    /**
     * Group by Prospect.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProspectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProspectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProspectGroupByArgs['orderBy'] }
        : { orderBy?: ProspectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProspectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProspectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prospect model
   */
  readonly fields: ProspectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prospect.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProspectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    interactions<T extends Prospect$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Prospect$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany"> | Null>
    conversions<T extends Prospect$conversionsArgs<ExtArgs> = {}>(args?: Subset<T, Prospect$conversionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany"> | Null>
    examApplications<T extends Prospect$examApplicationsArgs<ExtArgs> = {}>(args?: Subset<T, Prospect$examApplicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prospect model
   */ 
  interface ProspectFieldRefs {
    readonly id: FieldRef<"Prospect", 'String'>
    readonly tenantId: FieldRef<"Prospect", 'String'>
    readonly firstName: FieldRef<"Prospect", 'String'>
    readonly lastName: FieldRef<"Prospect", 'String'>
    readonly phone: FieldRef<"Prospect", 'String'>
    readonly email: FieldRef<"Prospect", 'String'>
    readonly status: FieldRef<"Prospect", 'String'>
    readonly source: FieldRef<"Prospect", 'String'>
    readonly score: FieldRef<"Prospect", 'Int'>
    readonly stage: FieldRef<"Prospect", 'String'>
    readonly notes: FieldRef<"Prospect", 'String'>
    readonly createdAt: FieldRef<"Prospect", 'DateTime'>
    readonly updatedAt: FieldRef<"Prospect", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prospect findUnique
   */
  export type ProspectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect findUniqueOrThrow
   */
  export type ProspectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect findFirst
   */
  export type ProspectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prospects.
     */
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect findFirstOrThrow
   */
  export type ProspectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospect to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prospects.
     */
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect findMany
   */
  export type ProspectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter, which Prospects to fetch.
     */
    where?: ProspectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prospects to fetch.
     */
    orderBy?: ProspectOrderByWithRelationInput | ProspectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prospects.
     */
    cursor?: ProspectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prospects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prospects.
     */
    skip?: number
    distinct?: ProspectScalarFieldEnum | ProspectScalarFieldEnum[]
  }

  /**
   * Prospect create
   */
  export type ProspectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The data needed to create a Prospect.
     */
    data: XOR<ProspectCreateInput, ProspectUncheckedCreateInput>
  }

  /**
   * Prospect createMany
   */
  export type ProspectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prospects.
     */
    data: ProspectCreateManyInput | ProspectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prospect createManyAndReturn
   */
  export type ProspectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prospects.
     */
    data: ProspectCreateManyInput | ProspectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prospect update
   */
  export type ProspectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The data needed to update a Prospect.
     */
    data: XOR<ProspectUpdateInput, ProspectUncheckedUpdateInput>
    /**
     * Choose, which Prospect to update.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect updateMany
   */
  export type ProspectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prospects.
     */
    data: XOR<ProspectUpdateManyMutationInput, ProspectUncheckedUpdateManyInput>
    /**
     * Filter which Prospects to update
     */
    where?: ProspectWhereInput
  }

  /**
   * Prospect upsert
   */
  export type ProspectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * The filter to search for the Prospect to update in case it exists.
     */
    where: ProspectWhereUniqueInput
    /**
     * In case the Prospect found by the `where` argument doesn't exist, create a new Prospect with this data.
     */
    create: XOR<ProspectCreateInput, ProspectUncheckedCreateInput>
    /**
     * In case the Prospect was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProspectUpdateInput, ProspectUncheckedUpdateInput>
  }

  /**
   * Prospect delete
   */
  export type ProspectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    /**
     * Filter which Prospect to delete.
     */
    where: ProspectWhereUniqueInput
  }

  /**
   * Prospect deleteMany
   */
  export type ProspectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prospects to delete
     */
    where?: ProspectWhereInput
  }

  /**
   * Prospect.interactions
   */
  export type Prospect$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Prospect.conversions
   */
  export type Prospect$conversionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    cursor?: ConversionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Prospect.examApplications
   */
  export type Prospect$examApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    where?: ExamApplicationWhereInput
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    cursor?: ExamApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * Prospect without action
   */
  export type ProspectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    prospectId: string | null
    type: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    prospectId: string | null
    type: string | null
    content: string | null
    createdAt: Date | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    prospectId: number
    type: number
    content: number
    createdAt: number
    _all: number
  }


  export type InteractionMinAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    content?: true
    createdAt?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    content?: true
    createdAt?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    prospectId?: true
    type?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    prospectId: string
    type: string
    content: string | null
    createdAt: Date
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    prospectId?: boolean
    type?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      prospect: Prisma.$ProspectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prospectId: string
      type: string
      content: string | null
      createdAt: Date
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prospect<T extends ProspectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProspectDefaultArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */ 
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly prospectId: FieldRef<"Interaction", 'String'>
    readonly type: FieldRef<"Interaction", 'String'>
    readonly content: FieldRef<"Interaction", 'String'>
    readonly createdAt: FieldRef<"Interaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model Conversion
   */

  export type AggregateConversion = {
    _count: ConversionCountAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  export type ConversionMinAggregateOutputType = {
    id: string | null
    prospectId: string | null
    studentId: string | null
    convertedAt: Date | null
  }

  export type ConversionMaxAggregateOutputType = {
    id: string | null
    prospectId: string | null
    studentId: string | null
    convertedAt: Date | null
  }

  export type ConversionCountAggregateOutputType = {
    id: number
    prospectId: number
    studentId: number
    convertedAt: number
    _all: number
  }


  export type ConversionMinAggregateInputType = {
    id?: true
    prospectId?: true
    studentId?: true
    convertedAt?: true
  }

  export type ConversionMaxAggregateInputType = {
    id?: true
    prospectId?: true
    studentId?: true
    convertedAt?: true
  }

  export type ConversionCountAggregateInputType = {
    id?: true
    prospectId?: true
    studentId?: true
    convertedAt?: true
    _all?: true
  }

  export type ConversionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversion to aggregate.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversions
    **/
    _count?: true | ConversionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversionMaxAggregateInputType
  }

  export type GetConversionAggregateType<T extends ConversionAggregateArgs> = {
        [P in keyof T & keyof AggregateConversion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversion[P]>
      : GetScalarType<T[P], AggregateConversion[P]>
  }




  export type ConversionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionWhereInput
    orderBy?: ConversionOrderByWithAggregationInput | ConversionOrderByWithAggregationInput[]
    by: ConversionScalarFieldEnum[] | ConversionScalarFieldEnum
    having?: ConversionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversionCountAggregateInputType | true
    _min?: ConversionMinAggregateInputType
    _max?: ConversionMaxAggregateInputType
  }

  export type ConversionGroupByOutputType = {
    id: string
    prospectId: string
    studentId: string
    convertedAt: Date
    _count: ConversionCountAggregateOutputType | null
    _min: ConversionMinAggregateOutputType | null
    _max: ConversionMaxAggregateOutputType | null
  }

  type GetConversionGroupByPayload<T extends ConversionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversionGroupByOutputType[P]>
            : GetScalarType<T[P], ConversionGroupByOutputType[P]>
        }
      >
    >


  export type ConversionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    studentId?: boolean
    convertedAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prospectId?: boolean
    studentId?: boolean
    convertedAt?: boolean
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversion"]>

  export type ConversionSelectScalar = {
    id?: boolean
    prospectId?: boolean
    studentId?: boolean
    convertedAt?: boolean
  }

  export type ConversionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }
  export type ConversionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prospect?: boolean | ProspectDefaultArgs<ExtArgs>
  }

  export type $ConversionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversion"
    objects: {
      prospect: Prisma.$ProspectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prospectId: string
      studentId: string
      convertedAt: Date
    }, ExtArgs["result"]["conversion"]>
    composites: {}
  }

  type ConversionGetPayload<S extends boolean | null | undefined | ConversionDefaultArgs> = $Result.GetResult<Prisma.$ConversionPayload, S>

  type ConversionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConversionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConversionCountAggregateInputType | true
    }

  export interface ConversionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversion'], meta: { name: 'Conversion' } }
    /**
     * Find zero or one Conversion that matches the filter.
     * @param {ConversionFindUniqueArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversionFindUniqueArgs>(args: SelectSubset<T, ConversionFindUniqueArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Conversion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConversionFindUniqueOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Conversion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversionFindFirstArgs>(args?: SelectSubset<T, ConversionFindFirstArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Conversion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindFirstOrThrowArgs} args - Arguments to find a Conversion
     * @example
     * // Get one Conversion
     * const conversion = await prisma.conversion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Conversions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversions
     * const conversions = await prisma.conversion.findMany()
     * 
     * // Get first 10 Conversions
     * const conversions = await prisma.conversion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversionWithIdOnly = await prisma.conversion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversionFindManyArgs>(args?: SelectSubset<T, ConversionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Conversion.
     * @param {ConversionCreateArgs} args - Arguments to create a Conversion.
     * @example
     * // Create one Conversion
     * const Conversion = await prisma.conversion.create({
     *   data: {
     *     // ... data to create a Conversion
     *   }
     * })
     * 
     */
    create<T extends ConversionCreateArgs>(args: SelectSubset<T, ConversionCreateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Conversions.
     * @param {ConversionCreateManyArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversionCreateManyArgs>(args?: SelectSubset<T, ConversionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversions and returns the data saved in the database.
     * @param {ConversionCreateManyAndReturnArgs} args - Arguments to create many Conversions.
     * @example
     * // Create many Conversions
     * const conversion = await prisma.conversion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversions and only return the `id`
     * const conversionWithIdOnly = await prisma.conversion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Conversion.
     * @param {ConversionDeleteArgs} args - Arguments to delete one Conversion.
     * @example
     * // Delete one Conversion
     * const Conversion = await prisma.conversion.delete({
     *   where: {
     *     // ... filter to delete one Conversion
     *   }
     * })
     * 
     */
    delete<T extends ConversionDeleteArgs>(args: SelectSubset<T, ConversionDeleteArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Conversion.
     * @param {ConversionUpdateArgs} args - Arguments to update one Conversion.
     * @example
     * // Update one Conversion
     * const conversion = await prisma.conversion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversionUpdateArgs>(args: SelectSubset<T, ConversionUpdateArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Conversions.
     * @param {ConversionDeleteManyArgs} args - Arguments to filter Conversions to delete.
     * @example
     * // Delete a few Conversions
     * const { count } = await prisma.conversion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversionDeleteManyArgs>(args?: SelectSubset<T, ConversionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversions
     * const conversion = await prisma.conversion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversionUpdateManyArgs>(args: SelectSubset<T, ConversionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversion.
     * @param {ConversionUpsertArgs} args - Arguments to update or create a Conversion.
     * @example
     * // Update or create a Conversion
     * const conversion = await prisma.conversion.upsert({
     *   create: {
     *     // ... data to create a Conversion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversion we want to update
     *   }
     * })
     */
    upsert<T extends ConversionUpsertArgs>(args: SelectSubset<T, ConversionUpsertArgs<ExtArgs>>): Prisma__ConversionClient<$Result.GetResult<Prisma.$ConversionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Conversions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionCountArgs} args - Arguments to filter Conversions to count.
     * @example
     * // Count the number of Conversions
     * const count = await prisma.conversion.count({
     *   where: {
     *     // ... the filter for the Conversions we want to count
     *   }
     * })
    **/
    count<T extends ConversionCountArgs>(
      args?: Subset<T, ConversionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversionAggregateArgs>(args: Subset<T, ConversionAggregateArgs>): Prisma.PrismaPromise<GetConversionAggregateType<T>>

    /**
     * Group by Conversion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversionGroupByArgs['orderBy'] }
        : { orderBy?: ConversionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversion model
   */
  readonly fields: ConversionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prospect<T extends ProspectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProspectDefaultArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversion model
   */ 
  interface ConversionFieldRefs {
    readonly id: FieldRef<"Conversion", 'String'>
    readonly prospectId: FieldRef<"Conversion", 'String'>
    readonly studentId: FieldRef<"Conversion", 'String'>
    readonly convertedAt: FieldRef<"Conversion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversion findUnique
   */
  export type ConversionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findUniqueOrThrow
   */
  export type ConversionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion findFirst
   */
  export type ConversionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findFirstOrThrow
   */
  export type ConversionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversion to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversions.
     */
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion findMany
   */
  export type ConversionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter, which Conversions to fetch.
     */
    where?: ConversionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversions to fetch.
     */
    orderBy?: ConversionOrderByWithRelationInput | ConversionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversions.
     */
    cursor?: ConversionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversions.
     */
    skip?: number
    distinct?: ConversionScalarFieldEnum | ConversionScalarFieldEnum[]
  }

  /**
   * Conversion create
   */
  export type ConversionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversion.
     */
    data: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
  }

  /**
   * Conversion createMany
   */
  export type ConversionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversion createManyAndReturn
   */
  export type ConversionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Conversions.
     */
    data: ConversionCreateManyInput | ConversionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversion update
   */
  export type ConversionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversion.
     */
    data: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
    /**
     * Choose, which Conversion to update.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion updateMany
   */
  export type ConversionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversions.
     */
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyInput>
    /**
     * Filter which Conversions to update
     */
    where?: ConversionWhereInput
  }

  /**
   * Conversion upsert
   */
  export type ConversionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversion to update in case it exists.
     */
    where: ConversionWhereUniqueInput
    /**
     * In case the Conversion found by the `where` argument doesn't exist, create a new Conversion with this data.
     */
    create: XOR<ConversionCreateInput, ConversionUncheckedCreateInput>
    /**
     * In case the Conversion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversionUpdateInput, ConversionUncheckedUpdateInput>
  }

  /**
   * Conversion delete
   */
  export type ConversionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
    /**
     * Filter which Conversion to delete.
     */
    where: ConversionWhereUniqueInput
  }

  /**
   * Conversion deleteMany
   */
  export type ConversionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversions to delete
     */
    where?: ConversionWhereInput
  }

  /**
   * Conversion without action
   */
  export type ConversionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversion
     */
    select?: ConversionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversionInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    duration: number | null
  }

  export type ExamSumAggregateOutputType = {
    duration: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    name: string | null
    date: Date | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    name: string | null
    date: Date | null
    duration: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    tenantId: number
    campusId: number
    name: number
    date: number
    duration: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    duration?: true
  }

  export type ExamSumAggregateInputType = {
    duration?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    name?: true
    date?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    name?: true
    date?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    name?: true
    date?: true
    duration?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    tenantId: string
    campusId: string
    name: string
    date: Date
    duration: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    name?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    sessions?: boolean | Exam$sessionsArgs<ExtArgs>
    applications?: boolean | Exam$applicationsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    name?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    name?: boolean
    date?: boolean
    duration?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    sessions?: boolean | Exam$sessionsArgs<ExtArgs>
    applications?: boolean | Exam$applicationsArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      campus: Prisma.$CampusPayload<ExtArgs>
      sessions: Prisma.$ExamSessionPayload<ExtArgs>[]
      applications: Prisma.$ExamApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      campusId: string
      name: string
      date: Date
      duration: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends Exam$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findMany"> | Null>
    applications<T extends Exam$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly tenantId: FieldRef<"Exam", 'String'>
    readonly campusId: FieldRef<"Exam", 'String'>
    readonly name: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly duration: FieldRef<"Exam", 'Int'>
    readonly status: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam.sessions
   */
  export type Exam$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    where?: ExamSessionWhereInput
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    cursor?: ExamSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * Exam.applications
   */
  export type Exam$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    where?: ExamApplicationWhereInput
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    cursor?: ExamApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamSession
   */

  export type AggregateExamSession = {
    _count: ExamSessionCountAggregateOutputType | null
    _avg: ExamSessionAvgAggregateOutputType | null
    _sum: ExamSessionSumAggregateOutputType | null
    _min: ExamSessionMinAggregateOutputType | null
    _max: ExamSessionMaxAggregateOutputType | null
  }

  export type ExamSessionAvgAggregateOutputType = {
    capacity: number | null
  }

  export type ExamSessionSumAggregateOutputType = {
    capacity: number | null
  }

  export type ExamSessionMinAggregateOutputType = {
    id: string | null
    examId: string | null
    campusId: string | null
    room: string | null
    capacity: number | null
    startTime: Date | null
    createdAt: Date | null
  }

  export type ExamSessionMaxAggregateOutputType = {
    id: string | null
    examId: string | null
    campusId: string | null
    room: string | null
    capacity: number | null
    startTime: Date | null
    createdAt: Date | null
  }

  export type ExamSessionCountAggregateOutputType = {
    id: number
    examId: number
    campusId: number
    room: number
    capacity: number
    startTime: number
    createdAt: number
    _all: number
  }


  export type ExamSessionAvgAggregateInputType = {
    capacity?: true
  }

  export type ExamSessionSumAggregateInputType = {
    capacity?: true
  }

  export type ExamSessionMinAggregateInputType = {
    id?: true
    examId?: true
    campusId?: true
    room?: true
    capacity?: true
    startTime?: true
    createdAt?: true
  }

  export type ExamSessionMaxAggregateInputType = {
    id?: true
    examId?: true
    campusId?: true
    room?: true
    capacity?: true
    startTime?: true
    createdAt?: true
  }

  export type ExamSessionCountAggregateInputType = {
    id?: true
    examId?: true
    campusId?: true
    room?: true
    capacity?: true
    startTime?: true
    createdAt?: true
    _all?: true
  }

  export type ExamSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSession to aggregate.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamSessions
    **/
    _count?: true | ExamSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamSessionMaxAggregateInputType
  }

  export type GetExamSessionAggregateType<T extends ExamSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamSession[P]>
      : GetScalarType<T[P], AggregateExamSession[P]>
  }




  export type ExamSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamSessionWhereInput
    orderBy?: ExamSessionOrderByWithAggregationInput | ExamSessionOrderByWithAggregationInput[]
    by: ExamSessionScalarFieldEnum[] | ExamSessionScalarFieldEnum
    having?: ExamSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamSessionCountAggregateInputType | true
    _avg?: ExamSessionAvgAggregateInputType
    _sum?: ExamSessionSumAggregateInputType
    _min?: ExamSessionMinAggregateInputType
    _max?: ExamSessionMaxAggregateInputType
  }

  export type ExamSessionGroupByOutputType = {
    id: string
    examId: string
    campusId: string
    room: string
    capacity: number
    startTime: Date
    createdAt: Date
    _count: ExamSessionCountAggregateOutputType | null
    _avg: ExamSessionAvgAggregateOutputType | null
    _sum: ExamSessionSumAggregateOutputType | null
    _min: ExamSessionMinAggregateOutputType | null
    _max: ExamSessionMaxAggregateOutputType | null
  }

  type GetExamSessionGroupByPayload<T extends ExamSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamSessionGroupByOutputType[P]>
        }
      >
    >


  export type ExamSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    campusId?: boolean
    room?: boolean
    capacity?: boolean
    startTime?: boolean
    createdAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    admissionTickets?: boolean | ExamSession$admissionTicketsArgs<ExtArgs>
    _count?: boolean | ExamSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSession"]>

  export type ExamSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    campusId?: boolean
    room?: boolean
    capacity?: boolean
    startTime?: boolean
    createdAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examSession"]>

  export type ExamSessionSelectScalar = {
    id?: boolean
    examId?: boolean
    campusId?: boolean
    room?: boolean
    capacity?: boolean
    startTime?: boolean
    createdAt?: boolean
  }

  export type ExamSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    admissionTickets?: boolean | ExamSession$admissionTicketsArgs<ExtArgs>
    _count?: boolean | ExamSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
  }

  export type $ExamSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamSession"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      campus: Prisma.$CampusPayload<ExtArgs>
      admissionTickets: Prisma.$AdmissionTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examId: string
      campusId: string
      room: string
      capacity: number
      startTime: Date
      createdAt: Date
    }, ExtArgs["result"]["examSession"]>
    composites: {}
  }

  type ExamSessionGetPayload<S extends boolean | null | undefined | ExamSessionDefaultArgs> = $Result.GetResult<Prisma.$ExamSessionPayload, S>

  type ExamSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamSessionCountAggregateInputType | true
    }

  export interface ExamSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamSession'], meta: { name: 'ExamSession' } }
    /**
     * Find zero or one ExamSession that matches the filter.
     * @param {ExamSessionFindUniqueArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamSessionFindUniqueArgs>(args: SelectSubset<T, ExamSessionFindUniqueArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamSessionFindUniqueOrThrowArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindFirstArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamSessionFindFirstArgs>(args?: SelectSubset<T, ExamSessionFindFirstArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindFirstOrThrowArgs} args - Arguments to find a ExamSession
     * @example
     * // Get one ExamSession
     * const examSession = await prisma.examSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamSessions
     * const examSessions = await prisma.examSession.findMany()
     * 
     * // Get first 10 ExamSessions
     * const examSessions = await prisma.examSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examSessionWithIdOnly = await prisma.examSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamSessionFindManyArgs>(args?: SelectSubset<T, ExamSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamSession.
     * @param {ExamSessionCreateArgs} args - Arguments to create a ExamSession.
     * @example
     * // Create one ExamSession
     * const ExamSession = await prisma.examSession.create({
     *   data: {
     *     // ... data to create a ExamSession
     *   }
     * })
     * 
     */
    create<T extends ExamSessionCreateArgs>(args: SelectSubset<T, ExamSessionCreateArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamSessions.
     * @param {ExamSessionCreateManyArgs} args - Arguments to create many ExamSessions.
     * @example
     * // Create many ExamSessions
     * const examSession = await prisma.examSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamSessionCreateManyArgs>(args?: SelectSubset<T, ExamSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamSessions and returns the data saved in the database.
     * @param {ExamSessionCreateManyAndReturnArgs} args - Arguments to create many ExamSessions.
     * @example
     * // Create many ExamSessions
     * const examSession = await prisma.examSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamSessions and only return the `id`
     * const examSessionWithIdOnly = await prisma.examSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExamSession.
     * @param {ExamSessionDeleteArgs} args - Arguments to delete one ExamSession.
     * @example
     * // Delete one ExamSession
     * const ExamSession = await prisma.examSession.delete({
     *   where: {
     *     // ... filter to delete one ExamSession
     *   }
     * })
     * 
     */
    delete<T extends ExamSessionDeleteArgs>(args: SelectSubset<T, ExamSessionDeleteArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamSession.
     * @param {ExamSessionUpdateArgs} args - Arguments to update one ExamSession.
     * @example
     * // Update one ExamSession
     * const examSession = await prisma.examSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamSessionUpdateArgs>(args: SelectSubset<T, ExamSessionUpdateArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamSessions.
     * @param {ExamSessionDeleteManyArgs} args - Arguments to filter ExamSessions to delete.
     * @example
     * // Delete a few ExamSessions
     * const { count } = await prisma.examSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamSessionDeleteManyArgs>(args?: SelectSubset<T, ExamSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamSessions
     * const examSession = await prisma.examSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamSessionUpdateManyArgs>(args: SelectSubset<T, ExamSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamSession.
     * @param {ExamSessionUpsertArgs} args - Arguments to update or create a ExamSession.
     * @example
     * // Update or create a ExamSession
     * const examSession = await prisma.examSession.upsert({
     *   create: {
     *     // ... data to create a ExamSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamSession we want to update
     *   }
     * })
     */
    upsert<T extends ExamSessionUpsertArgs>(args: SelectSubset<T, ExamSessionUpsertArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionCountArgs} args - Arguments to filter ExamSessions to count.
     * @example
     * // Count the number of ExamSessions
     * const count = await prisma.examSession.count({
     *   where: {
     *     // ... the filter for the ExamSessions we want to count
     *   }
     * })
    **/
    count<T extends ExamSessionCountArgs>(
      args?: Subset<T, ExamSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamSessionAggregateArgs>(args: Subset<T, ExamSessionAggregateArgs>): Prisma.PrismaPromise<GetExamSessionAggregateType<T>>

    /**
     * Group by ExamSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamSessionGroupByArgs['orderBy'] }
        : { orderBy?: ExamSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamSession model
   */
  readonly fields: ExamSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    admissionTickets<T extends ExamSession$admissionTicketsArgs<ExtArgs> = {}>(args?: Subset<T, ExamSession$admissionTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamSession model
   */ 
  interface ExamSessionFieldRefs {
    readonly id: FieldRef<"ExamSession", 'String'>
    readonly examId: FieldRef<"ExamSession", 'String'>
    readonly campusId: FieldRef<"ExamSession", 'String'>
    readonly room: FieldRef<"ExamSession", 'String'>
    readonly capacity: FieldRef<"ExamSession", 'Int'>
    readonly startTime: FieldRef<"ExamSession", 'DateTime'>
    readonly createdAt: FieldRef<"ExamSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamSession findUnique
   */
  export type ExamSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession findUniqueOrThrow
   */
  export type ExamSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession findFirst
   */
  export type ExamSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSessions.
     */
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession findFirstOrThrow
   */
  export type ExamSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSession to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamSessions.
     */
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession findMany
   */
  export type ExamSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExamSessions to fetch.
     */
    where?: ExamSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamSessions to fetch.
     */
    orderBy?: ExamSessionOrderByWithRelationInput | ExamSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamSessions.
     */
    cursor?: ExamSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamSessions.
     */
    skip?: number
    distinct?: ExamSessionScalarFieldEnum | ExamSessionScalarFieldEnum[]
  }

  /**
   * ExamSession create
   */
  export type ExamSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamSession.
     */
    data: XOR<ExamSessionCreateInput, ExamSessionUncheckedCreateInput>
  }

  /**
   * ExamSession createMany
   */
  export type ExamSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamSessions.
     */
    data: ExamSessionCreateManyInput | ExamSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamSession createManyAndReturn
   */
  export type ExamSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExamSessions.
     */
    data: ExamSessionCreateManyInput | ExamSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamSession update
   */
  export type ExamSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamSession.
     */
    data: XOR<ExamSessionUpdateInput, ExamSessionUncheckedUpdateInput>
    /**
     * Choose, which ExamSession to update.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession updateMany
   */
  export type ExamSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamSessions.
     */
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyInput>
    /**
     * Filter which ExamSessions to update
     */
    where?: ExamSessionWhereInput
  }

  /**
   * ExamSession upsert
   */
  export type ExamSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamSession to update in case it exists.
     */
    where: ExamSessionWhereUniqueInput
    /**
     * In case the ExamSession found by the `where` argument doesn't exist, create a new ExamSession with this data.
     */
    create: XOR<ExamSessionCreateInput, ExamSessionUncheckedCreateInput>
    /**
     * In case the ExamSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamSessionUpdateInput, ExamSessionUncheckedUpdateInput>
  }

  /**
   * ExamSession delete
   */
  export type ExamSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
    /**
     * Filter which ExamSession to delete.
     */
    where: ExamSessionWhereUniqueInput
  }

  /**
   * ExamSession deleteMany
   */
  export type ExamSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamSessions to delete
     */
    where?: ExamSessionWhereInput
  }

  /**
   * ExamSession.admissionTickets
   */
  export type ExamSession$admissionTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    where?: AdmissionTicketWhereInput
    orderBy?: AdmissionTicketOrderByWithRelationInput | AdmissionTicketOrderByWithRelationInput[]
    cursor?: AdmissionTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionTicketScalarFieldEnum | AdmissionTicketScalarFieldEnum[]
  }

  /**
   * ExamSession without action
   */
  export type ExamSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamSession
     */
    select?: ExamSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamSessionInclude<ExtArgs> | null
  }


  /**
   * Model ExamApplication
   */

  export type AggregateExamApplication = {
    _count: ExamApplicationCountAggregateOutputType | null
    _avg: ExamApplicationAvgAggregateOutputType | null
    _sum: ExamApplicationSumAggregateOutputType | null
    _min: ExamApplicationMinAggregateOutputType | null
    _max: ExamApplicationMaxAggregateOutputType | null
  }

  export type ExamApplicationAvgAggregateOutputType = {
    score: number | null
  }

  export type ExamApplicationSumAggregateOutputType = {
    score: number | null
  }

  export type ExamApplicationMinAggregateOutputType = {
    id: string | null
    examId: string | null
    prospectId: string | null
    studentId: string | null
    status: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamApplicationMaxAggregateOutputType = {
    id: string | null
    examId: string | null
    prospectId: string | null
    studentId: string | null
    status: string | null
    score: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamApplicationCountAggregateOutputType = {
    id: number
    examId: number
    prospectId: number
    studentId: number
    status: number
    score: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamApplicationAvgAggregateInputType = {
    score?: true
  }

  export type ExamApplicationSumAggregateInputType = {
    score?: true
  }

  export type ExamApplicationMinAggregateInputType = {
    id?: true
    examId?: true
    prospectId?: true
    studentId?: true
    status?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamApplicationMaxAggregateInputType = {
    id?: true
    examId?: true
    prospectId?: true
    studentId?: true
    status?: true
    score?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamApplicationCountAggregateInputType = {
    id?: true
    examId?: true
    prospectId?: true
    studentId?: true
    status?: true
    score?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamApplication to aggregate.
     */
    where?: ExamApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamApplications to fetch.
     */
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamApplications
    **/
    _count?: true | ExamApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamApplicationMaxAggregateInputType
  }

  export type GetExamApplicationAggregateType<T extends ExamApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateExamApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamApplication[P]>
      : GetScalarType<T[P], AggregateExamApplication[P]>
  }




  export type ExamApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamApplicationWhereInput
    orderBy?: ExamApplicationOrderByWithAggregationInput | ExamApplicationOrderByWithAggregationInput[]
    by: ExamApplicationScalarFieldEnum[] | ExamApplicationScalarFieldEnum
    having?: ExamApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamApplicationCountAggregateInputType | true
    _avg?: ExamApplicationAvgAggregateInputType
    _sum?: ExamApplicationSumAggregateInputType
    _min?: ExamApplicationMinAggregateInputType
    _max?: ExamApplicationMaxAggregateInputType
  }

  export type ExamApplicationGroupByOutputType = {
    id: string
    examId: string
    prospectId: string | null
    studentId: string | null
    status: string
    score: number | null
    createdAt: Date
    updatedAt: Date
    _count: ExamApplicationCountAggregateOutputType | null
    _avg: ExamApplicationAvgAggregateOutputType | null
    _sum: ExamApplicationSumAggregateOutputType | null
    _min: ExamApplicationMinAggregateOutputType | null
    _max: ExamApplicationMaxAggregateOutputType | null
  }

  type GetExamApplicationGroupByPayload<T extends ExamApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ExamApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ExamApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    prospectId?: boolean
    studentId?: boolean
    status?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    prospect?: boolean | ExamApplication$prospectArgs<ExtArgs>
    student?: boolean | ExamApplication$studentArgs<ExtArgs>
    admissionTicket?: boolean | ExamApplication$admissionTicketArgs<ExtArgs>
  }, ExtArgs["result"]["examApplication"]>

  export type ExamApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    prospectId?: boolean
    studentId?: boolean
    status?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    prospect?: boolean | ExamApplication$prospectArgs<ExtArgs>
    student?: boolean | ExamApplication$studentArgs<ExtArgs>
  }, ExtArgs["result"]["examApplication"]>

  export type ExamApplicationSelectScalar = {
    id?: boolean
    examId?: boolean
    prospectId?: boolean
    studentId?: boolean
    status?: boolean
    score?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    prospect?: boolean | ExamApplication$prospectArgs<ExtArgs>
    student?: boolean | ExamApplication$studentArgs<ExtArgs>
    admissionTicket?: boolean | ExamApplication$admissionTicketArgs<ExtArgs>
  }
  export type ExamApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    prospect?: boolean | ExamApplication$prospectArgs<ExtArgs>
    student?: boolean | ExamApplication$studentArgs<ExtArgs>
  }

  export type $ExamApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamApplication"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      prospect: Prisma.$ProspectPayload<ExtArgs> | null
      student: Prisma.$StudentPayload<ExtArgs> | null
      admissionTicket: Prisma.$AdmissionTicketPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examId: string
      prospectId: string | null
      studentId: string | null
      status: string
      score: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examApplication"]>
    composites: {}
  }

  type ExamApplicationGetPayload<S extends boolean | null | undefined | ExamApplicationDefaultArgs> = $Result.GetResult<Prisma.$ExamApplicationPayload, S>

  type ExamApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamApplicationCountAggregateInputType | true
    }

  export interface ExamApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamApplication'], meta: { name: 'ExamApplication' } }
    /**
     * Find zero or one ExamApplication that matches the filter.
     * @param {ExamApplicationFindUniqueArgs} args - Arguments to find a ExamApplication
     * @example
     * // Get one ExamApplication
     * const examApplication = await prisma.examApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamApplicationFindUniqueArgs>(args: SelectSubset<T, ExamApplicationFindUniqueArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExamApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamApplicationFindUniqueOrThrowArgs} args - Arguments to find a ExamApplication
     * @example
     * // Get one ExamApplication
     * const examApplication = await prisma.examApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExamApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationFindFirstArgs} args - Arguments to find a ExamApplication
     * @example
     * // Get one ExamApplication
     * const examApplication = await prisma.examApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamApplicationFindFirstArgs>(args?: SelectSubset<T, ExamApplicationFindFirstArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExamApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationFindFirstOrThrowArgs} args - Arguments to find a ExamApplication
     * @example
     * // Get one ExamApplication
     * const examApplication = await prisma.examApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExamApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamApplications
     * const examApplications = await prisma.examApplication.findMany()
     * 
     * // Get first 10 ExamApplications
     * const examApplications = await prisma.examApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examApplicationWithIdOnly = await prisma.examApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamApplicationFindManyArgs>(args?: SelectSubset<T, ExamApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExamApplication.
     * @param {ExamApplicationCreateArgs} args - Arguments to create a ExamApplication.
     * @example
     * // Create one ExamApplication
     * const ExamApplication = await prisma.examApplication.create({
     *   data: {
     *     // ... data to create a ExamApplication
     *   }
     * })
     * 
     */
    create<T extends ExamApplicationCreateArgs>(args: SelectSubset<T, ExamApplicationCreateArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExamApplications.
     * @param {ExamApplicationCreateManyArgs} args - Arguments to create many ExamApplications.
     * @example
     * // Create many ExamApplications
     * const examApplication = await prisma.examApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamApplicationCreateManyArgs>(args?: SelectSubset<T, ExamApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamApplications and returns the data saved in the database.
     * @param {ExamApplicationCreateManyAndReturnArgs} args - Arguments to create many ExamApplications.
     * @example
     * // Create many ExamApplications
     * const examApplication = await prisma.examApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamApplications and only return the `id`
     * const examApplicationWithIdOnly = await prisma.examApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExamApplication.
     * @param {ExamApplicationDeleteArgs} args - Arguments to delete one ExamApplication.
     * @example
     * // Delete one ExamApplication
     * const ExamApplication = await prisma.examApplication.delete({
     *   where: {
     *     // ... filter to delete one ExamApplication
     *   }
     * })
     * 
     */
    delete<T extends ExamApplicationDeleteArgs>(args: SelectSubset<T, ExamApplicationDeleteArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExamApplication.
     * @param {ExamApplicationUpdateArgs} args - Arguments to update one ExamApplication.
     * @example
     * // Update one ExamApplication
     * const examApplication = await prisma.examApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamApplicationUpdateArgs>(args: SelectSubset<T, ExamApplicationUpdateArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExamApplications.
     * @param {ExamApplicationDeleteManyArgs} args - Arguments to filter ExamApplications to delete.
     * @example
     * // Delete a few ExamApplications
     * const { count } = await prisma.examApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamApplicationDeleteManyArgs>(args?: SelectSubset<T, ExamApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamApplications
     * const examApplication = await prisma.examApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamApplicationUpdateManyArgs>(args: SelectSubset<T, ExamApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamApplication.
     * @param {ExamApplicationUpsertArgs} args - Arguments to update or create a ExamApplication.
     * @example
     * // Update or create a ExamApplication
     * const examApplication = await prisma.examApplication.upsert({
     *   create: {
     *     // ... data to create a ExamApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamApplication we want to update
     *   }
     * })
     */
    upsert<T extends ExamApplicationUpsertArgs>(args: SelectSubset<T, ExamApplicationUpsertArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExamApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationCountArgs} args - Arguments to filter ExamApplications to count.
     * @example
     * // Count the number of ExamApplications
     * const count = await prisma.examApplication.count({
     *   where: {
     *     // ... the filter for the ExamApplications we want to count
     *   }
     * })
    **/
    count<T extends ExamApplicationCountArgs>(
      args?: Subset<T, ExamApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamApplicationAggregateArgs>(args: Subset<T, ExamApplicationAggregateArgs>): Prisma.PrismaPromise<GetExamApplicationAggregateType<T>>

    /**
     * Group by ExamApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ExamApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamApplication model
   */
  readonly fields: ExamApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prospect<T extends ExamApplication$prospectArgs<ExtArgs> = {}>(args?: Subset<T, ExamApplication$prospectArgs<ExtArgs>>): Prisma__ProspectClient<$Result.GetResult<Prisma.$ProspectPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    student<T extends ExamApplication$studentArgs<ExtArgs> = {}>(args?: Subset<T, ExamApplication$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    admissionTicket<T extends ExamApplication$admissionTicketArgs<ExtArgs> = {}>(args?: Subset<T, ExamApplication$admissionTicketArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamApplication model
   */ 
  interface ExamApplicationFieldRefs {
    readonly id: FieldRef<"ExamApplication", 'String'>
    readonly examId: FieldRef<"ExamApplication", 'String'>
    readonly prospectId: FieldRef<"ExamApplication", 'String'>
    readonly studentId: FieldRef<"ExamApplication", 'String'>
    readonly status: FieldRef<"ExamApplication", 'String'>
    readonly score: FieldRef<"ExamApplication", 'Float'>
    readonly createdAt: FieldRef<"ExamApplication", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamApplication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamApplication findUnique
   */
  export type ExamApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ExamApplication to fetch.
     */
    where: ExamApplicationWhereUniqueInput
  }

  /**
   * ExamApplication findUniqueOrThrow
   */
  export type ExamApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ExamApplication to fetch.
     */
    where: ExamApplicationWhereUniqueInput
  }

  /**
   * ExamApplication findFirst
   */
  export type ExamApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ExamApplication to fetch.
     */
    where?: ExamApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamApplications to fetch.
     */
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamApplications.
     */
    cursor?: ExamApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamApplications.
     */
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * ExamApplication findFirstOrThrow
   */
  export type ExamApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ExamApplication to fetch.
     */
    where?: ExamApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamApplications to fetch.
     */
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamApplications.
     */
    cursor?: ExamApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamApplications.
     */
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * ExamApplication findMany
   */
  export type ExamApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter, which ExamApplications to fetch.
     */
    where?: ExamApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamApplications to fetch.
     */
    orderBy?: ExamApplicationOrderByWithRelationInput | ExamApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamApplications.
     */
    cursor?: ExamApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamApplications.
     */
    skip?: number
    distinct?: ExamApplicationScalarFieldEnum | ExamApplicationScalarFieldEnum[]
  }

  /**
   * ExamApplication create
   */
  export type ExamApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamApplication.
     */
    data: XOR<ExamApplicationCreateInput, ExamApplicationUncheckedCreateInput>
  }

  /**
   * ExamApplication createMany
   */
  export type ExamApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamApplications.
     */
    data: ExamApplicationCreateManyInput | ExamApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamApplication createManyAndReturn
   */
  export type ExamApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExamApplications.
     */
    data: ExamApplicationCreateManyInput | ExamApplicationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamApplication update
   */
  export type ExamApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamApplication.
     */
    data: XOR<ExamApplicationUpdateInput, ExamApplicationUncheckedUpdateInput>
    /**
     * Choose, which ExamApplication to update.
     */
    where: ExamApplicationWhereUniqueInput
  }

  /**
   * ExamApplication updateMany
   */
  export type ExamApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamApplications.
     */
    data: XOR<ExamApplicationUpdateManyMutationInput, ExamApplicationUncheckedUpdateManyInput>
    /**
     * Filter which ExamApplications to update
     */
    where?: ExamApplicationWhereInput
  }

  /**
   * ExamApplication upsert
   */
  export type ExamApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamApplication to update in case it exists.
     */
    where: ExamApplicationWhereUniqueInput
    /**
     * In case the ExamApplication found by the `where` argument doesn't exist, create a new ExamApplication with this data.
     */
    create: XOR<ExamApplicationCreateInput, ExamApplicationUncheckedCreateInput>
    /**
     * In case the ExamApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamApplicationUpdateInput, ExamApplicationUncheckedUpdateInput>
  }

  /**
   * ExamApplication delete
   */
  export type ExamApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
    /**
     * Filter which ExamApplication to delete.
     */
    where: ExamApplicationWhereUniqueInput
  }

  /**
   * ExamApplication deleteMany
   */
  export type ExamApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamApplications to delete
     */
    where?: ExamApplicationWhereInput
  }

  /**
   * ExamApplication.prospect
   */
  export type ExamApplication$prospectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prospect
     */
    select?: ProspectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProspectInclude<ExtArgs> | null
    where?: ProspectWhereInput
  }

  /**
   * ExamApplication.student
   */
  export type ExamApplication$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * ExamApplication.admissionTicket
   */
  export type ExamApplication$admissionTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    where?: AdmissionTicketWhereInput
  }

  /**
   * ExamApplication without action
   */
  export type ExamApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamApplication
     */
    select?: ExamApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamApplicationInclude<ExtArgs> | null
  }


  /**
   * Model AdmissionTicket
   */

  export type AggregateAdmissionTicket = {
    _count: AdmissionTicketCountAggregateOutputType | null
    _min: AdmissionTicketMinAggregateOutputType | null
    _max: AdmissionTicketMaxAggregateOutputType | null
  }

  export type AdmissionTicketMinAggregateOutputType = {
    id: string | null
    applicationId: string | null
    sessionId: string | null
    seatNumber: string | null
  }

  export type AdmissionTicketMaxAggregateOutputType = {
    id: string | null
    applicationId: string | null
    sessionId: string | null
    seatNumber: string | null
  }

  export type AdmissionTicketCountAggregateOutputType = {
    id: number
    applicationId: number
    sessionId: number
    seatNumber: number
    _all: number
  }


  export type AdmissionTicketMinAggregateInputType = {
    id?: true
    applicationId?: true
    sessionId?: true
    seatNumber?: true
  }

  export type AdmissionTicketMaxAggregateInputType = {
    id?: true
    applicationId?: true
    sessionId?: true
    seatNumber?: true
  }

  export type AdmissionTicketCountAggregateInputType = {
    id?: true
    applicationId?: true
    sessionId?: true
    seatNumber?: true
    _all?: true
  }

  export type AdmissionTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTicket to aggregate.
     */
    where?: AdmissionTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTickets to fetch.
     */
    orderBy?: AdmissionTicketOrderByWithRelationInput | AdmissionTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdmissionTickets
    **/
    _count?: true | AdmissionTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionTicketMaxAggregateInputType
  }

  export type GetAdmissionTicketAggregateType<T extends AdmissionTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmissionTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmissionTicket[P]>
      : GetScalarType<T[P], AggregateAdmissionTicket[P]>
  }




  export type AdmissionTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionTicketWhereInput
    orderBy?: AdmissionTicketOrderByWithAggregationInput | AdmissionTicketOrderByWithAggregationInput[]
    by: AdmissionTicketScalarFieldEnum[] | AdmissionTicketScalarFieldEnum
    having?: AdmissionTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionTicketCountAggregateInputType | true
    _min?: AdmissionTicketMinAggregateInputType
    _max?: AdmissionTicketMaxAggregateInputType
  }

  export type AdmissionTicketGroupByOutputType = {
    id: string
    applicationId: string
    sessionId: string
    seatNumber: string
    _count: AdmissionTicketCountAggregateOutputType | null
    _min: AdmissionTicketMinAggregateOutputType | null
    _max: AdmissionTicketMaxAggregateOutputType | null
  }

  type GetAdmissionTicketGroupByPayload<T extends AdmissionTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionTicketGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionTicketGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    sessionId?: boolean
    seatNumber?: boolean
    application?: boolean | ExamApplicationDefaultArgs<ExtArgs>
    session?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionTicket"]>

  export type AdmissionTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationId?: boolean
    sessionId?: boolean
    seatNumber?: boolean
    application?: boolean | ExamApplicationDefaultArgs<ExtArgs>
    session?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admissionTicket"]>

  export type AdmissionTicketSelectScalar = {
    id?: boolean
    applicationId?: boolean
    sessionId?: boolean
    seatNumber?: boolean
  }

  export type AdmissionTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ExamApplicationDefaultArgs<ExtArgs>
    session?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }
  export type AdmissionTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    application?: boolean | ExamApplicationDefaultArgs<ExtArgs>
    session?: boolean | ExamSessionDefaultArgs<ExtArgs>
  }

  export type $AdmissionTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdmissionTicket"
    objects: {
      application: Prisma.$ExamApplicationPayload<ExtArgs>
      session: Prisma.$ExamSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationId: string
      sessionId: string
      seatNumber: string
    }, ExtArgs["result"]["admissionTicket"]>
    composites: {}
  }

  type AdmissionTicketGetPayload<S extends boolean | null | undefined | AdmissionTicketDefaultArgs> = $Result.GetResult<Prisma.$AdmissionTicketPayload, S>

  type AdmissionTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdmissionTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdmissionTicketCountAggregateInputType | true
    }

  export interface AdmissionTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdmissionTicket'], meta: { name: 'AdmissionTicket' } }
    /**
     * Find zero or one AdmissionTicket that matches the filter.
     * @param {AdmissionTicketFindUniqueArgs} args - Arguments to find a AdmissionTicket
     * @example
     * // Get one AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionTicketFindUniqueArgs>(args: SelectSubset<T, AdmissionTicketFindUniqueArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdmissionTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdmissionTicketFindUniqueOrThrowArgs} args - Arguments to find a AdmissionTicket
     * @example
     * // Get one AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdmissionTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketFindFirstArgs} args - Arguments to find a AdmissionTicket
     * @example
     * // Get one AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionTicketFindFirstArgs>(args?: SelectSubset<T, AdmissionTicketFindFirstArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdmissionTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketFindFirstOrThrowArgs} args - Arguments to find a AdmissionTicket
     * @example
     * // Get one AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdmissionTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdmissionTickets
     * const admissionTickets = await prisma.admissionTicket.findMany()
     * 
     * // Get first 10 AdmissionTickets
     * const admissionTickets = await prisma.admissionTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionTicketWithIdOnly = await prisma.admissionTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionTicketFindManyArgs>(args?: SelectSubset<T, AdmissionTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdmissionTicket.
     * @param {AdmissionTicketCreateArgs} args - Arguments to create a AdmissionTicket.
     * @example
     * // Create one AdmissionTicket
     * const AdmissionTicket = await prisma.admissionTicket.create({
     *   data: {
     *     // ... data to create a AdmissionTicket
     *   }
     * })
     * 
     */
    create<T extends AdmissionTicketCreateArgs>(args: SelectSubset<T, AdmissionTicketCreateArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdmissionTickets.
     * @param {AdmissionTicketCreateManyArgs} args - Arguments to create many AdmissionTickets.
     * @example
     * // Create many AdmissionTickets
     * const admissionTicket = await prisma.admissionTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionTicketCreateManyArgs>(args?: SelectSubset<T, AdmissionTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdmissionTickets and returns the data saved in the database.
     * @param {AdmissionTicketCreateManyAndReturnArgs} args - Arguments to create many AdmissionTickets.
     * @example
     * // Create many AdmissionTickets
     * const admissionTicket = await prisma.admissionTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdmissionTickets and only return the `id`
     * const admissionTicketWithIdOnly = await prisma.admissionTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdmissionTicket.
     * @param {AdmissionTicketDeleteArgs} args - Arguments to delete one AdmissionTicket.
     * @example
     * // Delete one AdmissionTicket
     * const AdmissionTicket = await prisma.admissionTicket.delete({
     *   where: {
     *     // ... filter to delete one AdmissionTicket
     *   }
     * })
     * 
     */
    delete<T extends AdmissionTicketDeleteArgs>(args: SelectSubset<T, AdmissionTicketDeleteArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdmissionTicket.
     * @param {AdmissionTicketUpdateArgs} args - Arguments to update one AdmissionTicket.
     * @example
     * // Update one AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionTicketUpdateArgs>(args: SelectSubset<T, AdmissionTicketUpdateArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdmissionTickets.
     * @param {AdmissionTicketDeleteManyArgs} args - Arguments to filter AdmissionTickets to delete.
     * @example
     * // Delete a few AdmissionTickets
     * const { count } = await prisma.admissionTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionTicketDeleteManyArgs>(args?: SelectSubset<T, AdmissionTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdmissionTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdmissionTickets
     * const admissionTicket = await prisma.admissionTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionTicketUpdateManyArgs>(args: SelectSubset<T, AdmissionTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdmissionTicket.
     * @param {AdmissionTicketUpsertArgs} args - Arguments to update or create a AdmissionTicket.
     * @example
     * // Update or create a AdmissionTicket
     * const admissionTicket = await prisma.admissionTicket.upsert({
     *   create: {
     *     // ... data to create a AdmissionTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdmissionTicket we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionTicketUpsertArgs>(args: SelectSubset<T, AdmissionTicketUpsertArgs<ExtArgs>>): Prisma__AdmissionTicketClient<$Result.GetResult<Prisma.$AdmissionTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdmissionTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketCountArgs} args - Arguments to filter AdmissionTickets to count.
     * @example
     * // Count the number of AdmissionTickets
     * const count = await prisma.admissionTicket.count({
     *   where: {
     *     // ... the filter for the AdmissionTickets we want to count
     *   }
     * })
    **/
    count<T extends AdmissionTicketCountArgs>(
      args?: Subset<T, AdmissionTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdmissionTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionTicketAggregateArgs>(args: Subset<T, AdmissionTicketAggregateArgs>): Prisma.PrismaPromise<GetAdmissionTicketAggregateType<T>>

    /**
     * Group by AdmissionTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionTicketGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdmissionTicket model
   */
  readonly fields: AdmissionTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdmissionTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    application<T extends ExamApplicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamApplicationDefaultArgs<ExtArgs>>): Prisma__ExamApplicationClient<$Result.GetResult<Prisma.$ExamApplicationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends ExamSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamSessionDefaultArgs<ExtArgs>>): Prisma__ExamSessionClient<$Result.GetResult<Prisma.$ExamSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdmissionTicket model
   */ 
  interface AdmissionTicketFieldRefs {
    readonly id: FieldRef<"AdmissionTicket", 'String'>
    readonly applicationId: FieldRef<"AdmissionTicket", 'String'>
    readonly sessionId: FieldRef<"AdmissionTicket", 'String'>
    readonly seatNumber: FieldRef<"AdmissionTicket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdmissionTicket findUnique
   */
  export type AdmissionTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTicket to fetch.
     */
    where: AdmissionTicketWhereUniqueInput
  }

  /**
   * AdmissionTicket findUniqueOrThrow
   */
  export type AdmissionTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTicket to fetch.
     */
    where: AdmissionTicketWhereUniqueInput
  }

  /**
   * AdmissionTicket findFirst
   */
  export type AdmissionTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTicket to fetch.
     */
    where?: AdmissionTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTickets to fetch.
     */
    orderBy?: AdmissionTicketOrderByWithRelationInput | AdmissionTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTickets.
     */
    cursor?: AdmissionTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTickets.
     */
    distinct?: AdmissionTicketScalarFieldEnum | AdmissionTicketScalarFieldEnum[]
  }

  /**
   * AdmissionTicket findFirstOrThrow
   */
  export type AdmissionTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTicket to fetch.
     */
    where?: AdmissionTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTickets to fetch.
     */
    orderBy?: AdmissionTicketOrderByWithRelationInput | AdmissionTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdmissionTickets.
     */
    cursor?: AdmissionTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdmissionTickets.
     */
    distinct?: AdmissionTicketScalarFieldEnum | AdmissionTicketScalarFieldEnum[]
  }

  /**
   * AdmissionTicket findMany
   */
  export type AdmissionTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter, which AdmissionTickets to fetch.
     */
    where?: AdmissionTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdmissionTickets to fetch.
     */
    orderBy?: AdmissionTicketOrderByWithRelationInput | AdmissionTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdmissionTickets.
     */
    cursor?: AdmissionTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdmissionTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdmissionTickets.
     */
    skip?: number
    distinct?: AdmissionTicketScalarFieldEnum | AdmissionTicketScalarFieldEnum[]
  }

  /**
   * AdmissionTicket create
   */
  export type AdmissionTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a AdmissionTicket.
     */
    data: XOR<AdmissionTicketCreateInput, AdmissionTicketUncheckedCreateInput>
  }

  /**
   * AdmissionTicket createMany
   */
  export type AdmissionTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdmissionTickets.
     */
    data: AdmissionTicketCreateManyInput | AdmissionTicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdmissionTicket createManyAndReturn
   */
  export type AdmissionTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdmissionTickets.
     */
    data: AdmissionTicketCreateManyInput | AdmissionTicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdmissionTicket update
   */
  export type AdmissionTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a AdmissionTicket.
     */
    data: XOR<AdmissionTicketUpdateInput, AdmissionTicketUncheckedUpdateInput>
    /**
     * Choose, which AdmissionTicket to update.
     */
    where: AdmissionTicketWhereUniqueInput
  }

  /**
   * AdmissionTicket updateMany
   */
  export type AdmissionTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdmissionTickets.
     */
    data: XOR<AdmissionTicketUpdateManyMutationInput, AdmissionTicketUncheckedUpdateManyInput>
    /**
     * Filter which AdmissionTickets to update
     */
    where?: AdmissionTicketWhereInput
  }

  /**
   * AdmissionTicket upsert
   */
  export type AdmissionTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the AdmissionTicket to update in case it exists.
     */
    where: AdmissionTicketWhereUniqueInput
    /**
     * In case the AdmissionTicket found by the `where` argument doesn't exist, create a new AdmissionTicket with this data.
     */
    create: XOR<AdmissionTicketCreateInput, AdmissionTicketUncheckedCreateInput>
    /**
     * In case the AdmissionTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionTicketUpdateInput, AdmissionTicketUncheckedUpdateInput>
  }

  /**
   * AdmissionTicket delete
   */
  export type AdmissionTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
    /**
     * Filter which AdmissionTicket to delete.
     */
    where: AdmissionTicketWhereUniqueInput
  }

  /**
   * AdmissionTicket deleteMany
   */
  export type AdmissionTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdmissionTickets to delete
     */
    where?: AdmissionTicketWhereInput
  }

  /**
   * AdmissionTicket without action
   */
  export type AdmissionTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionTicket
     */
    select?: AdmissionTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionTicketInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractAvgAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    installmentCount: number | null
  }

  export type ContractSumAggregateOutputType = {
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    installmentCount: number | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    schoolYear: string | null
    studentId: string | null
    contractNo: string | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    installmentCount: number | null
    status: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    campusId: string | null
    schoolYear: string | null
    studentId: string | null
    contractNo: string | null
    totalAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    installmentCount: number | null
    status: string | null
    signedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    tenantId: number
    campusId: number
    schoolYear: number
    studentId: number
    contractNo: number
    totalAmount: number
    discountAmount: number
    netAmount: number
    installmentCount: number
    status: number
    signedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractAvgAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    netAmount?: true
    installmentCount?: true
  }

  export type ContractSumAggregateInputType = {
    totalAmount?: true
    discountAmount?: true
    netAmount?: true
    installmentCount?: true
  }

  export type ContractMinAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    studentId?: true
    contractNo?: true
    totalAmount?: true
    discountAmount?: true
    netAmount?: true
    installmentCount?: true
    status?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    studentId?: true
    contractNo?: true
    totalAmount?: true
    discountAmount?: true
    netAmount?: true
    installmentCount?: true
    status?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    tenantId?: true
    campusId?: true
    schoolYear?: true
    studentId?: true
    contractNo?: true
    totalAmount?: true
    discountAmount?: true
    netAmount?: true
    installmentCount?: true
    status?: true
    signedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _avg?: ContractAvgAggregateInputType
    _sum?: ContractSumAggregateInputType
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal
    discountAmount: Decimal
    netAmount: Decimal
    installmentCount: number
    status: string
    signedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _avg: ContractAvgAggregateOutputType | null
    _sum: ContractSumAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    studentId?: boolean
    contractNo?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    installmentCount?: boolean
    status?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    items?: boolean | Contract$itemsArgs<ExtArgs>
    installments?: boolean | Contract$installmentsArgs<ExtArgs>
    payments?: boolean | Contract$paymentsArgs<ExtArgs>
    discounts?: boolean | Contract$discountsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    studentId?: boolean
    contractNo?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    installmentCount?: boolean
    status?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    tenantId?: boolean
    campusId?: boolean
    schoolYear?: boolean
    studentId?: boolean
    contractNo?: boolean
    totalAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    installmentCount?: boolean
    status?: boolean
    signedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
    items?: boolean | Contract$itemsArgs<ExtArgs>
    installments?: boolean | Contract$installmentsArgs<ExtArgs>
    payments?: boolean | Contract$paymentsArgs<ExtArgs>
    discounts?: boolean | Contract$discountsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    campus?: boolean | CampusDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      campus: Prisma.$CampusPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
      items: Prisma.$ContractItemPayload<ExtArgs>[]
      installments: Prisma.$InstallmentPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      discounts: Prisma.$ContractDiscountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      campusId: string
      schoolYear: string
      studentId: string
      contractNo: string
      totalAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      installmentCount: number
      status: string
      signedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    campus<T extends CampusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampusDefaultArgs<ExtArgs>>): Prisma__CampusClient<$Result.GetResult<Prisma.$CampusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends Contract$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findMany"> | Null>
    installments<T extends Contract$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Contract$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    discounts<T extends Contract$discountsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */ 
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly tenantId: FieldRef<"Contract", 'String'>
    readonly campusId: FieldRef<"Contract", 'String'>
    readonly schoolYear: FieldRef<"Contract", 'String'>
    readonly studentId: FieldRef<"Contract", 'String'>
    readonly contractNo: FieldRef<"Contract", 'String'>
    readonly totalAmount: FieldRef<"Contract", 'Decimal'>
    readonly discountAmount: FieldRef<"Contract", 'Decimal'>
    readonly netAmount: FieldRef<"Contract", 'Decimal'>
    readonly installmentCount: FieldRef<"Contract", 'Int'>
    readonly status: FieldRef<"Contract", 'String'>
    readonly signedAt: FieldRef<"Contract", 'DateTime'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
  }

  /**
   * Contract.items
   */
  export type Contract$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    where?: ContractItemWhereInput
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    cursor?: ContractItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * Contract.installments
   */
  export type Contract$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    cursor?: InstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Contract.payments
   */
  export type Contract$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Contract.discounts
   */
  export type Contract$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    where?: ContractDiscountWhereInput
    orderBy?: ContractDiscountOrderByWithRelationInput | ContractDiscountOrderByWithRelationInput[]
    cursor?: ContractDiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractDiscountScalarFieldEnum | ContractDiscountScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model FeeItem
   */

  export type AggregateFeeItem = {
    _count: FeeItemCountAggregateOutputType | null
    _avg: FeeItemAvgAggregateOutputType | null
    _sum: FeeItemSumAggregateOutputType | null
    _min: FeeItemMinAggregateOutputType | null
    _max: FeeItemMaxAggregateOutputType | null
  }

  export type FeeItemAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeItemSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type FeeItemMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    schoolYear: string | null
    name: string | null
    amount: Decimal | null
    category: string | null
    isMandatory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeItemMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    schoolYear: string | null
    name: string | null
    amount: Decimal | null
    category: string | null
    isMandatory: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeeItemCountAggregateOutputType = {
    id: number
    tenantId: number
    schoolYear: number
    name: number
    amount: number
    category: number
    isMandatory: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeeItemAvgAggregateInputType = {
    amount?: true
  }

  export type FeeItemSumAggregateInputType = {
    amount?: true
  }

  export type FeeItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    schoolYear?: true
    name?: true
    amount?: true
    category?: true
    isMandatory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    schoolYear?: true
    name?: true
    amount?: true
    category?: true
    isMandatory?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeeItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    schoolYear?: true
    name?: true
    amount?: true
    category?: true
    isMandatory?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeeItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeItem to aggregate.
     */
    where?: FeeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeItems to fetch.
     */
    orderBy?: FeeItemOrderByWithRelationInput | FeeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeeItems
    **/
    _count?: true | FeeItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeeItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeeItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeeItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeeItemMaxAggregateInputType
  }

  export type GetFeeItemAggregateType<T extends FeeItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFeeItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeeItem[P]>
      : GetScalarType<T[P], AggregateFeeItem[P]>
  }




  export type FeeItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeeItemWhereInput
    orderBy?: FeeItemOrderByWithAggregationInput | FeeItemOrderByWithAggregationInput[]
    by: FeeItemScalarFieldEnum[] | FeeItemScalarFieldEnum
    having?: FeeItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeeItemCountAggregateInputType | true
    _avg?: FeeItemAvgAggregateInputType
    _sum?: FeeItemSumAggregateInputType
    _min?: FeeItemMinAggregateInputType
    _max?: FeeItemMaxAggregateInputType
  }

  export type FeeItemGroupByOutputType = {
    id: string
    tenantId: string
    schoolYear: string
    name: string
    amount: Decimal
    category: string | null
    isMandatory: boolean
    createdAt: Date
    updatedAt: Date
    _count: FeeItemCountAggregateOutputType | null
    _avg: FeeItemAvgAggregateOutputType | null
    _sum: FeeItemSumAggregateOutputType | null
    _min: FeeItemMinAggregateOutputType | null
    _max: FeeItemMaxAggregateOutputType | null
  }

  type GetFeeItemGroupByPayload<T extends FeeItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeeItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeeItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeeItemGroupByOutputType[P]>
            : GetScalarType<T[P], FeeItemGroupByOutputType[P]>
        }
      >
    >


  export type FeeItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    schoolYear?: boolean
    name?: boolean
    amount?: boolean
    category?: boolean
    isMandatory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contractItems?: boolean | FeeItem$contractItemsArgs<ExtArgs>
    _count?: boolean | FeeItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeItem"]>

  export type FeeItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    schoolYear?: boolean
    name?: boolean
    amount?: boolean
    category?: boolean
    isMandatory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feeItem"]>

  export type FeeItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    schoolYear?: boolean
    name?: boolean
    amount?: boolean
    category?: boolean
    isMandatory?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeeItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contractItems?: boolean | FeeItem$contractItemsArgs<ExtArgs>
    _count?: boolean | FeeItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeeItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $FeeItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeeItem"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contractItems: Prisma.$ContractItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      schoolYear: string
      name: string
      amount: Prisma.Decimal
      category: string | null
      isMandatory: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feeItem"]>
    composites: {}
  }

  type FeeItemGetPayload<S extends boolean | null | undefined | FeeItemDefaultArgs> = $Result.GetResult<Prisma.$FeeItemPayload, S>

  type FeeItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeeItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeeItemCountAggregateInputType | true
    }

  export interface FeeItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeeItem'], meta: { name: 'FeeItem' } }
    /**
     * Find zero or one FeeItem that matches the filter.
     * @param {FeeItemFindUniqueArgs} args - Arguments to find a FeeItem
     * @example
     * // Get one FeeItem
     * const feeItem = await prisma.feeItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeeItemFindUniqueArgs>(args: SelectSubset<T, FeeItemFindUniqueArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeeItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeeItemFindUniqueOrThrowArgs} args - Arguments to find a FeeItem
     * @example
     * // Get one FeeItem
     * const feeItem = await prisma.feeItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeeItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FeeItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeeItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemFindFirstArgs} args - Arguments to find a FeeItem
     * @example
     * // Get one FeeItem
     * const feeItem = await prisma.feeItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeeItemFindFirstArgs>(args?: SelectSubset<T, FeeItemFindFirstArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeeItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemFindFirstOrThrowArgs} args - Arguments to find a FeeItem
     * @example
     * // Get one FeeItem
     * const feeItem = await prisma.feeItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeeItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FeeItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeeItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeeItems
     * const feeItems = await prisma.feeItem.findMany()
     * 
     * // Get first 10 FeeItems
     * const feeItems = await prisma.feeItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feeItemWithIdOnly = await prisma.feeItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeeItemFindManyArgs>(args?: SelectSubset<T, FeeItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeeItem.
     * @param {FeeItemCreateArgs} args - Arguments to create a FeeItem.
     * @example
     * // Create one FeeItem
     * const FeeItem = await prisma.feeItem.create({
     *   data: {
     *     // ... data to create a FeeItem
     *   }
     * })
     * 
     */
    create<T extends FeeItemCreateArgs>(args: SelectSubset<T, FeeItemCreateArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeeItems.
     * @param {FeeItemCreateManyArgs} args - Arguments to create many FeeItems.
     * @example
     * // Create many FeeItems
     * const feeItem = await prisma.feeItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeeItemCreateManyArgs>(args?: SelectSubset<T, FeeItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeeItems and returns the data saved in the database.
     * @param {FeeItemCreateManyAndReturnArgs} args - Arguments to create many FeeItems.
     * @example
     * // Create many FeeItems
     * const feeItem = await prisma.feeItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeeItems and only return the `id`
     * const feeItemWithIdOnly = await prisma.feeItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeeItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FeeItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeeItem.
     * @param {FeeItemDeleteArgs} args - Arguments to delete one FeeItem.
     * @example
     * // Delete one FeeItem
     * const FeeItem = await prisma.feeItem.delete({
     *   where: {
     *     // ... filter to delete one FeeItem
     *   }
     * })
     * 
     */
    delete<T extends FeeItemDeleteArgs>(args: SelectSubset<T, FeeItemDeleteArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeeItem.
     * @param {FeeItemUpdateArgs} args - Arguments to update one FeeItem.
     * @example
     * // Update one FeeItem
     * const feeItem = await prisma.feeItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeeItemUpdateArgs>(args: SelectSubset<T, FeeItemUpdateArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeeItems.
     * @param {FeeItemDeleteManyArgs} args - Arguments to filter FeeItems to delete.
     * @example
     * // Delete a few FeeItems
     * const { count } = await prisma.feeItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeeItemDeleteManyArgs>(args?: SelectSubset<T, FeeItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeeItems
     * const feeItem = await prisma.feeItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeeItemUpdateManyArgs>(args: SelectSubset<T, FeeItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeeItem.
     * @param {FeeItemUpsertArgs} args - Arguments to update or create a FeeItem.
     * @example
     * // Update or create a FeeItem
     * const feeItem = await prisma.feeItem.upsert({
     *   create: {
     *     // ... data to create a FeeItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeeItem we want to update
     *   }
     * })
     */
    upsert<T extends FeeItemUpsertArgs>(args: SelectSubset<T, FeeItemUpsertArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeeItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemCountArgs} args - Arguments to filter FeeItems to count.
     * @example
     * // Count the number of FeeItems
     * const count = await prisma.feeItem.count({
     *   where: {
     *     // ... the filter for the FeeItems we want to count
     *   }
     * })
    **/
    count<T extends FeeItemCountArgs>(
      args?: Subset<T, FeeItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeeItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeeItemAggregateArgs>(args: Subset<T, FeeItemAggregateArgs>): Prisma.PrismaPromise<GetFeeItemAggregateType<T>>

    /**
     * Group by FeeItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeeItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeeItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeeItemGroupByArgs['orderBy'] }
        : { orderBy?: FeeItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeeItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeeItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeeItem model
   */
  readonly fields: FeeItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeeItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeeItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contractItems<T extends FeeItem$contractItemsArgs<ExtArgs> = {}>(args?: Subset<T, FeeItem$contractItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeeItem model
   */ 
  interface FeeItemFieldRefs {
    readonly id: FieldRef<"FeeItem", 'String'>
    readonly tenantId: FieldRef<"FeeItem", 'String'>
    readonly schoolYear: FieldRef<"FeeItem", 'String'>
    readonly name: FieldRef<"FeeItem", 'String'>
    readonly amount: FieldRef<"FeeItem", 'Decimal'>
    readonly category: FieldRef<"FeeItem", 'String'>
    readonly isMandatory: FieldRef<"FeeItem", 'Boolean'>
    readonly createdAt: FieldRef<"FeeItem", 'DateTime'>
    readonly updatedAt: FieldRef<"FeeItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeeItem findUnique
   */
  export type FeeItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter, which FeeItem to fetch.
     */
    where: FeeItemWhereUniqueInput
  }

  /**
   * FeeItem findUniqueOrThrow
   */
  export type FeeItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter, which FeeItem to fetch.
     */
    where: FeeItemWhereUniqueInput
  }

  /**
   * FeeItem findFirst
   */
  export type FeeItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter, which FeeItem to fetch.
     */
    where?: FeeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeItems to fetch.
     */
    orderBy?: FeeItemOrderByWithRelationInput | FeeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeItems.
     */
    cursor?: FeeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeItems.
     */
    distinct?: FeeItemScalarFieldEnum | FeeItemScalarFieldEnum[]
  }

  /**
   * FeeItem findFirstOrThrow
   */
  export type FeeItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter, which FeeItem to fetch.
     */
    where?: FeeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeItems to fetch.
     */
    orderBy?: FeeItemOrderByWithRelationInput | FeeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeeItems.
     */
    cursor?: FeeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeeItems.
     */
    distinct?: FeeItemScalarFieldEnum | FeeItemScalarFieldEnum[]
  }

  /**
   * FeeItem findMany
   */
  export type FeeItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter, which FeeItems to fetch.
     */
    where?: FeeItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeeItems to fetch.
     */
    orderBy?: FeeItemOrderByWithRelationInput | FeeItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeeItems.
     */
    cursor?: FeeItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeeItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeeItems.
     */
    skip?: number
    distinct?: FeeItemScalarFieldEnum | FeeItemScalarFieldEnum[]
  }

  /**
   * FeeItem create
   */
  export type FeeItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FeeItem.
     */
    data: XOR<FeeItemCreateInput, FeeItemUncheckedCreateInput>
  }

  /**
   * FeeItem createMany
   */
  export type FeeItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeeItems.
     */
    data: FeeItemCreateManyInput | FeeItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeeItem createManyAndReturn
   */
  export type FeeItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeeItems.
     */
    data: FeeItemCreateManyInput | FeeItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeeItem update
   */
  export type FeeItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FeeItem.
     */
    data: XOR<FeeItemUpdateInput, FeeItemUncheckedUpdateInput>
    /**
     * Choose, which FeeItem to update.
     */
    where: FeeItemWhereUniqueInput
  }

  /**
   * FeeItem updateMany
   */
  export type FeeItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeeItems.
     */
    data: XOR<FeeItemUpdateManyMutationInput, FeeItemUncheckedUpdateManyInput>
    /**
     * Filter which FeeItems to update
     */
    where?: FeeItemWhereInput
  }

  /**
   * FeeItem upsert
   */
  export type FeeItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FeeItem to update in case it exists.
     */
    where: FeeItemWhereUniqueInput
    /**
     * In case the FeeItem found by the `where` argument doesn't exist, create a new FeeItem with this data.
     */
    create: XOR<FeeItemCreateInput, FeeItemUncheckedCreateInput>
    /**
     * In case the FeeItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeeItemUpdateInput, FeeItemUncheckedUpdateInput>
  }

  /**
   * FeeItem delete
   */
  export type FeeItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
    /**
     * Filter which FeeItem to delete.
     */
    where: FeeItemWhereUniqueInput
  }

  /**
   * FeeItem deleteMany
   */
  export type FeeItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeeItems to delete
     */
    where?: FeeItemWhereInput
  }

  /**
   * FeeItem.contractItems
   */
  export type FeeItem$contractItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    where?: ContractItemWhereInput
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    cursor?: ContractItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * FeeItem without action
   */
  export type FeeItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeeItem
     */
    select?: FeeItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeeItemInclude<ExtArgs> | null
  }


  /**
   * Model ContractItem
   */

  export type AggregateContractItem = {
    _count: ContractItemCountAggregateOutputType | null
    _avg: ContractItemAvgAggregateOutputType | null
    _sum: ContractItemSumAggregateOutputType | null
    _min: ContractItemMinAggregateOutputType | null
    _max: ContractItemMaxAggregateOutputType | null
  }

  export type ContractItemAvgAggregateOutputType = {
    quantity: number | null
    unitAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type ContractItemSumAggregateOutputType = {
    quantity: number | null
    unitAmount: Decimal | null
    totalAmount: Decimal | null
  }

  export type ContractItemMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    feeItemId: string | null
    description: string | null
    quantity: number | null
    unitAmount: Decimal | null
    totalAmount: Decimal | null
    createdAt: Date | null
  }

  export type ContractItemMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    feeItemId: string | null
    description: string | null
    quantity: number | null
    unitAmount: Decimal | null
    totalAmount: Decimal | null
    createdAt: Date | null
  }

  export type ContractItemCountAggregateOutputType = {
    id: number
    contractId: number
    feeItemId: number
    description: number
    quantity: number
    unitAmount: number
    totalAmount: number
    createdAt: number
    _all: number
  }


  export type ContractItemAvgAggregateInputType = {
    quantity?: true
    unitAmount?: true
    totalAmount?: true
  }

  export type ContractItemSumAggregateInputType = {
    quantity?: true
    unitAmount?: true
    totalAmount?: true
  }

  export type ContractItemMinAggregateInputType = {
    id?: true
    contractId?: true
    feeItemId?: true
    description?: true
    quantity?: true
    unitAmount?: true
    totalAmount?: true
    createdAt?: true
  }

  export type ContractItemMaxAggregateInputType = {
    id?: true
    contractId?: true
    feeItemId?: true
    description?: true
    quantity?: true
    unitAmount?: true
    totalAmount?: true
    createdAt?: true
  }

  export type ContractItemCountAggregateInputType = {
    id?: true
    contractId?: true
    feeItemId?: true
    description?: true
    quantity?: true
    unitAmount?: true
    totalAmount?: true
    createdAt?: true
    _all?: true
  }

  export type ContractItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractItem to aggregate.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractItems
    **/
    _count?: true | ContractItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractItemMaxAggregateInputType
  }

  export type GetContractItemAggregateType<T extends ContractItemAggregateArgs> = {
        [P in keyof T & keyof AggregateContractItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractItem[P]>
      : GetScalarType<T[P], AggregateContractItem[P]>
  }




  export type ContractItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractItemWhereInput
    orderBy?: ContractItemOrderByWithAggregationInput | ContractItemOrderByWithAggregationInput[]
    by: ContractItemScalarFieldEnum[] | ContractItemScalarFieldEnum
    having?: ContractItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractItemCountAggregateInputType | true
    _avg?: ContractItemAvgAggregateInputType
    _sum?: ContractItemSumAggregateInputType
    _min?: ContractItemMinAggregateInputType
    _max?: ContractItemMaxAggregateInputType
  }

  export type ContractItemGroupByOutputType = {
    id: string
    contractId: string
    feeItemId: string
    description: string | null
    quantity: number
    unitAmount: Decimal
    totalAmount: Decimal
    createdAt: Date
    _count: ContractItemCountAggregateOutputType | null
    _avg: ContractItemAvgAggregateOutputType | null
    _sum: ContractItemSumAggregateOutputType | null
    _min: ContractItemMinAggregateOutputType | null
    _max: ContractItemMaxAggregateOutputType | null
  }

  type GetContractItemGroupByPayload<T extends ContractItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractItemGroupByOutputType[P]>
            : GetScalarType<T[P], ContractItemGroupByOutputType[P]>
        }
      >
    >


  export type ContractItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    feeItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    feeItem?: boolean | FeeItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractItem"]>

  export type ContractItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    feeItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    feeItem?: boolean | FeeItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractItem"]>

  export type ContractItemSelectScalar = {
    id?: boolean
    contractId?: boolean
    feeItemId?: boolean
    description?: boolean
    quantity?: boolean
    unitAmount?: boolean
    totalAmount?: boolean
    createdAt?: boolean
  }

  export type ContractItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    feeItem?: boolean | FeeItemDefaultArgs<ExtArgs>
  }
  export type ContractItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    feeItem?: boolean | FeeItemDefaultArgs<ExtArgs>
  }

  export type $ContractItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractItem"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      feeItem: Prisma.$FeeItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      feeItemId: string
      description: string | null
      quantity: number
      unitAmount: Prisma.Decimal
      totalAmount: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["contractItem"]>
    composites: {}
  }

  type ContractItemGetPayload<S extends boolean | null | undefined | ContractItemDefaultArgs> = $Result.GetResult<Prisma.$ContractItemPayload, S>

  type ContractItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractItemCountAggregateInputType | true
    }

  export interface ContractItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractItem'], meta: { name: 'ContractItem' } }
    /**
     * Find zero or one ContractItem that matches the filter.
     * @param {ContractItemFindUniqueArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractItemFindUniqueArgs>(args: SelectSubset<T, ContractItemFindUniqueArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractItemFindUniqueOrThrowArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindFirstArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractItemFindFirstArgs>(args?: SelectSubset<T, ContractItemFindFirstArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindFirstOrThrowArgs} args - Arguments to find a ContractItem
     * @example
     * // Get one ContractItem
     * const contractItem = await prisma.contractItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractItems
     * const contractItems = await prisma.contractItem.findMany()
     * 
     * // Get first 10 ContractItems
     * const contractItems = await prisma.contractItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractItemWithIdOnly = await prisma.contractItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractItemFindManyArgs>(args?: SelectSubset<T, ContractItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractItem.
     * @param {ContractItemCreateArgs} args - Arguments to create a ContractItem.
     * @example
     * // Create one ContractItem
     * const ContractItem = await prisma.contractItem.create({
     *   data: {
     *     // ... data to create a ContractItem
     *   }
     * })
     * 
     */
    create<T extends ContractItemCreateArgs>(args: SelectSubset<T, ContractItemCreateArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractItems.
     * @param {ContractItemCreateManyArgs} args - Arguments to create many ContractItems.
     * @example
     * // Create many ContractItems
     * const contractItem = await prisma.contractItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractItemCreateManyArgs>(args?: SelectSubset<T, ContractItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractItems and returns the data saved in the database.
     * @param {ContractItemCreateManyAndReturnArgs} args - Arguments to create many ContractItems.
     * @example
     * // Create many ContractItems
     * const contractItem = await prisma.contractItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractItems and only return the `id`
     * const contractItemWithIdOnly = await prisma.contractItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContractItem.
     * @param {ContractItemDeleteArgs} args - Arguments to delete one ContractItem.
     * @example
     * // Delete one ContractItem
     * const ContractItem = await prisma.contractItem.delete({
     *   where: {
     *     // ... filter to delete one ContractItem
     *   }
     * })
     * 
     */
    delete<T extends ContractItemDeleteArgs>(args: SelectSubset<T, ContractItemDeleteArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractItem.
     * @param {ContractItemUpdateArgs} args - Arguments to update one ContractItem.
     * @example
     * // Update one ContractItem
     * const contractItem = await prisma.contractItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractItemUpdateArgs>(args: SelectSubset<T, ContractItemUpdateArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractItems.
     * @param {ContractItemDeleteManyArgs} args - Arguments to filter ContractItems to delete.
     * @example
     * // Delete a few ContractItems
     * const { count } = await prisma.contractItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractItemDeleteManyArgs>(args?: SelectSubset<T, ContractItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractItems
     * const contractItem = await prisma.contractItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractItemUpdateManyArgs>(args: SelectSubset<T, ContractItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractItem.
     * @param {ContractItemUpsertArgs} args - Arguments to update or create a ContractItem.
     * @example
     * // Update or create a ContractItem
     * const contractItem = await prisma.contractItem.upsert({
     *   create: {
     *     // ... data to create a ContractItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractItem we want to update
     *   }
     * })
     */
    upsert<T extends ContractItemUpsertArgs>(args: SelectSubset<T, ContractItemUpsertArgs<ExtArgs>>): Prisma__ContractItemClient<$Result.GetResult<Prisma.$ContractItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemCountArgs} args - Arguments to filter ContractItems to count.
     * @example
     * // Count the number of ContractItems
     * const count = await prisma.contractItem.count({
     *   where: {
     *     // ... the filter for the ContractItems we want to count
     *   }
     * })
    **/
    count<T extends ContractItemCountArgs>(
      args?: Subset<T, ContractItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractItemAggregateArgs>(args: Subset<T, ContractItemAggregateArgs>): Prisma.PrismaPromise<GetContractItemAggregateType<T>>

    /**
     * Group by ContractItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractItemGroupByArgs['orderBy'] }
        : { orderBy?: ContractItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractItem model
   */
  readonly fields: ContractItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feeItem<T extends FeeItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeeItemDefaultArgs<ExtArgs>>): Prisma__FeeItemClient<$Result.GetResult<Prisma.$FeeItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractItem model
   */ 
  interface ContractItemFieldRefs {
    readonly id: FieldRef<"ContractItem", 'String'>
    readonly contractId: FieldRef<"ContractItem", 'String'>
    readonly feeItemId: FieldRef<"ContractItem", 'String'>
    readonly description: FieldRef<"ContractItem", 'String'>
    readonly quantity: FieldRef<"ContractItem", 'Int'>
    readonly unitAmount: FieldRef<"ContractItem", 'Decimal'>
    readonly totalAmount: FieldRef<"ContractItem", 'Decimal'>
    readonly createdAt: FieldRef<"ContractItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractItem findUnique
   */
  export type ContractItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem findUniqueOrThrow
   */
  export type ContractItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem findFirst
   */
  export type ContractItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractItems.
     */
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem findFirstOrThrow
   */
  export type ContractItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItem to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractItems.
     */
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem findMany
   */
  export type ContractItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter, which ContractItems to fetch.
     */
    where?: ContractItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractItems to fetch.
     */
    orderBy?: ContractItemOrderByWithRelationInput | ContractItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractItems.
     */
    cursor?: ContractItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractItems.
     */
    skip?: number
    distinct?: ContractItemScalarFieldEnum | ContractItemScalarFieldEnum[]
  }

  /**
   * ContractItem create
   */
  export type ContractItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractItem.
     */
    data: XOR<ContractItemCreateInput, ContractItemUncheckedCreateInput>
  }

  /**
   * ContractItem createMany
   */
  export type ContractItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractItems.
     */
    data: ContractItemCreateManyInput | ContractItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractItem createManyAndReturn
   */
  export type ContractItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContractItems.
     */
    data: ContractItemCreateManyInput | ContractItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractItem update
   */
  export type ContractItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractItem.
     */
    data: XOR<ContractItemUpdateInput, ContractItemUncheckedUpdateInput>
    /**
     * Choose, which ContractItem to update.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem updateMany
   */
  export type ContractItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractItems.
     */
    data: XOR<ContractItemUpdateManyMutationInput, ContractItemUncheckedUpdateManyInput>
    /**
     * Filter which ContractItems to update
     */
    where?: ContractItemWhereInput
  }

  /**
   * ContractItem upsert
   */
  export type ContractItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractItem to update in case it exists.
     */
    where: ContractItemWhereUniqueInput
    /**
     * In case the ContractItem found by the `where` argument doesn't exist, create a new ContractItem with this data.
     */
    create: XOR<ContractItemCreateInput, ContractItemUncheckedCreateInput>
    /**
     * In case the ContractItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractItemUpdateInput, ContractItemUncheckedUpdateInput>
  }

  /**
   * ContractItem delete
   */
  export type ContractItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
    /**
     * Filter which ContractItem to delete.
     */
    where: ContractItemWhereUniqueInput
  }

  /**
   * ContractItem deleteMany
   */
  export type ContractItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractItems to delete
     */
    where?: ContractItemWhereInput
  }

  /**
   * ContractItem without action
   */
  export type ContractItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractItem
     */
    select?: ContractItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractItemInclude<ExtArgs> | null
  }


  /**
   * Model ContractDiscount
   */

  export type AggregateContractDiscount = {
    _count: ContractDiscountCountAggregateOutputType | null
    _avg: ContractDiscountAvgAggregateOutputType | null
    _sum: ContractDiscountSumAggregateOutputType | null
    _min: ContractDiscountMinAggregateOutputType | null
    _max: ContractDiscountMaxAggregateOutputType | null
  }

  export type ContractDiscountAvgAggregateOutputType = {
    amount: Decimal | null
    percentage: number | null
  }

  export type ContractDiscountSumAggregateOutputType = {
    amount: Decimal | null
    percentage: number | null
  }

  export type ContractDiscountMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    type: string | null
    amount: Decimal | null
    percentage: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type ContractDiscountMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    type: string | null
    amount: Decimal | null
    percentage: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type ContractDiscountCountAggregateOutputType = {
    id: number
    contractId: number
    type: number
    amount: number
    percentage: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ContractDiscountAvgAggregateInputType = {
    amount?: true
    percentage?: true
  }

  export type ContractDiscountSumAggregateInputType = {
    amount?: true
    percentage?: true
  }

  export type ContractDiscountMinAggregateInputType = {
    id?: true
    contractId?: true
    type?: true
    amount?: true
    percentage?: true
    reason?: true
    createdAt?: true
  }

  export type ContractDiscountMaxAggregateInputType = {
    id?: true
    contractId?: true
    type?: true
    amount?: true
    percentage?: true
    reason?: true
    createdAt?: true
  }

  export type ContractDiscountCountAggregateInputType = {
    id?: true
    contractId?: true
    type?: true
    amount?: true
    percentage?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ContractDiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractDiscount to aggregate.
     */
    where?: ContractDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDiscounts to fetch.
     */
    orderBy?: ContractDiscountOrderByWithRelationInput | ContractDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractDiscounts
    **/
    _count?: true | ContractDiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractDiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractDiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractDiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractDiscountMaxAggregateInputType
  }

  export type GetContractDiscountAggregateType<T extends ContractDiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateContractDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractDiscount[P]>
      : GetScalarType<T[P], AggregateContractDiscount[P]>
  }




  export type ContractDiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractDiscountWhereInput
    orderBy?: ContractDiscountOrderByWithAggregationInput | ContractDiscountOrderByWithAggregationInput[]
    by: ContractDiscountScalarFieldEnum[] | ContractDiscountScalarFieldEnum
    having?: ContractDiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractDiscountCountAggregateInputType | true
    _avg?: ContractDiscountAvgAggregateInputType
    _sum?: ContractDiscountSumAggregateInputType
    _min?: ContractDiscountMinAggregateInputType
    _max?: ContractDiscountMaxAggregateInputType
  }

  export type ContractDiscountGroupByOutputType = {
    id: string
    contractId: string
    type: string
    amount: Decimal | null
    percentage: number | null
    reason: string | null
    createdAt: Date
    _count: ContractDiscountCountAggregateOutputType | null
    _avg: ContractDiscountAvgAggregateOutputType | null
    _sum: ContractDiscountSumAggregateOutputType | null
    _min: ContractDiscountMinAggregateOutputType | null
    _max: ContractDiscountMaxAggregateOutputType | null
  }

  type GetContractDiscountGroupByPayload<T extends ContractDiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractDiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractDiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractDiscountGroupByOutputType[P]>
            : GetScalarType<T[P], ContractDiscountGroupByOutputType[P]>
        }
      >
    >


  export type ContractDiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    type?: boolean
    amount?: boolean
    percentage?: boolean
    reason?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractDiscount"]>

  export type ContractDiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    type?: boolean
    amount?: boolean
    percentage?: boolean
    reason?: boolean
    createdAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractDiscount"]>

  export type ContractDiscountSelectScalar = {
    id?: boolean
    contractId?: boolean
    type?: boolean
    amount?: boolean
    percentage?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ContractDiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }
  export type ContractDiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $ContractDiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractDiscount"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      type: string
      amount: Prisma.Decimal | null
      percentage: number | null
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["contractDiscount"]>
    composites: {}
  }

  type ContractDiscountGetPayload<S extends boolean | null | undefined | ContractDiscountDefaultArgs> = $Result.GetResult<Prisma.$ContractDiscountPayload, S>

  type ContractDiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContractDiscountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContractDiscountCountAggregateInputType | true
    }

  export interface ContractDiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractDiscount'], meta: { name: 'ContractDiscount' } }
    /**
     * Find zero or one ContractDiscount that matches the filter.
     * @param {ContractDiscountFindUniqueArgs} args - Arguments to find a ContractDiscount
     * @example
     * // Get one ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractDiscountFindUniqueArgs>(args: SelectSubset<T, ContractDiscountFindUniqueArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContractDiscount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContractDiscountFindUniqueOrThrowArgs} args - Arguments to find a ContractDiscount
     * @example
     * // Get one ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractDiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractDiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContractDiscount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountFindFirstArgs} args - Arguments to find a ContractDiscount
     * @example
     * // Get one ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractDiscountFindFirstArgs>(args?: SelectSubset<T, ContractDiscountFindFirstArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContractDiscount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountFindFirstOrThrowArgs} args - Arguments to find a ContractDiscount
     * @example
     * // Get one ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractDiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractDiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContractDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractDiscounts
     * const contractDiscounts = await prisma.contractDiscount.findMany()
     * 
     * // Get first 10 ContractDiscounts
     * const contractDiscounts = await prisma.contractDiscount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractDiscountWithIdOnly = await prisma.contractDiscount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractDiscountFindManyArgs>(args?: SelectSubset<T, ContractDiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContractDiscount.
     * @param {ContractDiscountCreateArgs} args - Arguments to create a ContractDiscount.
     * @example
     * // Create one ContractDiscount
     * const ContractDiscount = await prisma.contractDiscount.create({
     *   data: {
     *     // ... data to create a ContractDiscount
     *   }
     * })
     * 
     */
    create<T extends ContractDiscountCreateArgs>(args: SelectSubset<T, ContractDiscountCreateArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContractDiscounts.
     * @param {ContractDiscountCreateManyArgs} args - Arguments to create many ContractDiscounts.
     * @example
     * // Create many ContractDiscounts
     * const contractDiscount = await prisma.contractDiscount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractDiscountCreateManyArgs>(args?: SelectSubset<T, ContractDiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractDiscounts and returns the data saved in the database.
     * @param {ContractDiscountCreateManyAndReturnArgs} args - Arguments to create many ContractDiscounts.
     * @example
     * // Create many ContractDiscounts
     * const contractDiscount = await prisma.contractDiscount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractDiscounts and only return the `id`
     * const contractDiscountWithIdOnly = await prisma.contractDiscount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractDiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractDiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContractDiscount.
     * @param {ContractDiscountDeleteArgs} args - Arguments to delete one ContractDiscount.
     * @example
     * // Delete one ContractDiscount
     * const ContractDiscount = await prisma.contractDiscount.delete({
     *   where: {
     *     // ... filter to delete one ContractDiscount
     *   }
     * })
     * 
     */
    delete<T extends ContractDiscountDeleteArgs>(args: SelectSubset<T, ContractDiscountDeleteArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContractDiscount.
     * @param {ContractDiscountUpdateArgs} args - Arguments to update one ContractDiscount.
     * @example
     * // Update one ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractDiscountUpdateArgs>(args: SelectSubset<T, ContractDiscountUpdateArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContractDiscounts.
     * @param {ContractDiscountDeleteManyArgs} args - Arguments to filter ContractDiscounts to delete.
     * @example
     * // Delete a few ContractDiscounts
     * const { count } = await prisma.contractDiscount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDiscountDeleteManyArgs>(args?: SelectSubset<T, ContractDiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractDiscounts
     * const contractDiscount = await prisma.contractDiscount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractDiscountUpdateManyArgs>(args: SelectSubset<T, ContractDiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractDiscount.
     * @param {ContractDiscountUpsertArgs} args - Arguments to update or create a ContractDiscount.
     * @example
     * // Update or create a ContractDiscount
     * const contractDiscount = await prisma.contractDiscount.upsert({
     *   create: {
     *     // ... data to create a ContractDiscount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractDiscount we want to update
     *   }
     * })
     */
    upsert<T extends ContractDiscountUpsertArgs>(args: SelectSubset<T, ContractDiscountUpsertArgs<ExtArgs>>): Prisma__ContractDiscountClient<$Result.GetResult<Prisma.$ContractDiscountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContractDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountCountArgs} args - Arguments to filter ContractDiscounts to count.
     * @example
     * // Count the number of ContractDiscounts
     * const count = await prisma.contractDiscount.count({
     *   where: {
     *     // ... the filter for the ContractDiscounts we want to count
     *   }
     * })
    **/
    count<T extends ContractDiscountCountArgs>(
      args?: Subset<T, ContractDiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractDiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractDiscountAggregateArgs>(args: Subset<T, ContractDiscountAggregateArgs>): Prisma.PrismaPromise<GetContractDiscountAggregateType<T>>

    /**
     * Group by ContractDiscount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractDiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractDiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractDiscountGroupByArgs['orderBy'] }
        : { orderBy?: ContractDiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractDiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractDiscount model
   */
  readonly fields: ContractDiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractDiscount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractDiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractDiscount model
   */ 
  interface ContractDiscountFieldRefs {
    readonly id: FieldRef<"ContractDiscount", 'String'>
    readonly contractId: FieldRef<"ContractDiscount", 'String'>
    readonly type: FieldRef<"ContractDiscount", 'String'>
    readonly amount: FieldRef<"ContractDiscount", 'Decimal'>
    readonly percentage: FieldRef<"ContractDiscount", 'Float'>
    readonly reason: FieldRef<"ContractDiscount", 'String'>
    readonly createdAt: FieldRef<"ContractDiscount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractDiscount findUnique
   */
  export type ContractDiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter, which ContractDiscount to fetch.
     */
    where: ContractDiscountWhereUniqueInput
  }

  /**
   * ContractDiscount findUniqueOrThrow
   */
  export type ContractDiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter, which ContractDiscount to fetch.
     */
    where: ContractDiscountWhereUniqueInput
  }

  /**
   * ContractDiscount findFirst
   */
  export type ContractDiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter, which ContractDiscount to fetch.
     */
    where?: ContractDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDiscounts to fetch.
     */
    orderBy?: ContractDiscountOrderByWithRelationInput | ContractDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractDiscounts.
     */
    cursor?: ContractDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractDiscounts.
     */
    distinct?: ContractDiscountScalarFieldEnum | ContractDiscountScalarFieldEnum[]
  }

  /**
   * ContractDiscount findFirstOrThrow
   */
  export type ContractDiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter, which ContractDiscount to fetch.
     */
    where?: ContractDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDiscounts to fetch.
     */
    orderBy?: ContractDiscountOrderByWithRelationInput | ContractDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractDiscounts.
     */
    cursor?: ContractDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractDiscounts.
     */
    distinct?: ContractDiscountScalarFieldEnum | ContractDiscountScalarFieldEnum[]
  }

  /**
   * ContractDiscount findMany
   */
  export type ContractDiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter, which ContractDiscounts to fetch.
     */
    where?: ContractDiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractDiscounts to fetch.
     */
    orderBy?: ContractDiscountOrderByWithRelationInput | ContractDiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractDiscounts.
     */
    cursor?: ContractDiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractDiscounts.
     */
    skip?: number
    distinct?: ContractDiscountScalarFieldEnum | ContractDiscountScalarFieldEnum[]
  }

  /**
   * ContractDiscount create
   */
  export type ContractDiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractDiscount.
     */
    data: XOR<ContractDiscountCreateInput, ContractDiscountUncheckedCreateInput>
  }

  /**
   * ContractDiscount createMany
   */
  export type ContractDiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractDiscounts.
     */
    data: ContractDiscountCreateManyInput | ContractDiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractDiscount createManyAndReturn
   */
  export type ContractDiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContractDiscounts.
     */
    data: ContractDiscountCreateManyInput | ContractDiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractDiscount update
   */
  export type ContractDiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractDiscount.
     */
    data: XOR<ContractDiscountUpdateInput, ContractDiscountUncheckedUpdateInput>
    /**
     * Choose, which ContractDiscount to update.
     */
    where: ContractDiscountWhereUniqueInput
  }

  /**
   * ContractDiscount updateMany
   */
  export type ContractDiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractDiscounts.
     */
    data: XOR<ContractDiscountUpdateManyMutationInput, ContractDiscountUncheckedUpdateManyInput>
    /**
     * Filter which ContractDiscounts to update
     */
    where?: ContractDiscountWhereInput
  }

  /**
   * ContractDiscount upsert
   */
  export type ContractDiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractDiscount to update in case it exists.
     */
    where: ContractDiscountWhereUniqueInput
    /**
     * In case the ContractDiscount found by the `where` argument doesn't exist, create a new ContractDiscount with this data.
     */
    create: XOR<ContractDiscountCreateInput, ContractDiscountUncheckedCreateInput>
    /**
     * In case the ContractDiscount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractDiscountUpdateInput, ContractDiscountUncheckedUpdateInput>
  }

  /**
   * ContractDiscount delete
   */
  export type ContractDiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
    /**
     * Filter which ContractDiscount to delete.
     */
    where: ContractDiscountWhereUniqueInput
  }

  /**
   * ContractDiscount deleteMany
   */
  export type ContractDiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractDiscounts to delete
     */
    where?: ContractDiscountWhereInput
  }

  /**
   * ContractDiscount without action
   */
  export type ContractDiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractDiscount
     */
    select?: ContractDiscountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractDiscountInclude<ExtArgs> | null
  }


  /**
   * Model Installment
   */

  export type AggregateInstallment = {
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  export type InstallmentAvgAggregateOutputType = {
    sequenceNo: number | null
    amount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InstallmentSumAggregateOutputType = {
    sequenceNo: number | null
    amount: Decimal | null
    paidAmount: Decimal | null
  }

  export type InstallmentMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    sequenceNo: number | null
    amount: Decimal | null
    dueDate: Date | null
    status: string | null
    paidAmount: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallmentMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    sequenceNo: number | null
    amount: Decimal | null
    dueDate: Date | null
    status: string | null
    paidAmount: Decimal | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallmentCountAggregateOutputType = {
    id: number
    contractId: number
    sequenceNo: number
    amount: number
    dueDate: number
    status: number
    paidAmount: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstallmentAvgAggregateInputType = {
    sequenceNo?: true
    amount?: true
    paidAmount?: true
  }

  export type InstallmentSumAggregateInputType = {
    sequenceNo?: true
    amount?: true
    paidAmount?: true
  }

  export type InstallmentMinAggregateInputType = {
    id?: true
    contractId?: true
    sequenceNo?: true
    amount?: true
    dueDate?: true
    status?: true
    paidAmount?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallmentMaxAggregateInputType = {
    id?: true
    contractId?: true
    sequenceNo?: true
    amount?: true
    dueDate?: true
    status?: true
    paidAmount?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallmentCountAggregateInputType = {
    id?: true
    contractId?: true
    sequenceNo?: true
    amount?: true
    dueDate?: true
    status?: true
    paidAmount?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installment to aggregate.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installments
    **/
    _count?: true | InstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallmentMaxAggregateInputType
  }

  export type GetInstallmentAggregateType<T extends InstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallment[P]>
      : GetScalarType<T[P], AggregateInstallment[P]>
  }




  export type InstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallmentWhereInput
    orderBy?: InstallmentOrderByWithAggregationInput | InstallmentOrderByWithAggregationInput[]
    by: InstallmentScalarFieldEnum[] | InstallmentScalarFieldEnum
    having?: InstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallmentCountAggregateInputType | true
    _avg?: InstallmentAvgAggregateInputType
    _sum?: InstallmentSumAggregateInputType
    _min?: InstallmentMinAggregateInputType
    _max?: InstallmentMaxAggregateInputType
  }

  export type InstallmentGroupByOutputType = {
    id: string
    contractId: string
    sequenceNo: number
    amount: Decimal
    dueDate: Date
    status: string
    paidAmount: Decimal
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: InstallmentCountAggregateOutputType | null
    _avg: InstallmentAvgAggregateOutputType | null
    _sum: InstallmentSumAggregateOutputType | null
    _min: InstallmentMinAggregateOutputType | null
    _max: InstallmentMaxAggregateOutputType | null
  }

  type GetInstallmentGroupByPayload<T extends InstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstallmentGroupByOutputType[P]>
        }
      >
    >


  export type InstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    sequenceNo?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    payments?: boolean | Installment$paymentsArgs<ExtArgs>
    _count?: boolean | InstallmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    sequenceNo?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installment"]>

  export type InstallmentSelectScalar = {
    id?: boolean
    contractId?: boolean
    sequenceNo?: boolean
    amount?: boolean
    dueDate?: boolean
    status?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    payments?: boolean | Installment$paymentsArgs<ExtArgs>
    _count?: boolean | InstallmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
  }

  export type $InstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Installment"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      sequenceNo: number
      amount: Prisma.Decimal
      dueDate: Date
      status: string
      paidAmount: Prisma.Decimal
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["installment"]>
    composites: {}
  }

  type InstallmentGetPayload<S extends boolean | null | undefined | InstallmentDefaultArgs> = $Result.GetResult<Prisma.$InstallmentPayload, S>

  type InstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstallmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstallmentCountAggregateInputType | true
    }

  export interface InstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Installment'], meta: { name: 'Installment' } }
    /**
     * Find zero or one Installment that matches the filter.
     * @param {InstallmentFindUniqueArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallmentFindUniqueArgs>(args: SelectSubset<T, InstallmentFindUniqueArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Installment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstallmentFindUniqueOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Installment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallmentFindFirstArgs>(args?: SelectSubset<T, InstallmentFindFirstArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Installment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindFirstOrThrowArgs} args - Arguments to find a Installment
     * @example
     * // Get one Installment
     * const installment = await prisma.installment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Installments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installments
     * const installments = await prisma.installment.findMany()
     * 
     * // Get first 10 Installments
     * const installments = await prisma.installment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installmentWithIdOnly = await prisma.installment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallmentFindManyArgs>(args?: SelectSubset<T, InstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Installment.
     * @param {InstallmentCreateArgs} args - Arguments to create a Installment.
     * @example
     * // Create one Installment
     * const Installment = await prisma.installment.create({
     *   data: {
     *     // ... data to create a Installment
     *   }
     * })
     * 
     */
    create<T extends InstallmentCreateArgs>(args: SelectSubset<T, InstallmentCreateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Installments.
     * @param {InstallmentCreateManyArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallmentCreateManyArgs>(args?: SelectSubset<T, InstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Installments and returns the data saved in the database.
     * @param {InstallmentCreateManyAndReturnArgs} args - Arguments to create many Installments.
     * @example
     * // Create many Installments
     * const installment = await prisma.installment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Installments and only return the `id`
     * const installmentWithIdOnly = await prisma.installment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Installment.
     * @param {InstallmentDeleteArgs} args - Arguments to delete one Installment.
     * @example
     * // Delete one Installment
     * const Installment = await prisma.installment.delete({
     *   where: {
     *     // ... filter to delete one Installment
     *   }
     * })
     * 
     */
    delete<T extends InstallmentDeleteArgs>(args: SelectSubset<T, InstallmentDeleteArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Installment.
     * @param {InstallmentUpdateArgs} args - Arguments to update one Installment.
     * @example
     * // Update one Installment
     * const installment = await prisma.installment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallmentUpdateArgs>(args: SelectSubset<T, InstallmentUpdateArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Installments.
     * @param {InstallmentDeleteManyArgs} args - Arguments to filter Installments to delete.
     * @example
     * // Delete a few Installments
     * const { count } = await prisma.installment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallmentDeleteManyArgs>(args?: SelectSubset<T, InstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installments
     * const installment = await prisma.installment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallmentUpdateManyArgs>(args: SelectSubset<T, InstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Installment.
     * @param {InstallmentUpsertArgs} args - Arguments to update or create a Installment.
     * @example
     * // Update or create a Installment
     * const installment = await prisma.installment.upsert({
     *   create: {
     *     // ... data to create a Installment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installment we want to update
     *   }
     * })
     */
    upsert<T extends InstallmentUpsertArgs>(args: SelectSubset<T, InstallmentUpsertArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Installments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentCountArgs} args - Arguments to filter Installments to count.
     * @example
     * // Count the number of Installments
     * const count = await prisma.installment.count({
     *   where: {
     *     // ... the filter for the Installments we want to count
     *   }
     * })
    **/
    count<T extends InstallmentCountArgs>(
      args?: Subset<T, InstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallmentAggregateArgs>(args: Subset<T, InstallmentAggregateArgs>): Prisma.PrismaPromise<GetInstallmentAggregateType<T>>

    /**
     * Group by Installment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallmentGroupByArgs['orderBy'] }
        : { orderBy?: InstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Installment model
   */
  readonly fields: InstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payments<T extends Installment$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Installment$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Installment model
   */ 
  interface InstallmentFieldRefs {
    readonly id: FieldRef<"Installment", 'String'>
    readonly contractId: FieldRef<"Installment", 'String'>
    readonly sequenceNo: FieldRef<"Installment", 'Int'>
    readonly amount: FieldRef<"Installment", 'Decimal'>
    readonly dueDate: FieldRef<"Installment", 'DateTime'>
    readonly status: FieldRef<"Installment", 'String'>
    readonly paidAmount: FieldRef<"Installment", 'Decimal'>
    readonly paidAt: FieldRef<"Installment", 'DateTime'>
    readonly createdAt: FieldRef<"Installment", 'DateTime'>
    readonly updatedAt: FieldRef<"Installment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Installment findUnique
   */
  export type InstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findUniqueOrThrow
   */
  export type InstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment findFirst
   */
  export type InstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findFirstOrThrow
   */
  export type InstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installment to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installments.
     */
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment findMany
   */
  export type InstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter, which Installments to fetch.
     */
    where?: InstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installments to fetch.
     */
    orderBy?: InstallmentOrderByWithRelationInput | InstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installments.
     */
    cursor?: InstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installments.
     */
    skip?: number
    distinct?: InstallmentScalarFieldEnum | InstallmentScalarFieldEnum[]
  }

  /**
   * Installment create
   */
  export type InstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Installment.
     */
    data: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
  }

  /**
   * Installment createMany
   */
  export type InstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Installment createManyAndReturn
   */
  export type InstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Installments.
     */
    data: InstallmentCreateManyInput | InstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Installment update
   */
  export type InstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Installment.
     */
    data: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
    /**
     * Choose, which Installment to update.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment updateMany
   */
  export type InstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Installments.
     */
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyInput>
    /**
     * Filter which Installments to update
     */
    where?: InstallmentWhereInput
  }

  /**
   * Installment upsert
   */
  export type InstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Installment to update in case it exists.
     */
    where: InstallmentWhereUniqueInput
    /**
     * In case the Installment found by the `where` argument doesn't exist, create a new Installment with this data.
     */
    create: XOR<InstallmentCreateInput, InstallmentUncheckedCreateInput>
    /**
     * In case the Installment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallmentUpdateInput, InstallmentUncheckedUpdateInput>
  }

  /**
   * Installment delete
   */
  export type InstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    /**
     * Filter which Installment to delete.
     */
    where: InstallmentWhereUniqueInput
  }

  /**
   * Installment deleteMany
   */
  export type InstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installments to delete
     */
    where?: InstallmentWhereInput
  }

  /**
   * Installment.payments
   */
  export type Installment$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Installment without action
   */
  export type InstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    installmentId: string | null
    amount: Decimal | null
    method: string | null
    providerName: string | null
    providerTransactionId: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    installmentId: string | null
    amount: Decimal | null
    method: string | null
    providerName: string | null
    providerTransactionId: string | null
    status: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    contractId: number
    installmentId: number
    amount: number
    method: number
    providerName: number
    providerTransactionId: number
    status: number
    providerResponse: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    contractId?: true
    installmentId?: true
    amount?: true
    method?: true
    providerName?: true
    providerTransactionId?: true
    status?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    contractId?: true
    installmentId?: true
    amount?: true
    method?: true
    providerName?: true
    providerTransactionId?: true
    status?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    contractId?: true
    installmentId?: true
    amount?: true
    method?: true
    providerName?: true
    providerTransactionId?: true
    status?: true
    providerResponse?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    contractId: string
    installmentId: string | null
    amount: Decimal
    method: string
    providerName: string | null
    providerTransactionId: string | null
    status: string
    providerResponse: JsonValue | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    installmentId?: boolean
    amount?: boolean
    method?: boolean
    providerName?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    installment?: boolean | Payment$installmentArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    installmentId?: boolean
    amount?: boolean
    method?: boolean
    providerName?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    installment?: boolean | Payment$installmentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    contractId?: boolean
    installmentId?: boolean
    amount?: boolean
    method?: boolean
    providerName?: boolean
    providerTransactionId?: boolean
    status?: boolean
    providerResponse?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    installment?: boolean | Payment$installmentArgs<ExtArgs>
    refunds?: boolean | Payment$refundsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    installment?: boolean | Payment$installmentArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      installment: Prisma.$InstallmentPayload<ExtArgs> | null
      refunds: Prisma.$RefundPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      installmentId: string | null
      amount: Prisma.Decimal
      method: string
      providerName: string | null
      providerTransactionId: string | null
      status: string
      providerResponse: Prisma.JsonValue | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    installment<T extends Payment$installmentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$installmentArgs<ExtArgs>>): Prisma__InstallmentClient<$Result.GetResult<Prisma.$InstallmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refunds<T extends Payment$refundsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$refundsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly contractId: FieldRef<"Payment", 'String'>
    readonly installmentId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly providerName: FieldRef<"Payment", 'String'>
    readonly providerTransactionId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly providerResponse: FieldRef<"Payment", 'Json'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.installment
   */
  export type Payment$installmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installment
     */
    select?: InstallmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallmentInclude<ExtArgs> | null
    where?: InstallmentWhereInput
  }

  /**
   * Payment.refunds
   */
  export type Payment$refundsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    cursor?: RefundWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type RefundSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    paymentId: string | null
    amount: Decimal | null
    reason: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    paymentId: string | null
    amount: Decimal | null
    reason: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    paymentId: number
    amount: number
    reason: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    amount?: true
  }

  export type RefundSumAggregateInputType = {
    amount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    paymentId?: true
    amount?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    paymentId?: true
    amount?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    paymentId?: true
    amount?: true
    reason?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    paymentId: string
    amount: Decimal
    reason: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    amount?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentId?: boolean
    amount?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    paymentId?: boolean
    amount?: boolean
    reason?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RefundInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }
  export type RefundIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | PaymentDefaultArgs<ExtArgs>
  }

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {
      payment: Prisma.$PaymentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentId: string
      amount: Prisma.Decimal
      reason: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payment<T extends PaymentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentDefaultArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */ 
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly paymentId: FieldRef<"Refund", 'String'>
    readonly amount: FieldRef<"Refund", 'Decimal'>
    readonly reason: FieldRef<"Refund", 'String'>
    readonly status: FieldRef<"Refund", 'String'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
    readonly updatedAt: FieldRef<"Refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefundInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    recipient: string | null
    type: string | null
    subject: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    recipient: string | null
    type: string | null
    subject: string | null
    content: string | null
    status: string | null
    sentAt: Date | null
    error: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    recipient: number
    type: number
    subject: number
    content: number
    status: number
    sentAt: number
    error: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    recipient?: true
    type?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    error?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    recipient?: true
    type?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    error?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    recipient?: true
    type?: true
    subject?: true
    content?: true
    status?: true
    sentAt?: true
    error?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    recipient: string
    type: string
    subject: string | null
    content: string
    status: string
    sentAt: Date | null
    error: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    recipient?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    recipient?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    recipient?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    status?: boolean
    sentAt?: boolean
    error?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      recipient: string
      type: string
      subject: string | null
      content: string
      status: string
      sentAt: Date | null
      error: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly recipient: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly subject: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly status: FieldRef<"Notification", 'String'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly error: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    settings: 'settings',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const CampusScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampusScalarFieldEnum = (typeof CampusScalarFieldEnum)[keyof typeof CampusScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    role: 'role',
    refreshToken: 'refreshToken',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    campusId: 'campusId',
    schoolYear: 'schoolYear',
    tcNo: 'tcNo',
    studentNo: 'studentNo',
    firstName: 'firstName',
    lastName: 'lastName',
    birthDate: 'birthDate',
    gender: 'gender',
    classLevel: 'classLevel',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    tcNo: 'tcNo',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    address: 'address',
    relationType: 'relationType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const StudentParentScalarFieldEnum: {
    studentId: 'studentId',
    parentId: 'parentId',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt'
  };

  export type StudentParentScalarFieldEnum = (typeof StudentParentScalarFieldEnum)[keyof typeof StudentParentScalarFieldEnum]


  export const ProspectScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    email: 'email',
    status: 'status',
    source: 'source',
    score: 'score',
    stage: 'stage',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProspectScalarFieldEnum = (typeof ProspectScalarFieldEnum)[keyof typeof ProspectScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    prospectId: 'prospectId',
    type: 'type',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const ConversionScalarFieldEnum: {
    id: 'id',
    prospectId: 'prospectId',
    studentId: 'studentId',
    convertedAt: 'convertedAt'
  };

  export type ConversionScalarFieldEnum = (typeof ConversionScalarFieldEnum)[keyof typeof ConversionScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    campusId: 'campusId',
    name: 'name',
    date: 'date',
    duration: 'duration',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamSessionScalarFieldEnum: {
    id: 'id',
    examId: 'examId',
    campusId: 'campusId',
    room: 'room',
    capacity: 'capacity',
    startTime: 'startTime',
    createdAt: 'createdAt'
  };

  export type ExamSessionScalarFieldEnum = (typeof ExamSessionScalarFieldEnum)[keyof typeof ExamSessionScalarFieldEnum]


  export const ExamApplicationScalarFieldEnum: {
    id: 'id',
    examId: 'examId',
    prospectId: 'prospectId',
    studentId: 'studentId',
    status: 'status',
    score: 'score',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamApplicationScalarFieldEnum = (typeof ExamApplicationScalarFieldEnum)[keyof typeof ExamApplicationScalarFieldEnum]


  export const AdmissionTicketScalarFieldEnum: {
    id: 'id',
    applicationId: 'applicationId',
    sessionId: 'sessionId',
    seatNumber: 'seatNumber'
  };

  export type AdmissionTicketScalarFieldEnum = (typeof AdmissionTicketScalarFieldEnum)[keyof typeof AdmissionTicketScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    campusId: 'campusId',
    schoolYear: 'schoolYear',
    studentId: 'studentId',
    contractNo: 'contractNo',
    totalAmount: 'totalAmount',
    discountAmount: 'discountAmount',
    netAmount: 'netAmount',
    installmentCount: 'installmentCount',
    status: 'status',
    signedAt: 'signedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const FeeItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    schoolYear: 'schoolYear',
    name: 'name',
    amount: 'amount',
    category: 'category',
    isMandatory: 'isMandatory',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeeItemScalarFieldEnum = (typeof FeeItemScalarFieldEnum)[keyof typeof FeeItemScalarFieldEnum]


  export const ContractItemScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    feeItemId: 'feeItemId',
    description: 'description',
    quantity: 'quantity',
    unitAmount: 'unitAmount',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt'
  };

  export type ContractItemScalarFieldEnum = (typeof ContractItemScalarFieldEnum)[keyof typeof ContractItemScalarFieldEnum]


  export const ContractDiscountScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    type: 'type',
    amount: 'amount',
    percentage: 'percentage',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ContractDiscountScalarFieldEnum = (typeof ContractDiscountScalarFieldEnum)[keyof typeof ContractDiscountScalarFieldEnum]


  export const InstallmentScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    sequenceNo: 'sequenceNo',
    amount: 'amount',
    dueDate: 'dueDate',
    status: 'status',
    paidAmount: 'paidAmount',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstallmentScalarFieldEnum = (typeof InstallmentScalarFieldEnum)[keyof typeof InstallmentScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    installmentId: 'installmentId',
    amount: 'amount',
    method: 'method',
    providerName: 'providerName',
    providerTransactionId: 'providerTransactionId',
    status: 'status',
    providerResponse: 'providerResponse',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    paymentId: 'paymentId',
    amount: 'amount',
    reason: 'reason',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    recipient: 'recipient',
    type: 'type',
    subject: 'subject',
    content: 'content',
    status: 'status',
    sentAt: 'sentAt',
    error: 'error',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    domain?: StringFilter<"Tenant"> | string
    settings?: JsonFilter<"Tenant">
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    campuses?: CampusListRelationFilter
    users?: UserListRelationFilter
    students?: StudentListRelationFilter
    parents?: ParentListRelationFilter
    contracts?: ContractListRelationFilter
    feeItems?: FeeItemListRelationFilter
    prospects?: ProspectListRelationFilter
    exams?: ExamListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campuses?: CampusOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    students?: StudentOrderByRelationAggregateInput
    parents?: ParentOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    feeItems?: FeeItemOrderByRelationAggregateInput
    prospects?: ProspectOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    settings?: JsonFilter<"Tenant">
    isActive?: BoolFilter<"Tenant"> | boolean
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    campuses?: CampusListRelationFilter
    users?: UserListRelationFilter
    students?: StudentListRelationFilter
    parents?: ParentListRelationFilter
    contracts?: ContractListRelationFilter
    feeItems?: FeeItemListRelationFilter
    prospects?: ProspectListRelationFilter
    exams?: ExamListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "domain">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringWithAggregatesFilter<"Tenant"> | string
    settings?: JsonWithAggregatesFilter<"Tenant">
    isActive?: BoolWithAggregatesFilter<"Tenant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type CampusWhereInput = {
    AND?: CampusWhereInput | CampusWhereInput[]
    OR?: CampusWhereInput[]
    NOT?: CampusWhereInput | CampusWhereInput[]
    id?: StringFilter<"Campus"> | string
    tenantId?: StringFilter<"Campus"> | string
    name?: StringFilter<"Campus"> | string
    address?: StringNullableFilter<"Campus"> | string | null
    phone?: StringNullableFilter<"Campus"> | string | null
    email?: StringNullableFilter<"Campus"> | string | null
    isActive?: BoolFilter<"Campus"> | boolean
    createdAt?: DateTimeFilter<"Campus"> | Date | string
    updatedAt?: DateTimeFilter<"Campus"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    students?: StudentListRelationFilter
    contracts?: ContractListRelationFilter
    exams?: ExamListRelationFilter
    examSessions?: ExamSessionListRelationFilter
  }

  export type CampusOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    students?: StudentOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    examSessions?: ExamSessionOrderByRelationAggregateInput
  }

  export type CampusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampusWhereInput | CampusWhereInput[]
    OR?: CampusWhereInput[]
    NOT?: CampusWhereInput | CampusWhereInput[]
    tenantId?: StringFilter<"Campus"> | string
    name?: StringFilter<"Campus"> | string
    address?: StringNullableFilter<"Campus"> | string | null
    phone?: StringNullableFilter<"Campus"> | string | null
    email?: StringNullableFilter<"Campus"> | string | null
    isActive?: BoolFilter<"Campus"> | boolean
    createdAt?: DateTimeFilter<"Campus"> | Date | string
    updatedAt?: DateTimeFilter<"Campus"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    students?: StudentListRelationFilter
    contracts?: ContractListRelationFilter
    exams?: ExamListRelationFilter
    examSessions?: ExamSessionListRelationFilter
  }, "id">

  export type CampusOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampusCountOrderByAggregateInput
    _max?: CampusMaxOrderByAggregateInput
    _min?: CampusMinOrderByAggregateInput
  }

  export type CampusScalarWhereWithAggregatesInput = {
    AND?: CampusScalarWhereWithAggregatesInput | CampusScalarWhereWithAggregatesInput[]
    OR?: CampusScalarWhereWithAggregatesInput[]
    NOT?: CampusScalarWhereWithAggregatesInput | CampusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campus"> | string
    tenantId?: StringWithAggregatesFilter<"Campus"> | string
    name?: StringWithAggregatesFilter<"Campus"> | string
    address?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    email?: StringNullableWithAggregatesFilter<"Campus"> | string | null
    isActive?: BoolWithAggregatesFilter<"Campus"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Campus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campus"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    tenantId?: StringFilter<"Student"> | string
    campusId?: StringFilter<"Student"> | string
    schoolYear?: StringFilter<"Student"> | string
    tcNo?: StringFilter<"Student"> | string
    studentNo?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    classLevel?: IntFilter<"Student"> | number
    status?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    parentRelations?: StudentParentListRelationFilter
    contracts?: ContractListRelationFilter
    examApplications?: ExamApplicationListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    tcNo?: SortOrder
    studentNo?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    classLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    campus?: CampusOrderByWithRelationInput
    parentRelations?: StudentParentOrderByRelationAggregateInput
    contracts?: ContractOrderByRelationAggregateInput
    examApplications?: ExamApplicationOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tcNo?: string
    tenantId_campusId_schoolYear_studentNo?: StudentTenantIdCampusIdSchoolYearStudentNoCompoundUniqueInput
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    tenantId?: StringFilter<"Student"> | string
    campusId?: StringFilter<"Student"> | string
    schoolYear?: StringFilter<"Student"> | string
    studentNo?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    classLevel?: IntFilter<"Student"> | number
    status?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    parentRelations?: StudentParentListRelationFilter
    contracts?: ContractListRelationFilter
    examApplications?: ExamApplicationListRelationFilter
  }, "id" | "tcNo" | "tenantId_campusId_schoolYear_studentNo">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    tcNo?: SortOrder
    studentNo?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    classLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    tenantId?: StringWithAggregatesFilter<"Student"> | string
    campusId?: StringWithAggregatesFilter<"Student"> | string
    schoolYear?: StringWithAggregatesFilter<"Student"> | string
    tcNo?: StringWithAggregatesFilter<"Student"> | string
    studentNo?: StringNullableWithAggregatesFilter<"Student"> | string | null
    firstName?: StringWithAggregatesFilter<"Student"> | string
    lastName?: StringWithAggregatesFilter<"Student"> | string
    birthDate?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    gender?: StringWithAggregatesFilter<"Student"> | string
    classLevel?: IntWithAggregatesFilter<"Student"> | number
    status?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    tenantId?: StringFilter<"Parent"> | string
    tcNo?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    lastName?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    email?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    relationType?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    studentRelations?: StudentParentListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tcNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    studentRelations?: StudentParentOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tcNo?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    tenantId?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    lastName?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    email?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    relationType?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    studentRelations?: StudentParentListRelationFilter
  }, "id" | "tcNo">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tcNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    tenantId?: StringWithAggregatesFilter<"Parent"> | string
    tcNo?: StringWithAggregatesFilter<"Parent"> | string
    firstName?: StringWithAggregatesFilter<"Parent"> | string
    lastName?: StringWithAggregatesFilter<"Parent"> | string
    phone?: StringWithAggregatesFilter<"Parent"> | string
    email?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    address?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    relationType?: StringWithAggregatesFilter<"Parent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type StudentParentWhereInput = {
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
  }

  export type StudentParentOrderByWithRelationInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
  }

  export type StudentParentWhereUniqueInput = Prisma.AtLeast<{
    studentId_parentId?: StudentParentStudentIdParentIdCompoundUniqueInput
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    parent?: XOR<ParentRelationFilter, ParentWhereInput>
  }, "studentId_parentId">

  export type StudentParentOrderByWithAggregationInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    _count?: StudentParentCountOrderByAggregateInput
    _max?: StudentParentMaxOrderByAggregateInput
    _min?: StudentParentMinOrderByAggregateInput
  }

  export type StudentParentScalarWhereWithAggregatesInput = {
    AND?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    OR?: StudentParentScalarWhereWithAggregatesInput[]
    NOT?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    studentId?: StringWithAggregatesFilter<"StudentParent"> | string
    parentId?: StringWithAggregatesFilter<"StudentParent"> | string
    isPrimary?: BoolWithAggregatesFilter<"StudentParent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudentParent"> | Date | string
  }

  export type ProspectWhereInput = {
    AND?: ProspectWhereInput | ProspectWhereInput[]
    OR?: ProspectWhereInput[]
    NOT?: ProspectWhereInput | ProspectWhereInput[]
    id?: StringFilter<"Prospect"> | string
    tenantId?: StringFilter<"Prospect"> | string
    firstName?: StringFilter<"Prospect"> | string
    lastName?: StringFilter<"Prospect"> | string
    phone?: StringFilter<"Prospect"> | string
    email?: StringNullableFilter<"Prospect"> | string | null
    status?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    score?: IntNullableFilter<"Prospect"> | number | null
    stage?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    interactions?: InteractionListRelationFilter
    conversions?: ConversionListRelationFilter
    examApplications?: ExamApplicationListRelationFilter
  }

  export type ProspectOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    stage?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    interactions?: InteractionOrderByRelationAggregateInput
    conversions?: ConversionOrderByRelationAggregateInput
    examApplications?: ExamApplicationOrderByRelationAggregateInput
  }

  export type ProspectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProspectWhereInput | ProspectWhereInput[]
    OR?: ProspectWhereInput[]
    NOT?: ProspectWhereInput | ProspectWhereInput[]
    tenantId?: StringFilter<"Prospect"> | string
    firstName?: StringFilter<"Prospect"> | string
    lastName?: StringFilter<"Prospect"> | string
    phone?: StringFilter<"Prospect"> | string
    email?: StringNullableFilter<"Prospect"> | string | null
    status?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    score?: IntNullableFilter<"Prospect"> | number | null
    stage?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    interactions?: InteractionListRelationFilter
    conversions?: ConversionListRelationFilter
    examApplications?: ExamApplicationListRelationFilter
  }, "id">

  export type ProspectOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    stage?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProspectCountOrderByAggregateInput
    _avg?: ProspectAvgOrderByAggregateInput
    _max?: ProspectMaxOrderByAggregateInput
    _min?: ProspectMinOrderByAggregateInput
    _sum?: ProspectSumOrderByAggregateInput
  }

  export type ProspectScalarWhereWithAggregatesInput = {
    AND?: ProspectScalarWhereWithAggregatesInput | ProspectScalarWhereWithAggregatesInput[]
    OR?: ProspectScalarWhereWithAggregatesInput[]
    NOT?: ProspectScalarWhereWithAggregatesInput | ProspectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prospect"> | string
    tenantId?: StringWithAggregatesFilter<"Prospect"> | string
    firstName?: StringWithAggregatesFilter<"Prospect"> | string
    lastName?: StringWithAggregatesFilter<"Prospect"> | string
    phone?: StringWithAggregatesFilter<"Prospect"> | string
    email?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    status?: StringWithAggregatesFilter<"Prospect"> | string
    source?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    score?: IntNullableWithAggregatesFilter<"Prospect"> | number | null
    stage?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Prospect"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prospect"> | Date | string
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    prospectId?: StringFilter<"Interaction"> | string
    type?: StringFilter<"Interaction"> | string
    content?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    prospect?: ProspectOrderByWithRelationInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    prospectId?: StringFilter<"Interaction"> | string
    type?: StringFilter<"Interaction"> | string
    content?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    content?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    prospectId?: StringWithAggregatesFilter<"Interaction"> | string
    type?: StringWithAggregatesFilter<"Interaction"> | string
    content?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
  }

  export type ConversionWhereInput = {
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    id?: StringFilter<"Conversion"> | string
    prospectId?: StringFilter<"Conversion"> | string
    studentId?: StringFilter<"Conversion"> | string
    convertedAt?: DateTimeFilter<"Conversion"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
  }

  export type ConversionOrderByWithRelationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    convertedAt?: SortOrder
    prospect?: ProspectOrderByWithRelationInput
  }

  export type ConversionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversionWhereInput | ConversionWhereInput[]
    OR?: ConversionWhereInput[]
    NOT?: ConversionWhereInput | ConversionWhereInput[]
    prospectId?: StringFilter<"Conversion"> | string
    studentId?: StringFilter<"Conversion"> | string
    convertedAt?: DateTimeFilter<"Conversion"> | Date | string
    prospect?: XOR<ProspectRelationFilter, ProspectWhereInput>
  }, "id">

  export type ConversionOrderByWithAggregationInput = {
    id?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    convertedAt?: SortOrder
    _count?: ConversionCountOrderByAggregateInput
    _max?: ConversionMaxOrderByAggregateInput
    _min?: ConversionMinOrderByAggregateInput
  }

  export type ConversionScalarWhereWithAggregatesInput = {
    AND?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    OR?: ConversionScalarWhereWithAggregatesInput[]
    NOT?: ConversionScalarWhereWithAggregatesInput | ConversionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversion"> | string
    prospectId?: StringWithAggregatesFilter<"Conversion"> | string
    studentId?: StringWithAggregatesFilter<"Conversion"> | string
    convertedAt?: DateTimeWithAggregatesFilter<"Conversion"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    tenantId?: StringFilter<"Exam"> | string
    campusId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    sessions?: ExamSessionListRelationFilter
    applications?: ExamApplicationListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    campus?: CampusOrderByWithRelationInput
    sessions?: ExamSessionOrderByRelationAggregateInput
    applications?: ExamApplicationOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    tenantId?: StringFilter<"Exam"> | string
    campusId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    sessions?: ExamSessionListRelationFilter
    applications?: ExamApplicationListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    tenantId?: StringWithAggregatesFilter<"Exam"> | string
    campusId?: StringWithAggregatesFilter<"Exam"> | string
    name?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    duration?: IntWithAggregatesFilter<"Exam"> | number
    status?: StringWithAggregatesFilter<"Exam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type ExamSessionWhereInput = {
    AND?: ExamSessionWhereInput | ExamSessionWhereInput[]
    OR?: ExamSessionWhereInput[]
    NOT?: ExamSessionWhereInput | ExamSessionWhereInput[]
    id?: StringFilter<"ExamSession"> | string
    examId?: StringFilter<"ExamSession"> | string
    campusId?: StringFilter<"ExamSession"> | string
    room?: StringFilter<"ExamSession"> | string
    capacity?: IntFilter<"ExamSession"> | number
    startTime?: DateTimeFilter<"ExamSession"> | Date | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    admissionTickets?: AdmissionTicketListRelationFilter
  }

  export type ExamSessionOrderByWithRelationInput = {
    id?: SortOrder
    examId?: SortOrder
    campusId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
    campus?: CampusOrderByWithRelationInput
    admissionTickets?: AdmissionTicketOrderByRelationAggregateInput
  }

  export type ExamSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamSessionWhereInput | ExamSessionWhereInput[]
    OR?: ExamSessionWhereInput[]
    NOT?: ExamSessionWhereInput | ExamSessionWhereInput[]
    examId?: StringFilter<"ExamSession"> | string
    campusId?: StringFilter<"ExamSession"> | string
    room?: StringFilter<"ExamSession"> | string
    capacity?: IntFilter<"ExamSession"> | number
    startTime?: DateTimeFilter<"ExamSession"> | Date | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    admissionTickets?: AdmissionTicketListRelationFilter
  }, "id">

  export type ExamSessionOrderByWithAggregationInput = {
    id?: SortOrder
    examId?: SortOrder
    campusId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
    _count?: ExamSessionCountOrderByAggregateInput
    _avg?: ExamSessionAvgOrderByAggregateInput
    _max?: ExamSessionMaxOrderByAggregateInput
    _min?: ExamSessionMinOrderByAggregateInput
    _sum?: ExamSessionSumOrderByAggregateInput
  }

  export type ExamSessionScalarWhereWithAggregatesInput = {
    AND?: ExamSessionScalarWhereWithAggregatesInput | ExamSessionScalarWhereWithAggregatesInput[]
    OR?: ExamSessionScalarWhereWithAggregatesInput[]
    NOT?: ExamSessionScalarWhereWithAggregatesInput | ExamSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamSession"> | string
    examId?: StringWithAggregatesFilter<"ExamSession"> | string
    campusId?: StringWithAggregatesFilter<"ExamSession"> | string
    room?: StringWithAggregatesFilter<"ExamSession"> | string
    capacity?: IntWithAggregatesFilter<"ExamSession"> | number
    startTime?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExamSession"> | Date | string
  }

  export type ExamApplicationWhereInput = {
    AND?: ExamApplicationWhereInput | ExamApplicationWhereInput[]
    OR?: ExamApplicationWhereInput[]
    NOT?: ExamApplicationWhereInput | ExamApplicationWhereInput[]
    id?: StringFilter<"ExamApplication"> | string
    examId?: StringFilter<"ExamApplication"> | string
    prospectId?: StringNullableFilter<"ExamApplication"> | string | null
    studentId?: StringNullableFilter<"ExamApplication"> | string | null
    status?: StringFilter<"ExamApplication"> | string
    score?: FloatNullableFilter<"ExamApplication"> | number | null
    createdAt?: DateTimeFilter<"ExamApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ExamApplication"> | Date | string
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    prospect?: XOR<ProspectNullableRelationFilter, ProspectWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    admissionTicket?: XOR<AdmissionTicketNullableRelationFilter, AdmissionTicketWhereInput> | null
  }

  export type ExamApplicationOrderByWithRelationInput = {
    id?: SortOrder
    examId?: SortOrder
    prospectId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
    prospect?: ProspectOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    admissionTicket?: AdmissionTicketOrderByWithRelationInput
  }

  export type ExamApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamApplicationWhereInput | ExamApplicationWhereInput[]
    OR?: ExamApplicationWhereInput[]
    NOT?: ExamApplicationWhereInput | ExamApplicationWhereInput[]
    examId?: StringFilter<"ExamApplication"> | string
    prospectId?: StringNullableFilter<"ExamApplication"> | string | null
    studentId?: StringNullableFilter<"ExamApplication"> | string | null
    status?: StringFilter<"ExamApplication"> | string
    score?: FloatNullableFilter<"ExamApplication"> | number | null
    createdAt?: DateTimeFilter<"ExamApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ExamApplication"> | Date | string
    exam?: XOR<ExamRelationFilter, ExamWhereInput>
    prospect?: XOR<ProspectNullableRelationFilter, ProspectWhereInput> | null
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    admissionTicket?: XOR<AdmissionTicketNullableRelationFilter, AdmissionTicketWhereInput> | null
  }, "id">

  export type ExamApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    examId?: SortOrder
    prospectId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    status?: SortOrder
    score?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamApplicationCountOrderByAggregateInput
    _avg?: ExamApplicationAvgOrderByAggregateInput
    _max?: ExamApplicationMaxOrderByAggregateInput
    _min?: ExamApplicationMinOrderByAggregateInput
    _sum?: ExamApplicationSumOrderByAggregateInput
  }

  export type ExamApplicationScalarWhereWithAggregatesInput = {
    AND?: ExamApplicationScalarWhereWithAggregatesInput | ExamApplicationScalarWhereWithAggregatesInput[]
    OR?: ExamApplicationScalarWhereWithAggregatesInput[]
    NOT?: ExamApplicationScalarWhereWithAggregatesInput | ExamApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamApplication"> | string
    examId?: StringWithAggregatesFilter<"ExamApplication"> | string
    prospectId?: StringNullableWithAggregatesFilter<"ExamApplication"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"ExamApplication"> | string | null
    status?: StringWithAggregatesFilter<"ExamApplication"> | string
    score?: FloatNullableWithAggregatesFilter<"ExamApplication"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ExamApplication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamApplication"> | Date | string
  }

  export type AdmissionTicketWhereInput = {
    AND?: AdmissionTicketWhereInput | AdmissionTicketWhereInput[]
    OR?: AdmissionTicketWhereInput[]
    NOT?: AdmissionTicketWhereInput | AdmissionTicketWhereInput[]
    id?: StringFilter<"AdmissionTicket"> | string
    applicationId?: StringFilter<"AdmissionTicket"> | string
    sessionId?: StringFilter<"AdmissionTicket"> | string
    seatNumber?: StringFilter<"AdmissionTicket"> | string
    application?: XOR<ExamApplicationRelationFilter, ExamApplicationWhereInput>
    session?: XOR<ExamSessionRelationFilter, ExamSessionWhereInput>
  }

  export type AdmissionTicketOrderByWithRelationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sessionId?: SortOrder
    seatNumber?: SortOrder
    application?: ExamApplicationOrderByWithRelationInput
    session?: ExamSessionOrderByWithRelationInput
  }

  export type AdmissionTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    applicationId?: string
    AND?: AdmissionTicketWhereInput | AdmissionTicketWhereInput[]
    OR?: AdmissionTicketWhereInput[]
    NOT?: AdmissionTicketWhereInput | AdmissionTicketWhereInput[]
    sessionId?: StringFilter<"AdmissionTicket"> | string
    seatNumber?: StringFilter<"AdmissionTicket"> | string
    application?: XOR<ExamApplicationRelationFilter, ExamApplicationWhereInput>
    session?: XOR<ExamSessionRelationFilter, ExamSessionWhereInput>
  }, "id" | "applicationId">

  export type AdmissionTicketOrderByWithAggregationInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sessionId?: SortOrder
    seatNumber?: SortOrder
    _count?: AdmissionTicketCountOrderByAggregateInput
    _max?: AdmissionTicketMaxOrderByAggregateInput
    _min?: AdmissionTicketMinOrderByAggregateInput
  }

  export type AdmissionTicketScalarWhereWithAggregatesInput = {
    AND?: AdmissionTicketScalarWhereWithAggregatesInput | AdmissionTicketScalarWhereWithAggregatesInput[]
    OR?: AdmissionTicketScalarWhereWithAggregatesInput[]
    NOT?: AdmissionTicketScalarWhereWithAggregatesInput | AdmissionTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdmissionTicket"> | string
    applicationId?: StringWithAggregatesFilter<"AdmissionTicket"> | string
    sessionId?: StringWithAggregatesFilter<"AdmissionTicket"> | string
    seatNumber?: StringWithAggregatesFilter<"AdmissionTicket"> | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    tenantId?: StringFilter<"Contract"> | string
    campusId?: StringFilter<"Contract"> | string
    schoolYear?: StringFilter<"Contract"> | string
    studentId?: StringFilter<"Contract"> | string
    contractNo?: StringFilter<"Contract"> | string
    totalAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFilter<"Contract"> | number
    status?: StringFilter<"Contract"> | string
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    items?: ContractItemListRelationFilter
    installments?: InstallmentListRelationFilter
    payments?: PaymentListRelationFilter
    discounts?: ContractDiscountListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    studentId?: SortOrder
    contractNo?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
    status?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    campus?: CampusOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
    items?: ContractItemOrderByRelationAggregateInput
    installments?: InstallmentOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    discounts?: ContractDiscountOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_campusId_schoolYear_contractNo?: ContractTenantIdCampusIdSchoolYearContractNoCompoundUniqueInput
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    tenantId?: StringFilter<"Contract"> | string
    campusId?: StringFilter<"Contract"> | string
    schoolYear?: StringFilter<"Contract"> | string
    studentId?: StringFilter<"Contract"> | string
    contractNo?: StringFilter<"Contract"> | string
    totalAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFilter<"Contract"> | number
    status?: StringFilter<"Contract"> | string
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    campus?: XOR<CampusRelationFilter, CampusWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    items?: ContractItemListRelationFilter
    installments?: InstallmentListRelationFilter
    payments?: PaymentListRelationFilter
    discounts?: ContractDiscountListRelationFilter
  }, "id" | "tenantId_campusId_schoolYear_contractNo">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    studentId?: SortOrder
    contractNo?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
    status?: SortOrder
    signedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _avg?: ContractAvgOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
    _sum?: ContractSumOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    tenantId?: StringWithAggregatesFilter<"Contract"> | string
    campusId?: StringWithAggregatesFilter<"Contract"> | string
    schoolYear?: StringWithAggregatesFilter<"Contract"> | string
    studentId?: StringWithAggregatesFilter<"Contract"> | string
    contractNo?: StringWithAggregatesFilter<"Contract"> | string
    totalAmount?: DecimalWithAggregatesFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    installmentCount?: IntWithAggregatesFilter<"Contract"> | number
    status?: StringWithAggregatesFilter<"Contract"> | string
    signedAt?: DateTimeNullableWithAggregatesFilter<"Contract"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type FeeItemWhereInput = {
    AND?: FeeItemWhereInput | FeeItemWhereInput[]
    OR?: FeeItemWhereInput[]
    NOT?: FeeItemWhereInput | FeeItemWhereInput[]
    id?: StringFilter<"FeeItem"> | string
    tenantId?: StringFilter<"FeeItem"> | string
    schoolYear?: StringFilter<"FeeItem"> | string
    name?: StringFilter<"FeeItem"> | string
    amount?: DecimalFilter<"FeeItem"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"FeeItem"> | string | null
    isMandatory?: BoolFilter<"FeeItem"> | boolean
    createdAt?: DateTimeFilter<"FeeItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeeItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    contractItems?: ContractItemListRelationFilter
  }

  export type FeeItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    schoolYear?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    category?: SortOrderInput | SortOrder
    isMandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contractItems?: ContractItemOrderByRelationAggregateInput
  }

  export type FeeItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeeItemWhereInput | FeeItemWhereInput[]
    OR?: FeeItemWhereInput[]
    NOT?: FeeItemWhereInput | FeeItemWhereInput[]
    tenantId?: StringFilter<"FeeItem"> | string
    schoolYear?: StringFilter<"FeeItem"> | string
    name?: StringFilter<"FeeItem"> | string
    amount?: DecimalFilter<"FeeItem"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"FeeItem"> | string | null
    isMandatory?: BoolFilter<"FeeItem"> | boolean
    createdAt?: DateTimeFilter<"FeeItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeeItem"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    contractItems?: ContractItemListRelationFilter
  }, "id">

  export type FeeItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    schoolYear?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    category?: SortOrderInput | SortOrder
    isMandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeeItemCountOrderByAggregateInput
    _avg?: FeeItemAvgOrderByAggregateInput
    _max?: FeeItemMaxOrderByAggregateInput
    _min?: FeeItemMinOrderByAggregateInput
    _sum?: FeeItemSumOrderByAggregateInput
  }

  export type FeeItemScalarWhereWithAggregatesInput = {
    AND?: FeeItemScalarWhereWithAggregatesInput | FeeItemScalarWhereWithAggregatesInput[]
    OR?: FeeItemScalarWhereWithAggregatesInput[]
    NOT?: FeeItemScalarWhereWithAggregatesInput | FeeItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeeItem"> | string
    tenantId?: StringWithAggregatesFilter<"FeeItem"> | string
    schoolYear?: StringWithAggregatesFilter<"FeeItem"> | string
    name?: StringWithAggregatesFilter<"FeeItem"> | string
    amount?: DecimalWithAggregatesFilter<"FeeItem"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableWithAggregatesFilter<"FeeItem"> | string | null
    isMandatory?: BoolWithAggregatesFilter<"FeeItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FeeItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeeItem"> | Date | string
  }

  export type ContractItemWhereInput = {
    AND?: ContractItemWhereInput | ContractItemWhereInput[]
    OR?: ContractItemWhereInput[]
    NOT?: ContractItemWhereInput | ContractItemWhereInput[]
    id?: StringFilter<"ContractItem"> | string
    contractId?: StringFilter<"ContractItem"> | string
    feeItemId?: StringFilter<"ContractItem"> | string
    description?: StringNullableFilter<"ContractItem"> | string | null
    quantity?: IntFilter<"ContractItem"> | number
    unitAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ContractItem"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    feeItem?: XOR<FeeItemRelationFilter, FeeItemWhereInput>
  }

  export type ContractItemOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    feeItemId?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    feeItem?: FeeItemOrderByWithRelationInput
  }

  export type ContractItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractItemWhereInput | ContractItemWhereInput[]
    OR?: ContractItemWhereInput[]
    NOT?: ContractItemWhereInput | ContractItemWhereInput[]
    contractId?: StringFilter<"ContractItem"> | string
    feeItemId?: StringFilter<"ContractItem"> | string
    description?: StringNullableFilter<"ContractItem"> | string | null
    quantity?: IntFilter<"ContractItem"> | number
    unitAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ContractItem"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    feeItem?: XOR<FeeItemRelationFilter, FeeItemWhereInput>
  }, "id">

  export type ContractItemOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    feeItemId?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    _count?: ContractItemCountOrderByAggregateInput
    _avg?: ContractItemAvgOrderByAggregateInput
    _max?: ContractItemMaxOrderByAggregateInput
    _min?: ContractItemMinOrderByAggregateInput
    _sum?: ContractItemSumOrderByAggregateInput
  }

  export type ContractItemScalarWhereWithAggregatesInput = {
    AND?: ContractItemScalarWhereWithAggregatesInput | ContractItemScalarWhereWithAggregatesInput[]
    OR?: ContractItemScalarWhereWithAggregatesInput[]
    NOT?: ContractItemScalarWhereWithAggregatesInput | ContractItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractItem"> | string
    contractId?: StringWithAggregatesFilter<"ContractItem"> | string
    feeItemId?: StringWithAggregatesFilter<"ContractItem"> | string
    description?: StringNullableWithAggregatesFilter<"ContractItem"> | string | null
    quantity?: IntWithAggregatesFilter<"ContractItem"> | number
    unitAmount?: DecimalWithAggregatesFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalWithAggregatesFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"ContractItem"> | Date | string
  }

  export type ContractDiscountWhereInput = {
    AND?: ContractDiscountWhereInput | ContractDiscountWhereInput[]
    OR?: ContractDiscountWhereInput[]
    NOT?: ContractDiscountWhereInput | ContractDiscountWhereInput[]
    id?: StringFilter<"ContractDiscount"> | string
    contractId?: StringFilter<"ContractDiscount"> | string
    type?: StringFilter<"ContractDiscount"> | string
    amount?: DecimalNullableFilter<"ContractDiscount"> | Decimal | DecimalJsLike | number | string | null
    percentage?: FloatNullableFilter<"ContractDiscount"> | number | null
    reason?: StringNullableFilter<"ContractDiscount"> | string | null
    createdAt?: DateTimeFilter<"ContractDiscount"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }

  export type ContractDiscountOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
  }

  export type ContractDiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractDiscountWhereInput | ContractDiscountWhereInput[]
    OR?: ContractDiscountWhereInput[]
    NOT?: ContractDiscountWhereInput | ContractDiscountWhereInput[]
    contractId?: StringFilter<"ContractDiscount"> | string
    type?: StringFilter<"ContractDiscount"> | string
    amount?: DecimalNullableFilter<"ContractDiscount"> | Decimal | DecimalJsLike | number | string | null
    percentage?: FloatNullableFilter<"ContractDiscount"> | number | null
    reason?: StringNullableFilter<"ContractDiscount"> | string | null
    createdAt?: DateTimeFilter<"ContractDiscount"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
  }, "id">

  export type ContractDiscountOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    type?: SortOrder
    amount?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ContractDiscountCountOrderByAggregateInput
    _avg?: ContractDiscountAvgOrderByAggregateInput
    _max?: ContractDiscountMaxOrderByAggregateInput
    _min?: ContractDiscountMinOrderByAggregateInput
    _sum?: ContractDiscountSumOrderByAggregateInput
  }

  export type ContractDiscountScalarWhereWithAggregatesInput = {
    AND?: ContractDiscountScalarWhereWithAggregatesInput | ContractDiscountScalarWhereWithAggregatesInput[]
    OR?: ContractDiscountScalarWhereWithAggregatesInput[]
    NOT?: ContractDiscountScalarWhereWithAggregatesInput | ContractDiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractDiscount"> | string
    contractId?: StringWithAggregatesFilter<"ContractDiscount"> | string
    type?: StringWithAggregatesFilter<"ContractDiscount"> | string
    amount?: DecimalNullableWithAggregatesFilter<"ContractDiscount"> | Decimal | DecimalJsLike | number | string | null
    percentage?: FloatNullableWithAggregatesFilter<"ContractDiscount"> | number | null
    reason?: StringNullableWithAggregatesFilter<"ContractDiscount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ContractDiscount"> | Date | string
  }

  export type InstallmentWhereInput = {
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    id?: StringFilter<"Installment"> | string
    contractId?: StringFilter<"Installment"> | string
    sequenceNo?: IntFilter<"Installment"> | number
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    paidAmount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InstallmentOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    sequenceNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractId_sequenceNo?: InstallmentContractIdSequenceNoCompoundUniqueInput
    AND?: InstallmentWhereInput | InstallmentWhereInput[]
    OR?: InstallmentWhereInput[]
    NOT?: InstallmentWhereInput | InstallmentWhereInput[]
    contractId?: StringFilter<"Installment"> | string
    sequenceNo?: IntFilter<"Installment"> | number
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    paidAmount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "contractId_sequenceNo">

  export type InstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    sequenceNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstallmentCountOrderByAggregateInput
    _avg?: InstallmentAvgOrderByAggregateInput
    _max?: InstallmentMaxOrderByAggregateInput
    _min?: InstallmentMinOrderByAggregateInput
    _sum?: InstallmentSumOrderByAggregateInput
  }

  export type InstallmentScalarWhereWithAggregatesInput = {
    AND?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    OR?: InstallmentScalarWhereWithAggregatesInput[]
    NOT?: InstallmentScalarWhereWithAggregatesInput | InstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Installment"> | string
    contractId?: StringWithAggregatesFilter<"Installment"> | string
    sequenceNo?: IntWithAggregatesFilter<"Installment"> | number
    amount?: DecimalWithAggregatesFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    status?: StringWithAggregatesFilter<"Installment"> | string
    paidAmount?: DecimalWithAggregatesFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Installment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Installment"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    contractId?: StringFilter<"Payment"> | string
    installmentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    providerName?: StringNullableFilter<"Payment"> | string | null
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    providerResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    installment?: XOR<InstallmentNullableRelationFilter, InstallmentWhereInput> | null
    refunds?: RefundListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    installmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    providerName?: SortOrderInput | SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    providerResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    installment?: InstallmentOrderByWithRelationInput
    refunds?: RefundOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    contractId?: StringFilter<"Payment"> | string
    installmentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    providerName?: StringNullableFilter<"Payment"> | string | null
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    providerResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    contract?: XOR<ContractRelationFilter, ContractWhereInput>
    installment?: XOR<InstallmentNullableRelationFilter, InstallmentWhereInput> | null
    refunds?: RefundListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    installmentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    method?: SortOrder
    providerName?: SortOrderInput | SortOrder
    providerTransactionId?: SortOrderInput | SortOrder
    status?: SortOrder
    providerResponse?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    contractId?: StringWithAggregatesFilter<"Payment"> | string
    installmentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    providerName?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    providerTransactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    providerResponse?: JsonNullableWithAggregatesFilter<"Payment">
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payment?: PaymentOrderByWithRelationInput
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    paymentId?: StringFilter<"Refund"> | string
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
    payment?: XOR<PaymentRelationFilter, PaymentWhereInput>
  }, "id">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refund"> | string
    paymentId?: StringWithAggregatesFilter<"Refund"> | string
    amount?: DecimalWithAggregatesFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableWithAggregatesFilter<"Refund"> | string | null
    status?: StringWithAggregatesFilter<"Refund"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    recipient?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    status?: StringFilter<"Notification"> | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    error?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    recipient?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    recipient?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    status?: StringFilter<"Notification"> | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    error?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    recipient?: SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    recipient?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    subject?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    content?: StringWithAggregatesFilter<"Notification"> | string
    status?: StringWithAggregatesFilter<"Notification"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCampusesInput
    students?: StudentCreateNestedManyWithoutCampusInput
    contracts?: ContractCreateNestedManyWithoutCampusInput
    exams?: ExamCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCampusInput
    exams?: ExamUncheckedCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCampusesNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
    contracts?: ContractUpdateManyWithoutCampusNestedInput
    exams?: ExamUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCampusNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type CampusCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId?: string | null
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    parentRelations?: StudentParentCreateNestedManyWithoutStudentInput
    contracts?: ContractCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    contracts?: ContractUncheckedCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parentRelations?: StudentParentUpdateManyWithoutStudentNestedInput
    contracts?: ContractUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentRelations?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutParentsInput
    studentRelations?: StudentParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    tenantId: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutParentsNestedInput
    studentRelations?: StudentParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    tenantId: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateInput = {
    isPrimary?: boolean
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutParentRelationsInput
    parent: ParentCreateNestedOneWithoutStudentRelationsInput
  }

  export type StudentParentUncheckedCreateInput = {
    studentId: string
    parentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type StudentParentUpdateInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentRelationsNestedInput
    parent?: ParentUpdateOneRequiredWithoutStudentRelationsNestedInput
  }

  export type StudentParentUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyInput = {
    studentId: string
    parentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type StudentParentUpdateManyMutationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectCreateInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProspectsInput
    interactions?: InteractionCreateNestedManyWithoutProspectInput
    conversions?: ConversionCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutProspectInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProspectsNestedInput
    interactions?: InteractionUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectCreateManyInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateInput = {
    id?: string
    type: string
    content?: string | null
    createdAt?: Date | string
    prospect: ProspectCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    prospectId: string
    type: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prospect?: ProspectUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateManyInput = {
    id?: string
    prospectId: string
    type: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionCreateInput = {
    id?: string
    studentId: string
    convertedAt?: Date | string
    prospect: ProspectCreateNestedOneWithoutConversionsInput
  }

  export type ConversionUncheckedCreateInput = {
    id?: string
    prospectId: string
    studentId: string
    convertedAt?: Date | string
  }

  export type ConversionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prospect?: ProspectUpdateOneRequiredWithoutConversionsNestedInput
  }

  export type ConversionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionCreateManyInput = {
    id?: string
    prospectId: string
    studentId: string
    convertedAt?: Date | string
  }

  export type ConversionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExamsInput
    campus: CampusCreateNestedOneWithoutExamsInput
    sessions?: ExamSessionCreateNestedManyWithoutExamInput
    applications?: ExamApplicationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    tenantId: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ExamSessionUncheckedCreateNestedManyWithoutExamInput
    applications?: ExamApplicationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExamsNestedInput
    campus?: CampusUpdateOneRequiredWithoutExamsNestedInput
    sessions?: ExamSessionUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ExamSessionUncheckedUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    tenantId: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionCreateInput = {
    id?: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    exam: ExamCreateNestedOneWithoutSessionsInput
    campus: CampusCreateNestedOneWithoutExamSessionsInput
    admissionTickets?: AdmissionTicketCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionUncheckedCreateInput = {
    id?: string
    examId: string
    campusId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    admissionTickets?: AdmissionTicketUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutSessionsNestedInput
    campus?: CampusUpdateOneRequiredWithoutExamSessionsNestedInput
    admissionTickets?: AdmissionTicketUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTickets?: AdmissionTicketUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionCreateManyInput = {
    id?: string
    examId: string
    campusId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
  }

  export type ExamSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamApplicationCreateInput = {
    id?: string
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutApplicationsInput
    prospect?: ProspectCreateNestedOneWithoutExamApplicationsInput
    student?: StudentCreateNestedOneWithoutExamApplicationsInput
    admissionTicket?: AdmissionTicketCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationUncheckedCreateInput = {
    id?: string
    examId: string
    prospectId?: string | null
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionTicket?: AdmissionTicketUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutApplicationsNestedInput
    prospect?: ProspectUpdateOneWithoutExamApplicationsNestedInput
    student?: StudentUpdateOneWithoutExamApplicationsNestedInput
    admissionTicket?: AdmissionTicketUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTicket?: AdmissionTicketUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationCreateManyInput = {
    id?: string
    examId: string
    prospectId?: string | null
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTicketCreateInput = {
    id?: string
    seatNumber: string
    application: ExamApplicationCreateNestedOneWithoutAdmissionTicketInput
    session: ExamSessionCreateNestedOneWithoutAdmissionTicketsInput
  }

  export type AdmissionTicketUncheckedCreateInput = {
    id?: string
    applicationId: string
    sessionId: string
    seatNumber: string
  }

  export type AdmissionTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    application?: ExamApplicationUpdateOneRequiredWithoutAdmissionTicketNestedInput
    session?: ExamSessionUpdateOneRequiredWithoutAdmissionTicketsNestedInput
  }

  export type AdmissionTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdmissionTicketCreateManyInput = {
    id?: string
    applicationId: string
    sessionId: string
    seatNumber: string
  }

  export type AdmissionTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdmissionTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ContractCreateInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeItemCreateInput = {
    id?: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutFeeItemsInput
    contractItems?: ContractItemCreateNestedManyWithoutFeeItemInput
  }

  export type FeeItemUncheckedCreateInput = {
    id?: string
    tenantId: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractItems?: ContractItemUncheckedCreateNestedManyWithoutFeeItemInput
  }

  export type FeeItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutFeeItemsNestedInput
    contractItems?: ContractItemUpdateManyWithoutFeeItemNestedInput
  }

  export type FeeItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractItems?: ContractItemUncheckedUpdateManyWithoutFeeItemNestedInput
  }

  export type FeeItemCreateManyInput = {
    id?: string
    tenantId: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemCreateInput = {
    id?: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutItemsInput
    feeItem: FeeItemCreateNestedOneWithoutContractItemsInput
  }

  export type ContractItemUncheckedCreateInput = {
    id?: string
    contractId: string
    feeItemId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ContractItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutItemsNestedInput
    feeItem?: FeeItemUpdateOneRequiredWithoutContractItemsNestedInput
  }

  export type ContractItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    feeItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemCreateManyInput = {
    id?: string
    contractId: string
    feeItemId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ContractItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    feeItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountCreateInput = {
    id?: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutDiscountsInput
  }

  export type ContractDiscountUncheckedCreateInput = {
    id?: string
    contractId: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ContractDiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type ContractDiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountCreateManyInput = {
    id?: string
    contractId: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ContractDiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentCreateInput = {
    id?: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutInstallmentsInput
    payments?: PaymentCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateInput = {
    id?: string
    contractId: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutInstallmentsNestedInput
    payments?: PaymentUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentCreateManyInput = {
    id?: string
    contractId: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutPaymentsInput
    installment?: InstallmentCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    contractId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutPaymentsNestedInput
    installment?: InstallmentUpdateOneWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    contractId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payment: PaymentCreateNestedOneWithoutRefundsInput
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    paymentId: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneRequiredWithoutRefundsNestedInput
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyInput = {
    id?: string
    paymentId: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CampusListRelationFilter = {
    every?: CampusWhereInput
    some?: CampusWhereInput
    none?: CampusWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type StudentListRelationFilter = {
    every?: StudentWhereInput
    some?: StudentWhereInput
    none?: StudentWhereInput
  }

  export type ParentListRelationFilter = {
    every?: ParentWhereInput
    some?: ParentWhereInput
    none?: ParentWhereInput
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type FeeItemListRelationFilter = {
    every?: FeeItemWhereInput
    some?: FeeItemWhereInput
    none?: FeeItemWhereInput
  }

  export type ProspectListRelationFilter = {
    every?: ProspectWhereInput
    some?: ProspectWhereInput
    none?: ProspectWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CampusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeeItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProspectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    settings?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type ExamSessionListRelationFilter = {
    every?: ExamSessionWhereInput
    some?: ExamSessionWhereInput
    none?: ExamSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExamSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampusCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampusMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    refreshToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type CampusRelationFilter = {
    is?: CampusWhereInput
    isNot?: CampusWhereInput
  }

  export type StudentParentListRelationFilter = {
    every?: StudentParentWhereInput
    some?: StudentParentWhereInput
    none?: StudentParentWhereInput
  }

  export type ExamApplicationListRelationFilter = {
    every?: ExamApplicationWhereInput
    some?: ExamApplicationWhereInput
    none?: ExamApplicationWhereInput
  }

  export type StudentParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentTenantIdCampusIdSchoolYearStudentNoCompoundUniqueInput = {
    tenantId: string
    campusId: string
    schoolYear: string
    studentNo: string
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    tcNo?: SortOrder
    studentNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    classLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    classLevel?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    tcNo?: SortOrder
    studentNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    classLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    tcNo?: SortOrder
    studentNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    birthDate?: SortOrder
    gender?: SortOrder
    classLevel?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    classLevel?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tcNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tcNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    tcNo?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    relationType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type StudentParentStudentIdParentIdCompoundUniqueInput = {
    studentId: string
    parentId: string
  }

  export type StudentParentCountOrderByAggregateInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentParentMaxOrderByAggregateInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentParentMinOrderByAggregateInput = {
    studentId?: SortOrder
    parentId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type ConversionListRelationFilter = {
    every?: ConversionWhereInput
    some?: ConversionWhereInput
    none?: ConversionWhereInput
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProspectCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    source?: SortOrder
    score?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ProspectMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    source?: SortOrder
    score?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    status?: SortOrder
    source?: SortOrder
    score?: SortOrder
    stage?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProspectSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProspectRelationFilter = {
    is?: ProspectWhereInput
    isNot?: ProspectWhereInput
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversionCountOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    convertedAt?: SortOrder
  }

  export type ConversionMaxOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    convertedAt?: SortOrder
  }

  export type ConversionMinOrderByAggregateInput = {
    id?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    convertedAt?: SortOrder
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    name?: SortOrder
    date?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ExamRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type AdmissionTicketListRelationFilter = {
    every?: AdmissionTicketWhereInput
    some?: AdmissionTicketWhereInput
    none?: AdmissionTicketWhereInput
  }

  export type AdmissionTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamSessionCountOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    campusId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamSessionAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type ExamSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    campusId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamSessionMinOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    campusId?: SortOrder
    room?: SortOrder
    capacity?: SortOrder
    startTime?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamSessionSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProspectNullableRelationFilter = {
    is?: ProspectWhereInput | null
    isNot?: ProspectWhereInput | null
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type AdmissionTicketNullableRelationFilter = {
    is?: AdmissionTicketWhereInput | null
    isNot?: AdmissionTicketWhereInput | null
  }

  export type ExamApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamApplicationAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type ExamApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    prospectId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    score?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamApplicationSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ExamApplicationRelationFilter = {
    is?: ExamApplicationWhereInput
    isNot?: ExamApplicationWhereInput
  }

  export type ExamSessionRelationFilter = {
    is?: ExamSessionWhereInput
    isNot?: ExamSessionWhereInput
  }

  export type AdmissionTicketCountOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sessionId?: SortOrder
    seatNumber?: SortOrder
  }

  export type AdmissionTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sessionId?: SortOrder
    seatNumber?: SortOrder
  }

  export type AdmissionTicketMinOrderByAggregateInput = {
    id?: SortOrder
    applicationId?: SortOrder
    sessionId?: SortOrder
    seatNumber?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContractItemListRelationFilter = {
    every?: ContractItemWhereInput
    some?: ContractItemWhereInput
    none?: ContractItemWhereInput
  }

  export type InstallmentListRelationFilter = {
    every?: InstallmentWhereInput
    some?: InstallmentWhereInput
    none?: InstallmentWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ContractDiscountListRelationFilter = {
    every?: ContractDiscountWhereInput
    some?: ContractDiscountWhereInput
    none?: ContractDiscountWhereInput
  }

  export type ContractItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractDiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractTenantIdCampusIdSchoolYearContractNoCompoundUniqueInput = {
    tenantId: string
    campusId: string
    schoolYear: string
    contractNo: string
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    studentId?: SortOrder
    contractNo?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
    status?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    studentId?: SortOrder
    contractNo?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
    status?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    campusId?: SortOrder
    schoolYear?: SortOrder
    studentId?: SortOrder
    contractNo?: SortOrder
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
    status?: SortOrder
    signedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    installmentCount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FeeItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    schoolYear?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    isMandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeItemAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FeeItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    schoolYear?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    isMandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    schoolYear?: SortOrder
    name?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    isMandatory?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeeItemSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ContractRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type FeeItemRelationFilter = {
    is?: FeeItemWhereInput
    isNot?: FeeItemWhereInput
  }

  export type ContractItemCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    feeItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type ContractItemMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    feeItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractItemMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    feeItemId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitAmount?: SortOrder
    totalAmount?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ContractDiscountCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractDiscountAvgOrderByAggregateInput = {
    amount?: SortOrder
    percentage?: SortOrder
  }

  export type ContractDiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractDiscountMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    percentage?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ContractDiscountSumOrderByAggregateInput = {
    amount?: SortOrder
    percentage?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type InstallmentContractIdSequenceNoCompoundUniqueInput = {
    contractId: string
    sequenceNo: number
  }

  export type InstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    sequenceNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentAvgOrderByAggregateInput = {
    sequenceNo?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    sequenceNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    sequenceNo?: SortOrder
    amount?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallmentSumOrderByAggregateInput = {
    sequenceNo?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type InstallmentNullableRelationFilter = {
    is?: InstallmentWhereInput | null
    isNot?: InstallmentWhereInput | null
  }

  export type RefundListRelationFilter = {
    every?: RefundWhereInput
    some?: RefundWhereInput
    none?: RefundWhereInput
  }

  export type RefundOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    providerName?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    providerResponse?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    providerName?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    installmentId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    providerName?: SortOrder
    providerTransactionId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PaymentRelationFilter = {
    is?: PaymentWhereInput
    isNot?: PaymentWhereInput
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    paymentId?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    recipient?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    recipient?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    recipient?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
  }

  export type CampusCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput> | CampusCreateWithoutTenantInput[] | CampusUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampusCreateOrConnectWithoutTenantInput | CampusCreateOrConnectWithoutTenantInput[]
    createMany?: CampusCreateManyTenantInputEnvelope
    connect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StudentCreateNestedManyWithoutTenantInput = {
    create?: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput> | StudentCreateWithoutTenantInput[] | StudentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTenantInput | StudentCreateOrConnectWithoutTenantInput[]
    createMany?: StudentCreateManyTenantInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ParentCreateNestedManyWithoutTenantInput = {
    create?: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput> | ParentCreateWithoutTenantInput[] | ParentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutTenantInput | ParentCreateOrConnectWithoutTenantInput[]
    createMany?: ParentCreateManyTenantInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput> | ContractCreateWithoutTenantInput[] | ContractUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutTenantInput | ContractCreateOrConnectWithoutTenantInput[]
    createMany?: ContractCreateManyTenantInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type FeeItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput> | FeeItemCreateWithoutTenantInput[] | FeeItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FeeItemCreateOrConnectWithoutTenantInput | FeeItemCreateOrConnectWithoutTenantInput[]
    createMany?: FeeItemCreateManyTenantInputEnvelope
    connect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
  }

  export type ProspectCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput> | ProspectCreateWithoutTenantInput[] | ProspectUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutTenantInput | ProspectCreateOrConnectWithoutTenantInput[]
    createMany?: ProspectCreateManyTenantInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput> | ExamCreateWithoutTenantInput[] | ExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTenantInput | ExamCreateOrConnectWithoutTenantInput[]
    createMany?: ExamCreateManyTenantInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CampusUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput> | CampusCreateWithoutTenantInput[] | CampusUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampusCreateOrConnectWithoutTenantInput | CampusCreateOrConnectWithoutTenantInput[]
    createMany?: CampusCreateManyTenantInputEnvelope
    connect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput> | StudentCreateWithoutTenantInput[] | StudentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTenantInput | StudentCreateOrConnectWithoutTenantInput[]
    createMany?: StudentCreateManyTenantInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ParentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput> | ParentCreateWithoutTenantInput[] | ParentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutTenantInput | ParentCreateOrConnectWithoutTenantInput[]
    createMany?: ParentCreateManyTenantInputEnvelope
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput> | ContractCreateWithoutTenantInput[] | ContractUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutTenantInput | ContractCreateOrConnectWithoutTenantInput[]
    createMany?: ContractCreateManyTenantInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type FeeItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput> | FeeItemCreateWithoutTenantInput[] | FeeItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FeeItemCreateOrConnectWithoutTenantInput | FeeItemCreateOrConnectWithoutTenantInput[]
    createMany?: FeeItemCreateManyTenantInputEnvelope
    connect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
  }

  export type ProspectUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput> | ProspectCreateWithoutTenantInput[] | ProspectUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutTenantInput | ProspectCreateOrConnectWithoutTenantInput[]
    createMany?: ProspectCreateManyTenantInputEnvelope
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput> | ExamCreateWithoutTenantInput[] | ExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTenantInput | ExamCreateOrConnectWithoutTenantInput[]
    createMany?: ExamCreateManyTenantInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CampusUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput> | CampusCreateWithoutTenantInput[] | CampusUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampusCreateOrConnectWithoutTenantInput | CampusCreateOrConnectWithoutTenantInput[]
    upsert?: CampusUpsertWithWhereUniqueWithoutTenantInput | CampusUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampusCreateManyTenantInputEnvelope
    set?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    disconnect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    delete?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    connect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    update?: CampusUpdateWithWhereUniqueWithoutTenantInput | CampusUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampusUpdateManyWithWhereWithoutTenantInput | CampusUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampusScalarWhereInput | CampusScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StudentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput> | StudentCreateWithoutTenantInput[] | StudentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTenantInput | StudentCreateOrConnectWithoutTenantInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutTenantInput | StudentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StudentCreateManyTenantInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutTenantInput | StudentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutTenantInput | StudentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ParentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput> | ParentCreateWithoutTenantInput[] | ParentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutTenantInput | ParentCreateOrConnectWithoutTenantInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutTenantInput | ParentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ParentCreateManyTenantInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutTenantInput | ParentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutTenantInput | ParentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput> | ContractCreateWithoutTenantInput[] | ContractUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutTenantInput | ContractCreateOrConnectWithoutTenantInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutTenantInput | ContractUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContractCreateManyTenantInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutTenantInput | ContractUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutTenantInput | ContractUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type FeeItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput> | FeeItemCreateWithoutTenantInput[] | FeeItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FeeItemCreateOrConnectWithoutTenantInput | FeeItemCreateOrConnectWithoutTenantInput[]
    upsert?: FeeItemUpsertWithWhereUniqueWithoutTenantInput | FeeItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FeeItemCreateManyTenantInputEnvelope
    set?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    disconnect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    delete?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    connect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    update?: FeeItemUpdateWithWhereUniqueWithoutTenantInput | FeeItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FeeItemUpdateManyWithWhereWithoutTenantInput | FeeItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FeeItemScalarWhereInput | FeeItemScalarWhereInput[]
  }

  export type ProspectUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput> | ProspectCreateWithoutTenantInput[] | ProspectUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutTenantInput | ProspectCreateOrConnectWithoutTenantInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutTenantInput | ProspectUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProspectCreateManyTenantInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutTenantInput | ProspectUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutTenantInput | ProspectUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput> | ExamCreateWithoutTenantInput[] | ExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTenantInput | ExamCreateOrConnectWithoutTenantInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutTenantInput | ExamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExamCreateManyTenantInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutTenantInput | ExamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutTenantInput | ExamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CampusUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput> | CampusCreateWithoutTenantInput[] | CampusUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CampusCreateOrConnectWithoutTenantInput | CampusCreateOrConnectWithoutTenantInput[]
    upsert?: CampusUpsertWithWhereUniqueWithoutTenantInput | CampusUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CampusCreateManyTenantInputEnvelope
    set?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    disconnect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    delete?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    connect?: CampusWhereUniqueInput | CampusWhereUniqueInput[]
    update?: CampusUpdateWithWhereUniqueWithoutTenantInput | CampusUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CampusUpdateManyWithWhereWithoutTenantInput | CampusUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CampusScalarWhereInput | CampusScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput> | StudentCreateWithoutTenantInput[] | StudentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutTenantInput | StudentCreateOrConnectWithoutTenantInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutTenantInput | StudentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: StudentCreateManyTenantInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutTenantInput | StudentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutTenantInput | StudentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ParentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput> | ParentCreateWithoutTenantInput[] | ParentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ParentCreateOrConnectWithoutTenantInput | ParentCreateOrConnectWithoutTenantInput[]
    upsert?: ParentUpsertWithWhereUniqueWithoutTenantInput | ParentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ParentCreateManyTenantInputEnvelope
    set?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    disconnect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    delete?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    connect?: ParentWhereUniqueInput | ParentWhereUniqueInput[]
    update?: ParentUpdateWithWhereUniqueWithoutTenantInput | ParentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ParentUpdateManyWithWhereWithoutTenantInput | ParentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ParentScalarWhereInput | ParentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput> | ContractCreateWithoutTenantInput[] | ContractUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutTenantInput | ContractCreateOrConnectWithoutTenantInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutTenantInput | ContractUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContractCreateManyTenantInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutTenantInput | ContractUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutTenantInput | ContractUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type FeeItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput> | FeeItemCreateWithoutTenantInput[] | FeeItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: FeeItemCreateOrConnectWithoutTenantInput | FeeItemCreateOrConnectWithoutTenantInput[]
    upsert?: FeeItemUpsertWithWhereUniqueWithoutTenantInput | FeeItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: FeeItemCreateManyTenantInputEnvelope
    set?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    disconnect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    delete?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    connect?: FeeItemWhereUniqueInput | FeeItemWhereUniqueInput[]
    update?: FeeItemUpdateWithWhereUniqueWithoutTenantInput | FeeItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: FeeItemUpdateManyWithWhereWithoutTenantInput | FeeItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: FeeItemScalarWhereInput | FeeItemScalarWhereInput[]
  }

  export type ProspectUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput> | ProspectCreateWithoutTenantInput[] | ProspectUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ProspectCreateOrConnectWithoutTenantInput | ProspectCreateOrConnectWithoutTenantInput[]
    upsert?: ProspectUpsertWithWhereUniqueWithoutTenantInput | ProspectUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ProspectCreateManyTenantInputEnvelope
    set?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    disconnect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    delete?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    connect?: ProspectWhereUniqueInput | ProspectWhereUniqueInput[]
    update?: ProspectUpdateWithWhereUniqueWithoutTenantInput | ProspectUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ProspectUpdateManyWithWhereWithoutTenantInput | ProspectUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput> | ExamCreateWithoutTenantInput[] | ExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutTenantInput | ExamCreateOrConnectWithoutTenantInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutTenantInput | ExamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ExamCreateManyTenantInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutTenantInput | ExamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutTenantInput | ExamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutCampusesInput = {
    create?: XOR<TenantCreateWithoutCampusesInput, TenantUncheckedCreateWithoutCampusesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampusesInput
    connect?: TenantWhereUniqueInput
  }

  export type StudentCreateNestedManyWithoutCampusInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutCampusInput = {
    create?: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput> | ContractCreateWithoutCampusInput[] | ContractUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCampusInput | ContractCreateOrConnectWithoutCampusInput[]
    createMany?: ContractCreateManyCampusInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutCampusInput = {
    create?: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput> | ExamCreateWithoutCampusInput[] | ExamUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCampusInput | ExamCreateOrConnectWithoutCampusInput[]
    createMany?: ExamCreateManyCampusInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamSessionCreateNestedManyWithoutCampusInput = {
    create?: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput> | ExamSessionCreateWithoutCampusInput[] | ExamSessionUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutCampusInput | ExamSessionCreateOrConnectWithoutCampusInput[]
    createMany?: ExamSessionCreateManyCampusInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput> | ContractCreateWithoutCampusInput[] | ContractUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCampusInput | ContractCreateOrConnectWithoutCampusInput[]
    createMany?: ContractCreateManyCampusInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput> | ExamCreateWithoutCampusInput[] | ExamUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCampusInput | ExamCreateOrConnectWithoutCampusInput[]
    createMany?: ExamCreateManyCampusInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamSessionUncheckedCreateNestedManyWithoutCampusInput = {
    create?: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput> | ExamSessionCreateWithoutCampusInput[] | ExamSessionUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutCampusInput | ExamSessionCreateOrConnectWithoutCampusInput[]
    createMany?: ExamSessionCreateManyCampusInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type TenantUpdateOneRequiredWithoutCampusesNestedInput = {
    create?: XOR<TenantCreateWithoutCampusesInput, TenantUncheckedCreateWithoutCampusesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCampusesInput
    upsert?: TenantUpsertWithoutCampusesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCampusesInput, TenantUpdateWithoutCampusesInput>, TenantUncheckedUpdateWithoutCampusesInput>
  }

  export type StudentUpdateManyWithoutCampusNestedInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCampusInput | StudentUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCampusInput | StudentUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCampusInput | StudentUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput> | ContractCreateWithoutCampusInput[] | ContractUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCampusInput | ContractCreateOrConnectWithoutCampusInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCampusInput | ContractUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ContractCreateManyCampusInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCampusInput | ContractUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCampusInput | ContractUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput> | ExamCreateWithoutCampusInput[] | ExamUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCampusInput | ExamCreateOrConnectWithoutCampusInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCampusInput | ExamUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ExamCreateManyCampusInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCampusInput | ExamUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCampusInput | ExamUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamSessionUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput> | ExamSessionCreateWithoutCampusInput[] | ExamSessionUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutCampusInput | ExamSessionCreateOrConnectWithoutCampusInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutCampusInput | ExamSessionUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ExamSessionCreateManyCampusInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutCampusInput | ExamSessionUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutCampusInput | ExamSessionUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type StudentUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput> | StudentCreateWithoutCampusInput[] | StudentUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: StudentCreateOrConnectWithoutCampusInput | StudentCreateOrConnectWithoutCampusInput[]
    upsert?: StudentUpsertWithWhereUniqueWithoutCampusInput | StudentUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: StudentCreateManyCampusInputEnvelope
    set?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    disconnect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    delete?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    connect?: StudentWhereUniqueInput | StudentWhereUniqueInput[]
    update?: StudentUpdateWithWhereUniqueWithoutCampusInput | StudentUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: StudentUpdateManyWithWhereWithoutCampusInput | StudentUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: StudentScalarWhereInput | StudentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput> | ContractCreateWithoutCampusInput[] | ContractUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutCampusInput | ContractCreateOrConnectWithoutCampusInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutCampusInput | ContractUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ContractCreateManyCampusInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutCampusInput | ContractUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutCampusInput | ContractUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput> | ExamCreateWithoutCampusInput[] | ExamUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCampusInput | ExamCreateOrConnectWithoutCampusInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCampusInput | ExamUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ExamCreateManyCampusInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCampusInput | ExamUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCampusInput | ExamUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamSessionUncheckedUpdateManyWithoutCampusNestedInput = {
    create?: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput> | ExamSessionCreateWithoutCampusInput[] | ExamSessionUncheckedCreateWithoutCampusInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutCampusInput | ExamSessionCreateOrConnectWithoutCampusInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutCampusInput | ExamSessionUpsertWithWhereUniqueWithoutCampusInput[]
    createMany?: ExamSessionCreateManyCampusInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutCampusInput | ExamSessionUpdateWithWhereUniqueWithoutCampusInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutCampusInput | ExamSessionUpdateManyWithWhereWithoutCampusInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantCreateNestedOneWithoutStudentsInput = {
    create?: XOR<TenantCreateWithoutStudentsInput, TenantUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStudentsInput
    connect?: TenantWhereUniqueInput
  }

  export type CampusCreateNestedOneWithoutStudentsInput = {
    create?: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutStudentsInput
    connect?: CampusWhereUniqueInput
  }

  export type StudentParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type ContractCreateNestedManyWithoutStudentInput = {
    create?: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput> | ContractCreateWithoutStudentInput[] | ContractUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutStudentInput | ContractCreateOrConnectWithoutStudentInput[]
    createMany?: ContractCreateManyStudentInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ExamApplicationCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput> | ExamApplicationCreateWithoutStudentInput[] | ExamApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutStudentInput | ExamApplicationCreateOrConnectWithoutStudentInput[]
    createMany?: ExamApplicationCreateManyStudentInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput> | ContractCreateWithoutStudentInput[] | ContractUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutStudentInput | ContractCreateOrConnectWithoutStudentInput[]
    createMany?: ContractCreateManyStudentInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ExamApplicationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput> | ExamApplicationCreateWithoutStudentInput[] | ExamApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutStudentInput | ExamApplicationCreateOrConnectWithoutStudentInput[]
    createMany?: ExamApplicationCreateManyStudentInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<TenantCreateWithoutStudentsInput, TenantUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutStudentsInput
    upsert?: TenantUpsertWithoutStudentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutStudentsInput, TenantUpdateWithoutStudentsInput>, TenantUncheckedUpdateWithoutStudentsInput>
  }

  export type CampusUpdateOneRequiredWithoutStudentsNestedInput = {
    create?: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutStudentsInput
    upsert?: CampusUpsertWithoutStudentsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutStudentsInput, CampusUpdateWithoutStudentsInput>, CampusUncheckedUpdateWithoutStudentsInput>
  }

  export type StudentParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type ContractUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput> | ContractCreateWithoutStudentInput[] | ContractUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutStudentInput | ContractCreateOrConnectWithoutStudentInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutStudentInput | ContractUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ContractCreateManyStudentInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutStudentInput | ContractUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutStudentInput | ContractUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ExamApplicationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput> | ExamApplicationCreateWithoutStudentInput[] | ExamApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutStudentInput | ExamApplicationCreateOrConnectWithoutStudentInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutStudentInput | ExamApplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamApplicationCreateManyStudentInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutStudentInput | ExamApplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutStudentInput | ExamApplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput> | ContractCreateWithoutStudentInput[] | ContractUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutStudentInput | ContractCreateOrConnectWithoutStudentInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutStudentInput | ContractUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ContractCreateManyStudentInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutStudentInput | ContractUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutStudentInput | ContractUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput> | ExamApplicationCreateWithoutStudentInput[] | ExamApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutStudentInput | ExamApplicationCreateOrConnectWithoutStudentInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutStudentInput | ExamApplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ExamApplicationCreateManyStudentInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutStudentInput | ExamApplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutStudentInput | ExamApplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutParentsInput = {
    create?: XOR<TenantCreateWithoutParentsInput, TenantUncheckedCreateWithoutParentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutParentsInput
    connect?: TenantWhereUniqueInput
  }

  export type StudentParentCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<TenantCreateWithoutParentsInput, TenantUncheckedCreateWithoutParentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutParentsInput
    upsert?: TenantUpsertWithoutParentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutParentsInput, TenantUpdateWithoutParentsInput>, TenantUncheckedUpdateWithoutParentsInput>
  }

  export type StudentParentUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutParentRelationsInput = {
    create?: XOR<StudentCreateWithoutParentRelationsInput, StudentUncheckedCreateWithoutParentRelationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentRelationsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutStudentRelationsInput = {
    create?: XOR<ParentCreateWithoutStudentRelationsInput, ParentUncheckedCreateWithoutStudentRelationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutStudentRelationsInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutParentRelationsNestedInput = {
    create?: XOR<StudentCreateWithoutParentRelationsInput, StudentUncheckedCreateWithoutParentRelationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentRelationsInput
    upsert?: StudentUpsertWithoutParentRelationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentRelationsInput, StudentUpdateWithoutParentRelationsInput>, StudentUncheckedUpdateWithoutParentRelationsInput>
  }

  export type ParentUpdateOneRequiredWithoutStudentRelationsNestedInput = {
    create?: XOR<ParentCreateWithoutStudentRelationsInput, ParentUncheckedCreateWithoutStudentRelationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutStudentRelationsInput
    upsert?: ParentUpsertWithoutStudentRelationsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutStudentRelationsInput, ParentUpdateWithoutStudentRelationsInput>, ParentUncheckedUpdateWithoutStudentRelationsInput>
  }

  export type TenantCreateNestedOneWithoutProspectsInput = {
    create?: XOR<TenantCreateWithoutProspectsInput, TenantUncheckedCreateWithoutProspectsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProspectsInput
    connect?: TenantWhereUniqueInput
  }

  export type InteractionCreateNestedManyWithoutProspectInput = {
    create?: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput> | InteractionCreateWithoutProspectInput[] | InteractionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutProspectInput | InteractionCreateOrConnectWithoutProspectInput[]
    createMany?: InteractionCreateManyProspectInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ConversionCreateNestedManyWithoutProspectInput = {
    create?: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput> | ConversionCreateWithoutProspectInput[] | ConversionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutProspectInput | ConversionCreateOrConnectWithoutProspectInput[]
    createMany?: ConversionCreateManyProspectInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type ExamApplicationCreateNestedManyWithoutProspectInput = {
    create?: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput> | ExamApplicationCreateWithoutProspectInput[] | ExamApplicationUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutProspectInput | ExamApplicationCreateOrConnectWithoutProspectInput[]
    createMany?: ExamApplicationCreateManyProspectInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutProspectInput = {
    create?: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput> | InteractionCreateWithoutProspectInput[] | InteractionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutProspectInput | InteractionCreateOrConnectWithoutProspectInput[]
    createMany?: InteractionCreateManyProspectInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type ConversionUncheckedCreateNestedManyWithoutProspectInput = {
    create?: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput> | ConversionCreateWithoutProspectInput[] | ConversionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutProspectInput | ConversionCreateOrConnectWithoutProspectInput[]
    createMany?: ConversionCreateManyProspectInputEnvelope
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
  }

  export type ExamApplicationUncheckedCreateNestedManyWithoutProspectInput = {
    create?: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput> | ExamApplicationCreateWithoutProspectInput[] | ExamApplicationUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutProspectInput | ExamApplicationCreateOrConnectWithoutProspectInput[]
    createMany?: ExamApplicationCreateManyProspectInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutProspectsNestedInput = {
    create?: XOR<TenantCreateWithoutProspectsInput, TenantUncheckedCreateWithoutProspectsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutProspectsInput
    upsert?: TenantUpsertWithoutProspectsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutProspectsInput, TenantUpdateWithoutProspectsInput>, TenantUncheckedUpdateWithoutProspectsInput>
  }

  export type InteractionUpdateManyWithoutProspectNestedInput = {
    create?: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput> | InteractionCreateWithoutProspectInput[] | InteractionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutProspectInput | InteractionCreateOrConnectWithoutProspectInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutProspectInput | InteractionUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: InteractionCreateManyProspectInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutProspectInput | InteractionUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutProspectInput | InteractionUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ConversionUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput> | ConversionCreateWithoutProspectInput[] | ConversionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutProspectInput | ConversionCreateOrConnectWithoutProspectInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutProspectInput | ConversionUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ConversionCreateManyProspectInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutProspectInput | ConversionUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutProspectInput | ConversionUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type ExamApplicationUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput> | ExamApplicationCreateWithoutProspectInput[] | ExamApplicationUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutProspectInput | ExamApplicationCreateOrConnectWithoutProspectInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutProspectInput | ExamApplicationUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ExamApplicationCreateManyProspectInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutProspectInput | ExamApplicationUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutProspectInput | ExamApplicationUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutProspectNestedInput = {
    create?: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput> | InteractionCreateWithoutProspectInput[] | InteractionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutProspectInput | InteractionCreateOrConnectWithoutProspectInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutProspectInput | InteractionUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: InteractionCreateManyProspectInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutProspectInput | InteractionUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutProspectInput | InteractionUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type ConversionUncheckedUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput> | ConversionCreateWithoutProspectInput[] | ConversionUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ConversionCreateOrConnectWithoutProspectInput | ConversionCreateOrConnectWithoutProspectInput[]
    upsert?: ConversionUpsertWithWhereUniqueWithoutProspectInput | ConversionUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ConversionCreateManyProspectInputEnvelope
    set?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    disconnect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    delete?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    connect?: ConversionWhereUniqueInput | ConversionWhereUniqueInput[]
    update?: ConversionUpdateWithWhereUniqueWithoutProspectInput | ConversionUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ConversionUpdateManyWithWhereWithoutProspectInput | ConversionUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
  }

  export type ExamApplicationUncheckedUpdateManyWithoutProspectNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput> | ExamApplicationCreateWithoutProspectInput[] | ExamApplicationUncheckedCreateWithoutProspectInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutProspectInput | ExamApplicationCreateOrConnectWithoutProspectInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutProspectInput | ExamApplicationUpsertWithWhereUniqueWithoutProspectInput[]
    createMany?: ExamApplicationCreateManyProspectInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutProspectInput | ExamApplicationUpdateWithWhereUniqueWithoutProspectInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutProspectInput | ExamApplicationUpdateManyWithWhereWithoutProspectInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type ProspectCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<ProspectCreateWithoutInteractionsInput, ProspectUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutInteractionsInput
    connect?: ProspectWhereUniqueInput
  }

  export type ProspectUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<ProspectCreateWithoutInteractionsInput, ProspectUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutInteractionsInput
    upsert?: ProspectUpsertWithoutInteractionsInput
    connect?: ProspectWhereUniqueInput
    update?: XOR<XOR<ProspectUpdateToOneWithWhereWithoutInteractionsInput, ProspectUpdateWithoutInteractionsInput>, ProspectUncheckedUpdateWithoutInteractionsInput>
  }

  export type ProspectCreateNestedOneWithoutConversionsInput = {
    create?: XOR<ProspectCreateWithoutConversionsInput, ProspectUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutConversionsInput
    connect?: ProspectWhereUniqueInput
  }

  export type ProspectUpdateOneRequiredWithoutConversionsNestedInput = {
    create?: XOR<ProspectCreateWithoutConversionsInput, ProspectUncheckedCreateWithoutConversionsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutConversionsInput
    upsert?: ProspectUpsertWithoutConversionsInput
    connect?: ProspectWhereUniqueInput
    update?: XOR<XOR<ProspectUpdateToOneWithWhereWithoutConversionsInput, ProspectUpdateWithoutConversionsInput>, ProspectUncheckedUpdateWithoutConversionsInput>
  }

  export type TenantCreateNestedOneWithoutExamsInput = {
    create?: XOR<TenantCreateWithoutExamsInput, TenantUncheckedCreateWithoutExamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExamsInput
    connect?: TenantWhereUniqueInput
  }

  export type CampusCreateNestedOneWithoutExamsInput = {
    create?: XOR<CampusCreateWithoutExamsInput, CampusUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutExamsInput
    connect?: CampusWhereUniqueInput
  }

  export type ExamSessionCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput> | ExamSessionCreateWithoutExamInput[] | ExamSessionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamInput | ExamSessionCreateOrConnectWithoutExamInput[]
    createMany?: ExamSessionCreateManyExamInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type ExamApplicationCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput> | ExamApplicationCreateWithoutExamInput[] | ExamApplicationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutExamInput | ExamApplicationCreateOrConnectWithoutExamInput[]
    createMany?: ExamApplicationCreateManyExamInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type ExamSessionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput> | ExamSessionCreateWithoutExamInput[] | ExamSessionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamInput | ExamSessionCreateOrConnectWithoutExamInput[]
    createMany?: ExamSessionCreateManyExamInputEnvelope
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
  }

  export type ExamApplicationUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput> | ExamApplicationCreateWithoutExamInput[] | ExamApplicationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutExamInput | ExamApplicationCreateOrConnectWithoutExamInput[]
    createMany?: ExamApplicationCreateManyExamInputEnvelope
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<TenantCreateWithoutExamsInput, TenantUncheckedCreateWithoutExamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutExamsInput
    upsert?: TenantUpsertWithoutExamsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutExamsInput, TenantUpdateWithoutExamsInput>, TenantUncheckedUpdateWithoutExamsInput>
  }

  export type CampusUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<CampusCreateWithoutExamsInput, CampusUncheckedCreateWithoutExamsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutExamsInput
    upsert?: CampusUpsertWithoutExamsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutExamsInput, CampusUpdateWithoutExamsInput>, CampusUncheckedUpdateWithoutExamsInput>
  }

  export type ExamSessionUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput> | ExamSessionCreateWithoutExamInput[] | ExamSessionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamInput | ExamSessionCreateOrConnectWithoutExamInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutExamInput | ExamSessionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamSessionCreateManyExamInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutExamInput | ExamSessionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutExamInput | ExamSessionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type ExamApplicationUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput> | ExamApplicationCreateWithoutExamInput[] | ExamApplicationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutExamInput | ExamApplicationCreateOrConnectWithoutExamInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutExamInput | ExamApplicationUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamApplicationCreateManyExamInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutExamInput | ExamApplicationUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutExamInput | ExamApplicationUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type ExamSessionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput> | ExamSessionCreateWithoutExamInput[] | ExamSessionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamSessionCreateOrConnectWithoutExamInput | ExamSessionCreateOrConnectWithoutExamInput[]
    upsert?: ExamSessionUpsertWithWhereUniqueWithoutExamInput | ExamSessionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamSessionCreateManyExamInputEnvelope
    set?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    disconnect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    delete?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    connect?: ExamSessionWhereUniqueInput | ExamSessionWhereUniqueInput[]
    update?: ExamSessionUpdateWithWhereUniqueWithoutExamInput | ExamSessionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamSessionUpdateManyWithWhereWithoutExamInput | ExamSessionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
  }

  export type ExamApplicationUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput> | ExamApplicationCreateWithoutExamInput[] | ExamApplicationUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutExamInput | ExamApplicationCreateOrConnectWithoutExamInput[]
    upsert?: ExamApplicationUpsertWithWhereUniqueWithoutExamInput | ExamApplicationUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamApplicationCreateManyExamInputEnvelope
    set?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    disconnect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    delete?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    connect?: ExamApplicationWhereUniqueInput | ExamApplicationWhereUniqueInput[]
    update?: ExamApplicationUpdateWithWhereUniqueWithoutExamInput | ExamApplicationUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamApplicationUpdateManyWithWhereWithoutExamInput | ExamApplicationUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ExamCreateWithoutSessionsInput, ExamUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutSessionsInput
    connect?: ExamWhereUniqueInput
  }

  export type CampusCreateNestedOneWithoutExamSessionsInput = {
    create?: XOR<CampusCreateWithoutExamSessionsInput, CampusUncheckedCreateWithoutExamSessionsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutExamSessionsInput
    connect?: CampusWhereUniqueInput
  }

  export type AdmissionTicketCreateNestedManyWithoutSessionInput = {
    create?: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput> | AdmissionTicketCreateWithoutSessionInput[] | AdmissionTicketUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutSessionInput | AdmissionTicketCreateOrConnectWithoutSessionInput[]
    createMany?: AdmissionTicketCreateManySessionInputEnvelope
    connect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
  }

  export type AdmissionTicketUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput> | AdmissionTicketCreateWithoutSessionInput[] | AdmissionTicketUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutSessionInput | AdmissionTicketCreateOrConnectWithoutSessionInput[]
    createMany?: AdmissionTicketCreateManySessionInputEnvelope
    connect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
  }

  export type ExamUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ExamCreateWithoutSessionsInput, ExamUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutSessionsInput
    upsert?: ExamUpsertWithoutSessionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutSessionsInput, ExamUpdateWithoutSessionsInput>, ExamUncheckedUpdateWithoutSessionsInput>
  }

  export type CampusUpdateOneRequiredWithoutExamSessionsNestedInput = {
    create?: XOR<CampusCreateWithoutExamSessionsInput, CampusUncheckedCreateWithoutExamSessionsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutExamSessionsInput
    upsert?: CampusUpsertWithoutExamSessionsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutExamSessionsInput, CampusUpdateWithoutExamSessionsInput>, CampusUncheckedUpdateWithoutExamSessionsInput>
  }

  export type AdmissionTicketUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput> | AdmissionTicketCreateWithoutSessionInput[] | AdmissionTicketUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutSessionInput | AdmissionTicketCreateOrConnectWithoutSessionInput[]
    upsert?: AdmissionTicketUpsertWithWhereUniqueWithoutSessionInput | AdmissionTicketUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AdmissionTicketCreateManySessionInputEnvelope
    set?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    disconnect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    delete?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    connect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    update?: AdmissionTicketUpdateWithWhereUniqueWithoutSessionInput | AdmissionTicketUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AdmissionTicketUpdateManyWithWhereWithoutSessionInput | AdmissionTicketUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AdmissionTicketScalarWhereInput | AdmissionTicketScalarWhereInput[]
  }

  export type AdmissionTicketUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput> | AdmissionTicketCreateWithoutSessionInput[] | AdmissionTicketUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutSessionInput | AdmissionTicketCreateOrConnectWithoutSessionInput[]
    upsert?: AdmissionTicketUpsertWithWhereUniqueWithoutSessionInput | AdmissionTicketUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: AdmissionTicketCreateManySessionInputEnvelope
    set?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    disconnect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    delete?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    connect?: AdmissionTicketWhereUniqueInput | AdmissionTicketWhereUniqueInput[]
    update?: AdmissionTicketUpdateWithWhereUniqueWithoutSessionInput | AdmissionTicketUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: AdmissionTicketUpdateManyWithWhereWithoutSessionInput | AdmissionTicketUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: AdmissionTicketScalarWhereInput | AdmissionTicketScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<ExamCreateWithoutApplicationsInput, ExamUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutApplicationsInput
    connect?: ExamWhereUniqueInput
  }

  export type ProspectCreateNestedOneWithoutExamApplicationsInput = {
    create?: XOR<ProspectCreateWithoutExamApplicationsInput, ProspectUncheckedCreateWithoutExamApplicationsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutExamApplicationsInput
    connect?: ProspectWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutExamApplicationsInput = {
    create?: XOR<StudentCreateWithoutExamApplicationsInput, StudentUncheckedCreateWithoutExamApplicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamApplicationsInput
    connect?: StudentWhereUniqueInput
  }

  export type AdmissionTicketCreateNestedOneWithoutApplicationInput = {
    create?: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutApplicationInput
    connect?: AdmissionTicketWhereUniqueInput
  }

  export type AdmissionTicketUncheckedCreateNestedOneWithoutApplicationInput = {
    create?: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutApplicationInput
    connect?: AdmissionTicketWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExamUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<ExamCreateWithoutApplicationsInput, ExamUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutApplicationsInput
    upsert?: ExamUpsertWithoutApplicationsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutApplicationsInput, ExamUpdateWithoutApplicationsInput>, ExamUncheckedUpdateWithoutApplicationsInput>
  }

  export type ProspectUpdateOneWithoutExamApplicationsNestedInput = {
    create?: XOR<ProspectCreateWithoutExamApplicationsInput, ProspectUncheckedCreateWithoutExamApplicationsInput>
    connectOrCreate?: ProspectCreateOrConnectWithoutExamApplicationsInput
    upsert?: ProspectUpsertWithoutExamApplicationsInput
    disconnect?: ProspectWhereInput | boolean
    delete?: ProspectWhereInput | boolean
    connect?: ProspectWhereUniqueInput
    update?: XOR<XOR<ProspectUpdateToOneWithWhereWithoutExamApplicationsInput, ProspectUpdateWithoutExamApplicationsInput>, ProspectUncheckedUpdateWithoutExamApplicationsInput>
  }

  export type StudentUpdateOneWithoutExamApplicationsNestedInput = {
    create?: XOR<StudentCreateWithoutExamApplicationsInput, StudentUncheckedCreateWithoutExamApplicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutExamApplicationsInput
    upsert?: StudentUpsertWithoutExamApplicationsInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutExamApplicationsInput, StudentUpdateWithoutExamApplicationsInput>, StudentUncheckedUpdateWithoutExamApplicationsInput>
  }

  export type AdmissionTicketUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutApplicationInput
    upsert?: AdmissionTicketUpsertWithoutApplicationInput
    disconnect?: AdmissionTicketWhereInput | boolean
    delete?: AdmissionTicketWhereInput | boolean
    connect?: AdmissionTicketWhereUniqueInput
    update?: XOR<XOR<AdmissionTicketUpdateToOneWithWhereWithoutApplicationInput, AdmissionTicketUpdateWithoutApplicationInput>, AdmissionTicketUncheckedUpdateWithoutApplicationInput>
  }

  export type AdmissionTicketUncheckedUpdateOneWithoutApplicationNestedInput = {
    create?: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
    connectOrCreate?: AdmissionTicketCreateOrConnectWithoutApplicationInput
    upsert?: AdmissionTicketUpsertWithoutApplicationInput
    disconnect?: AdmissionTicketWhereInput | boolean
    delete?: AdmissionTicketWhereInput | boolean
    connect?: AdmissionTicketWhereUniqueInput
    update?: XOR<XOR<AdmissionTicketUpdateToOneWithWhereWithoutApplicationInput, AdmissionTicketUpdateWithoutApplicationInput>, AdmissionTicketUncheckedUpdateWithoutApplicationInput>
  }

  export type ExamApplicationCreateNestedOneWithoutAdmissionTicketInput = {
    create?: XOR<ExamApplicationCreateWithoutAdmissionTicketInput, ExamApplicationUncheckedCreateWithoutAdmissionTicketInput>
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutAdmissionTicketInput
    connect?: ExamApplicationWhereUniqueInput
  }

  export type ExamSessionCreateNestedOneWithoutAdmissionTicketsInput = {
    create?: XOR<ExamSessionCreateWithoutAdmissionTicketsInput, ExamSessionUncheckedCreateWithoutAdmissionTicketsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAdmissionTicketsInput
    connect?: ExamSessionWhereUniqueInput
  }

  export type ExamApplicationUpdateOneRequiredWithoutAdmissionTicketNestedInput = {
    create?: XOR<ExamApplicationCreateWithoutAdmissionTicketInput, ExamApplicationUncheckedCreateWithoutAdmissionTicketInput>
    connectOrCreate?: ExamApplicationCreateOrConnectWithoutAdmissionTicketInput
    upsert?: ExamApplicationUpsertWithoutAdmissionTicketInput
    connect?: ExamApplicationWhereUniqueInput
    update?: XOR<XOR<ExamApplicationUpdateToOneWithWhereWithoutAdmissionTicketInput, ExamApplicationUpdateWithoutAdmissionTicketInput>, ExamApplicationUncheckedUpdateWithoutAdmissionTicketInput>
  }

  export type ExamSessionUpdateOneRequiredWithoutAdmissionTicketsNestedInput = {
    create?: XOR<ExamSessionCreateWithoutAdmissionTicketsInput, ExamSessionUncheckedCreateWithoutAdmissionTicketsInput>
    connectOrCreate?: ExamSessionCreateOrConnectWithoutAdmissionTicketsInput
    upsert?: ExamSessionUpsertWithoutAdmissionTicketsInput
    connect?: ExamSessionWhereUniqueInput
    update?: XOR<XOR<ExamSessionUpdateToOneWithWhereWithoutAdmissionTicketsInput, ExamSessionUpdateWithoutAdmissionTicketsInput>, ExamSessionUncheckedUpdateWithoutAdmissionTicketsInput>
  }

  export type TenantCreateNestedOneWithoutContractsInput = {
    create?: XOR<TenantCreateWithoutContractsInput, TenantUncheckedCreateWithoutContractsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContractsInput
    connect?: TenantWhereUniqueInput
  }

  export type CampusCreateNestedOneWithoutContractsInput = {
    create?: XOR<CampusCreateWithoutContractsInput, CampusUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutContractsInput
    connect?: CampusWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutContractsInput = {
    create?: XOR<StudentCreateWithoutContractsInput, StudentUncheckedCreateWithoutContractsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutContractsInput
    connect?: StudentWhereUniqueInput
  }

  export type ContractItemCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput> | ContractItemCreateWithoutContractInput[] | ContractItemUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutContractInput | ContractItemCreateOrConnectWithoutContractInput[]
    createMany?: ContractItemCreateManyContractInputEnvelope
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
  }

  export type InstallmentCreateNestedManyWithoutContractInput = {
    create?: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput> | InstallmentCreateWithoutContractInput[] | InstallmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutContractInput | InstallmentCreateOrConnectWithoutContractInput[]
    createMany?: InstallmentCreateManyContractInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutContractInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractDiscountCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput> | ContractDiscountCreateWithoutContractInput[] | ContractDiscountUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractDiscountCreateOrConnectWithoutContractInput | ContractDiscountCreateOrConnectWithoutContractInput[]
    createMany?: ContractDiscountCreateManyContractInputEnvelope
    connect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
  }

  export type ContractItemUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput> | ContractItemCreateWithoutContractInput[] | ContractItemUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutContractInput | ContractItemCreateOrConnectWithoutContractInput[]
    createMany?: ContractItemCreateManyContractInputEnvelope
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
  }

  export type InstallmentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput> | InstallmentCreateWithoutContractInput[] | InstallmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutContractInput | InstallmentCreateOrConnectWithoutContractInput[]
    createMany?: InstallmentCreateManyContractInputEnvelope
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractDiscountUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput> | ContractDiscountCreateWithoutContractInput[] | ContractDiscountUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractDiscountCreateOrConnectWithoutContractInput | ContractDiscountCreateOrConnectWithoutContractInput[]
    createMany?: ContractDiscountCreateManyContractInputEnvelope
    connect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<TenantCreateWithoutContractsInput, TenantUncheckedCreateWithoutContractsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContractsInput
    upsert?: TenantUpsertWithoutContractsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutContractsInput, TenantUpdateWithoutContractsInput>, TenantUncheckedUpdateWithoutContractsInput>
  }

  export type CampusUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<CampusCreateWithoutContractsInput, CampusUncheckedCreateWithoutContractsInput>
    connectOrCreate?: CampusCreateOrConnectWithoutContractsInput
    upsert?: CampusUpsertWithoutContractsInput
    connect?: CampusWhereUniqueInput
    update?: XOR<XOR<CampusUpdateToOneWithWhereWithoutContractsInput, CampusUpdateWithoutContractsInput>, CampusUncheckedUpdateWithoutContractsInput>
  }

  export type StudentUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<StudentCreateWithoutContractsInput, StudentUncheckedCreateWithoutContractsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutContractsInput
    upsert?: StudentUpsertWithoutContractsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutContractsInput, StudentUpdateWithoutContractsInput>, StudentUncheckedUpdateWithoutContractsInput>
  }

  export type ContractItemUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput> | ContractItemCreateWithoutContractInput[] | ContractItemUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutContractInput | ContractItemCreateOrConnectWithoutContractInput[]
    upsert?: ContractItemUpsertWithWhereUniqueWithoutContractInput | ContractItemUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractItemCreateManyContractInputEnvelope
    set?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    disconnect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    delete?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    update?: ContractItemUpdateWithWhereUniqueWithoutContractInput | ContractItemUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractItemUpdateManyWithWhereWithoutContractInput | ContractItemUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
  }

  export type InstallmentUpdateManyWithoutContractNestedInput = {
    create?: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput> | InstallmentCreateWithoutContractInput[] | InstallmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutContractInput | InstallmentCreateOrConnectWithoutContractInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutContractInput | InstallmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: InstallmentCreateManyContractInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutContractInput | InstallmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutContractInput | InstallmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutContractNestedInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractInput | PaymentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractInput | PaymentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractInput | PaymentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractDiscountUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput> | ContractDiscountCreateWithoutContractInput[] | ContractDiscountUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractDiscountCreateOrConnectWithoutContractInput | ContractDiscountCreateOrConnectWithoutContractInput[]
    upsert?: ContractDiscountUpsertWithWhereUniqueWithoutContractInput | ContractDiscountUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractDiscountCreateManyContractInputEnvelope
    set?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    disconnect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    delete?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    connect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    update?: ContractDiscountUpdateWithWhereUniqueWithoutContractInput | ContractDiscountUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractDiscountUpdateManyWithWhereWithoutContractInput | ContractDiscountUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractDiscountScalarWhereInput | ContractDiscountScalarWhereInput[]
  }

  export type ContractItemUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput> | ContractItemCreateWithoutContractInput[] | ContractItemUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutContractInput | ContractItemCreateOrConnectWithoutContractInput[]
    upsert?: ContractItemUpsertWithWhereUniqueWithoutContractInput | ContractItemUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractItemCreateManyContractInputEnvelope
    set?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    disconnect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    delete?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    update?: ContractItemUpdateWithWhereUniqueWithoutContractInput | ContractItemUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractItemUpdateManyWithWhereWithoutContractInput | ContractItemUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
  }

  export type InstallmentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput> | InstallmentCreateWithoutContractInput[] | InstallmentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: InstallmentCreateOrConnectWithoutContractInput | InstallmentCreateOrConnectWithoutContractInput[]
    upsert?: InstallmentUpsertWithWhereUniqueWithoutContractInput | InstallmentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: InstallmentCreateManyContractInputEnvelope
    set?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    disconnect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    delete?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    connect?: InstallmentWhereUniqueInput | InstallmentWhereUniqueInput[]
    update?: InstallmentUpdateWithWhereUniqueWithoutContractInput | InstallmentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: InstallmentUpdateManyWithWhereWithoutContractInput | InstallmentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput> | PaymentCreateWithoutContractInput[] | PaymentUncheckedCreateWithoutContractInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutContractInput | PaymentCreateOrConnectWithoutContractInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutContractInput | PaymentUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: PaymentCreateManyContractInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutContractInput | PaymentUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutContractInput | PaymentUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractDiscountUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput> | ContractDiscountCreateWithoutContractInput[] | ContractDiscountUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractDiscountCreateOrConnectWithoutContractInput | ContractDiscountCreateOrConnectWithoutContractInput[]
    upsert?: ContractDiscountUpsertWithWhereUniqueWithoutContractInput | ContractDiscountUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractDiscountCreateManyContractInputEnvelope
    set?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    disconnect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    delete?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    connect?: ContractDiscountWhereUniqueInput | ContractDiscountWhereUniqueInput[]
    update?: ContractDiscountUpdateWithWhereUniqueWithoutContractInput | ContractDiscountUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractDiscountUpdateManyWithWhereWithoutContractInput | ContractDiscountUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractDiscountScalarWhereInput | ContractDiscountScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutFeeItemsInput = {
    create?: XOR<TenantCreateWithoutFeeItemsInput, TenantUncheckedCreateWithoutFeeItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFeeItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContractItemCreateNestedManyWithoutFeeItemInput = {
    create?: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput> | ContractItemCreateWithoutFeeItemInput[] | ContractItemUncheckedCreateWithoutFeeItemInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutFeeItemInput | ContractItemCreateOrConnectWithoutFeeItemInput[]
    createMany?: ContractItemCreateManyFeeItemInputEnvelope
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
  }

  export type ContractItemUncheckedCreateNestedManyWithoutFeeItemInput = {
    create?: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput> | ContractItemCreateWithoutFeeItemInput[] | ContractItemUncheckedCreateWithoutFeeItemInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutFeeItemInput | ContractItemCreateOrConnectWithoutFeeItemInput[]
    createMany?: ContractItemCreateManyFeeItemInputEnvelope
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutFeeItemsNestedInput = {
    create?: XOR<TenantCreateWithoutFeeItemsInput, TenantUncheckedCreateWithoutFeeItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutFeeItemsInput
    upsert?: TenantUpsertWithoutFeeItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutFeeItemsInput, TenantUpdateWithoutFeeItemsInput>, TenantUncheckedUpdateWithoutFeeItemsInput>
  }

  export type ContractItemUpdateManyWithoutFeeItemNestedInput = {
    create?: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput> | ContractItemCreateWithoutFeeItemInput[] | ContractItemUncheckedCreateWithoutFeeItemInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutFeeItemInput | ContractItemCreateOrConnectWithoutFeeItemInput[]
    upsert?: ContractItemUpsertWithWhereUniqueWithoutFeeItemInput | ContractItemUpsertWithWhereUniqueWithoutFeeItemInput[]
    createMany?: ContractItemCreateManyFeeItemInputEnvelope
    set?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    disconnect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    delete?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    update?: ContractItemUpdateWithWhereUniqueWithoutFeeItemInput | ContractItemUpdateWithWhereUniqueWithoutFeeItemInput[]
    updateMany?: ContractItemUpdateManyWithWhereWithoutFeeItemInput | ContractItemUpdateManyWithWhereWithoutFeeItemInput[]
    deleteMany?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
  }

  export type ContractItemUncheckedUpdateManyWithoutFeeItemNestedInput = {
    create?: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput> | ContractItemCreateWithoutFeeItemInput[] | ContractItemUncheckedCreateWithoutFeeItemInput[]
    connectOrCreate?: ContractItemCreateOrConnectWithoutFeeItemInput | ContractItemCreateOrConnectWithoutFeeItemInput[]
    upsert?: ContractItemUpsertWithWhereUniqueWithoutFeeItemInput | ContractItemUpsertWithWhereUniqueWithoutFeeItemInput[]
    createMany?: ContractItemCreateManyFeeItemInputEnvelope
    set?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    disconnect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    delete?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    connect?: ContractItemWhereUniqueInput | ContractItemWhereUniqueInput[]
    update?: ContractItemUpdateWithWhereUniqueWithoutFeeItemInput | ContractItemUpdateWithWhereUniqueWithoutFeeItemInput[]
    updateMany?: ContractItemUpdateManyWithWhereWithoutFeeItemInput | ContractItemUpdateManyWithWhereWithoutFeeItemInput[]
    deleteMany?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutItemsInput = {
    create?: XOR<ContractCreateWithoutItemsInput, ContractUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutItemsInput
    connect?: ContractWhereUniqueInput
  }

  export type FeeItemCreateNestedOneWithoutContractItemsInput = {
    create?: XOR<FeeItemCreateWithoutContractItemsInput, FeeItemUncheckedCreateWithoutContractItemsInput>
    connectOrCreate?: FeeItemCreateOrConnectWithoutContractItemsInput
    connect?: FeeItemWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<ContractCreateWithoutItemsInput, ContractUncheckedCreateWithoutItemsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutItemsInput
    upsert?: ContractUpsertWithoutItemsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutItemsInput, ContractUpdateWithoutItemsInput>, ContractUncheckedUpdateWithoutItemsInput>
  }

  export type FeeItemUpdateOneRequiredWithoutContractItemsNestedInput = {
    create?: XOR<FeeItemCreateWithoutContractItemsInput, FeeItemUncheckedCreateWithoutContractItemsInput>
    connectOrCreate?: FeeItemCreateOrConnectWithoutContractItemsInput
    upsert?: FeeItemUpsertWithoutContractItemsInput
    connect?: FeeItemWhereUniqueInput
    update?: XOR<XOR<FeeItemUpdateToOneWithWhereWithoutContractItemsInput, FeeItemUpdateWithoutContractItemsInput>, FeeItemUncheckedUpdateWithoutContractItemsInput>
  }

  export type ContractCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<ContractCreateWithoutDiscountsInput, ContractUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDiscountsInput
    connect?: ContractWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ContractUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<ContractCreateWithoutDiscountsInput, ContractUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutDiscountsInput
    upsert?: ContractUpsertWithoutDiscountsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutDiscountsInput, ContractUpdateWithoutDiscountsInput>, ContractUncheckedUpdateWithoutDiscountsInput>
  }

  export type ContractCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<ContractCreateWithoutInstallmentsInput, ContractUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutInstallmentsInput
    connect?: ContractWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInstallmentInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput> | PaymentCreateWithoutInstallmentInput[] | PaymentUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput | PaymentCreateOrConnectWithoutInstallmentInput[]
    createMany?: PaymentCreateManyInstallmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInstallmentInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput> | PaymentCreateWithoutInstallmentInput[] | PaymentUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput | PaymentCreateOrConnectWithoutInstallmentInput[]
    createMany?: PaymentCreateManyInstallmentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ContractUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<ContractCreateWithoutInstallmentsInput, ContractUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutInstallmentsInput
    upsert?: ContractUpsertWithoutInstallmentsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutInstallmentsInput, ContractUpdateWithoutInstallmentsInput>, ContractUncheckedUpdateWithoutInstallmentsInput>
  }

  export type PaymentUpdateManyWithoutInstallmentNestedInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput> | PaymentCreateWithoutInstallmentInput[] | PaymentUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput | PaymentCreateOrConnectWithoutInstallmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInstallmentInput | PaymentUpsertWithWhereUniqueWithoutInstallmentInput[]
    createMany?: PaymentCreateManyInstallmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInstallmentInput | PaymentUpdateWithWhereUniqueWithoutInstallmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInstallmentInput | PaymentUpdateManyWithWhereWithoutInstallmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInstallmentNestedInput = {
    create?: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput> | PaymentCreateWithoutInstallmentInput[] | PaymentUncheckedCreateWithoutInstallmentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInstallmentInput | PaymentCreateOrConnectWithoutInstallmentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInstallmentInput | PaymentUpsertWithWhereUniqueWithoutInstallmentInput[]
    createMany?: PaymentCreateManyInstallmentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInstallmentInput | PaymentUpdateWithWhereUniqueWithoutInstallmentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInstallmentInput | PaymentUpdateManyWithWhereWithoutInstallmentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ContractCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPaymentsInput
    connect?: ContractWhereUniqueInput
  }

  export type InstallmentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InstallmentCreateWithoutPaymentsInput, InstallmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentsInput
    connect?: InstallmentWhereUniqueInput
  }

  export type RefundCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type RefundUncheckedCreateNestedManyWithoutPaymentInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
  }

  export type ContractUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutPaymentsInput
    upsert?: ContractUpsertWithoutPaymentsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutPaymentsInput, ContractUpdateWithoutPaymentsInput>, ContractUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstallmentUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InstallmentCreateWithoutPaymentsInput, InstallmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstallmentCreateOrConnectWithoutPaymentsInput
    upsert?: InstallmentUpsertWithoutPaymentsInput
    disconnect?: InstallmentWhereInput | boolean
    delete?: InstallmentWhereInput | boolean
    connect?: InstallmentWhereUniqueInput
    update?: XOR<XOR<InstallmentUpdateToOneWithWhereWithoutPaymentsInput, InstallmentUpdateWithoutPaymentsInput>, InstallmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type RefundUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type RefundUncheckedUpdateManyWithoutPaymentNestedInput = {
    create?: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput> | RefundCreateWithoutPaymentInput[] | RefundUncheckedCreateWithoutPaymentInput[]
    connectOrCreate?: RefundCreateOrConnectWithoutPaymentInput | RefundCreateOrConnectWithoutPaymentInput[]
    upsert?: RefundUpsertWithWhereUniqueWithoutPaymentInput | RefundUpsertWithWhereUniqueWithoutPaymentInput[]
    createMany?: RefundCreateManyPaymentInputEnvelope
    set?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    disconnect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    delete?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    connect?: RefundWhereUniqueInput | RefundWhereUniqueInput[]
    update?: RefundUpdateWithWhereUniqueWithoutPaymentInput | RefundUpdateWithWhereUniqueWithoutPaymentInput[]
    updateMany?: RefundUpdateManyWithWhereWithoutPaymentInput | RefundUpdateManyWithWhereWithoutPaymentInput[]
    deleteMany?: RefundScalarWhereInput | RefundScalarWhereInput[]
  }

  export type PaymentCreateNestedOneWithoutRefundsInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUpdateOneRequiredWithoutRefundsNestedInput = {
    create?: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutRefundsInput
    upsert?: PaymentUpsertWithoutRefundsInput
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutRefundsInput, PaymentUpdateWithoutRefundsInput>, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CampusCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentCreateNestedManyWithoutCampusInput
    contracts?: ContractCreateNestedManyWithoutCampusInput
    exams?: ExamCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCampusInput
    exams?: ExamUncheckedCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutTenantInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput>
  }

  export type CampusCreateManyTenantInputEnvelope = {
    data: CampusCreateManyTenantInput | CampusCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type StudentCreateWithoutTenantInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campus: CampusCreateNestedOneWithoutStudentsInput
    parentRelations?: StudentParentCreateNestedManyWithoutStudentInput
    contracts?: ContractCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutTenantInput = {
    id?: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    contracts?: ContractUncheckedCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutTenantInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput>
  }

  export type StudentCreateManyTenantInputEnvelope = {
    data: StudentCreateManyTenantInput | StudentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ParentCreateWithoutTenantInput = {
    id?: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentRelations?: StudentParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutTenantInput = {
    id?: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    studentRelations?: StudentParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutTenantInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput>
  }

  export type ParentCreateManyTenantInputEnvelope = {
    data: ParentCreateManyTenantInput | ParentCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutTenantInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutTenantInput = {
    id?: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutTenantInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput>
  }

  export type ContractCreateManyTenantInputEnvelope = {
    data: ContractCreateManyTenantInput | ContractCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type FeeItemCreateWithoutTenantInput = {
    id?: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractItems?: ContractItemCreateNestedManyWithoutFeeItemInput
  }

  export type FeeItemUncheckedCreateWithoutTenantInput = {
    id?: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractItems?: ContractItemUncheckedCreateNestedManyWithoutFeeItemInput
  }

  export type FeeItemCreateOrConnectWithoutTenantInput = {
    where: FeeItemWhereUniqueInput
    create: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput>
  }

  export type FeeItemCreateManyTenantInputEnvelope = {
    data: FeeItemCreateManyTenantInput | FeeItemCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ProspectCreateWithoutTenantInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionCreateNestedManyWithoutProspectInput
    conversions?: ConversionCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutTenantInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutProspectInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutTenantInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput>
  }

  export type ProspectCreateManyTenantInputEnvelope = {
    data: ProspectCreateManyTenantInput | ProspectCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutTenantInput = {
    id?: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campus: CampusCreateNestedOneWithoutExamsInput
    sessions?: ExamSessionCreateNestedManyWithoutExamInput
    applications?: ExamApplicationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutTenantInput = {
    id?: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ExamSessionUncheckedCreateNestedManyWithoutExamInput
    applications?: ExamApplicationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutTenantInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput>
  }

  export type ExamCreateManyTenantInputEnvelope = {
    data: ExamCreateManyTenantInput | ExamCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CampusUpsertWithWhereUniqueWithoutTenantInput = {
    where: CampusWhereUniqueInput
    update: XOR<CampusUpdateWithoutTenantInput, CampusUncheckedUpdateWithoutTenantInput>
    create: XOR<CampusCreateWithoutTenantInput, CampusUncheckedCreateWithoutTenantInput>
  }

  export type CampusUpdateWithWhereUniqueWithoutTenantInput = {
    where: CampusWhereUniqueInput
    data: XOR<CampusUpdateWithoutTenantInput, CampusUncheckedUpdateWithoutTenantInput>
  }

  export type CampusUpdateManyWithWhereWithoutTenantInput = {
    where: CampusScalarWhereInput
    data: XOR<CampusUpdateManyMutationInput, CampusUncheckedUpdateManyWithoutTenantInput>
  }

  export type CampusScalarWhereInput = {
    AND?: CampusScalarWhereInput | CampusScalarWhereInput[]
    OR?: CampusScalarWhereInput[]
    NOT?: CampusScalarWhereInput | CampusScalarWhereInput[]
    id?: StringFilter<"Campus"> | string
    tenantId?: StringFilter<"Campus"> | string
    name?: StringFilter<"Campus"> | string
    address?: StringNullableFilter<"Campus"> | string | null
    phone?: StringNullableFilter<"Campus"> | string | null
    email?: StringNullableFilter<"Campus"> | string | null
    isActive?: BoolFilter<"Campus"> | boolean
    createdAt?: DateTimeFilter<"Campus"> | Date | string
    updatedAt?: DateTimeFilter<"Campus"> | Date | string
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    refreshToken?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type StudentUpsertWithWhereUniqueWithoutTenantInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutTenantInput, StudentUncheckedUpdateWithoutTenantInput>
    create: XOR<StudentCreateWithoutTenantInput, StudentUncheckedCreateWithoutTenantInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutTenantInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutTenantInput, StudentUncheckedUpdateWithoutTenantInput>
  }

  export type StudentUpdateManyWithWhereWithoutTenantInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutTenantInput>
  }

  export type StudentScalarWhereInput = {
    AND?: StudentScalarWhereInput | StudentScalarWhereInput[]
    OR?: StudentScalarWhereInput[]
    NOT?: StudentScalarWhereInput | StudentScalarWhereInput[]
    id?: StringFilter<"Student"> | string
    tenantId?: StringFilter<"Student"> | string
    campusId?: StringFilter<"Student"> | string
    schoolYear?: StringFilter<"Student"> | string
    tcNo?: StringFilter<"Student"> | string
    studentNo?: StringNullableFilter<"Student"> | string | null
    firstName?: StringFilter<"Student"> | string
    lastName?: StringFilter<"Student"> | string
    birthDate?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    classLevel?: IntFilter<"Student"> | number
    status?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
  }

  export type ParentUpsertWithWhereUniqueWithoutTenantInput = {
    where: ParentWhereUniqueInput
    update: XOR<ParentUpdateWithoutTenantInput, ParentUncheckedUpdateWithoutTenantInput>
    create: XOR<ParentCreateWithoutTenantInput, ParentUncheckedCreateWithoutTenantInput>
  }

  export type ParentUpdateWithWhereUniqueWithoutTenantInput = {
    where: ParentWhereUniqueInput
    data: XOR<ParentUpdateWithoutTenantInput, ParentUncheckedUpdateWithoutTenantInput>
  }

  export type ParentUpdateManyWithWhereWithoutTenantInput = {
    where: ParentScalarWhereInput
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyWithoutTenantInput>
  }

  export type ParentScalarWhereInput = {
    AND?: ParentScalarWhereInput | ParentScalarWhereInput[]
    OR?: ParentScalarWhereInput[]
    NOT?: ParentScalarWhereInput | ParentScalarWhereInput[]
    id?: StringFilter<"Parent"> | string
    tenantId?: StringFilter<"Parent"> | string
    tcNo?: StringFilter<"Parent"> | string
    firstName?: StringFilter<"Parent"> | string
    lastName?: StringFilter<"Parent"> | string
    phone?: StringFilter<"Parent"> | string
    email?: StringNullableFilter<"Parent"> | string | null
    address?: StringNullableFilter<"Parent"> | string | null
    relationType?: StringFilter<"Parent"> | string
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutTenantInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutTenantInput, ContractUncheckedUpdateWithoutTenantInput>
    create: XOR<ContractCreateWithoutTenantInput, ContractUncheckedCreateWithoutTenantInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutTenantInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutTenantInput, ContractUncheckedUpdateWithoutTenantInput>
  }

  export type ContractUpdateManyWithWhereWithoutTenantInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    tenantId?: StringFilter<"Contract"> | string
    campusId?: StringFilter<"Contract"> | string
    schoolYear?: StringFilter<"Contract"> | string
    studentId?: StringFilter<"Contract"> | string
    contractNo?: StringFilter<"Contract"> | string
    totalAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Contract"> | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFilter<"Contract"> | number
    status?: StringFilter<"Contract"> | string
    signedAt?: DateTimeNullableFilter<"Contract"> | Date | string | null
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type FeeItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: FeeItemWhereUniqueInput
    update: XOR<FeeItemUpdateWithoutTenantInput, FeeItemUncheckedUpdateWithoutTenantInput>
    create: XOR<FeeItemCreateWithoutTenantInput, FeeItemUncheckedCreateWithoutTenantInput>
  }

  export type FeeItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: FeeItemWhereUniqueInput
    data: XOR<FeeItemUpdateWithoutTenantInput, FeeItemUncheckedUpdateWithoutTenantInput>
  }

  export type FeeItemUpdateManyWithWhereWithoutTenantInput = {
    where: FeeItemScalarWhereInput
    data: XOR<FeeItemUpdateManyMutationInput, FeeItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type FeeItemScalarWhereInput = {
    AND?: FeeItemScalarWhereInput | FeeItemScalarWhereInput[]
    OR?: FeeItemScalarWhereInput[]
    NOT?: FeeItemScalarWhereInput | FeeItemScalarWhereInput[]
    id?: StringFilter<"FeeItem"> | string
    tenantId?: StringFilter<"FeeItem"> | string
    schoolYear?: StringFilter<"FeeItem"> | string
    name?: StringFilter<"FeeItem"> | string
    amount?: DecimalFilter<"FeeItem"> | Decimal | DecimalJsLike | number | string
    category?: StringNullableFilter<"FeeItem"> | string | null
    isMandatory?: BoolFilter<"FeeItem"> | boolean
    createdAt?: DateTimeFilter<"FeeItem"> | Date | string
    updatedAt?: DateTimeFilter<"FeeItem"> | Date | string
  }

  export type ProspectUpsertWithWhereUniqueWithoutTenantInput = {
    where: ProspectWhereUniqueInput
    update: XOR<ProspectUpdateWithoutTenantInput, ProspectUncheckedUpdateWithoutTenantInput>
    create: XOR<ProspectCreateWithoutTenantInput, ProspectUncheckedCreateWithoutTenantInput>
  }

  export type ProspectUpdateWithWhereUniqueWithoutTenantInput = {
    where: ProspectWhereUniqueInput
    data: XOR<ProspectUpdateWithoutTenantInput, ProspectUncheckedUpdateWithoutTenantInput>
  }

  export type ProspectUpdateManyWithWhereWithoutTenantInput = {
    where: ProspectScalarWhereInput
    data: XOR<ProspectUpdateManyMutationInput, ProspectUncheckedUpdateManyWithoutTenantInput>
  }

  export type ProspectScalarWhereInput = {
    AND?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
    OR?: ProspectScalarWhereInput[]
    NOT?: ProspectScalarWhereInput | ProspectScalarWhereInput[]
    id?: StringFilter<"Prospect"> | string
    tenantId?: StringFilter<"Prospect"> | string
    firstName?: StringFilter<"Prospect"> | string
    lastName?: StringFilter<"Prospect"> | string
    phone?: StringFilter<"Prospect"> | string
    email?: StringNullableFilter<"Prospect"> | string | null
    status?: StringFilter<"Prospect"> | string
    source?: StringNullableFilter<"Prospect"> | string | null
    score?: IntNullableFilter<"Prospect"> | number | null
    stage?: StringNullableFilter<"Prospect"> | string | null
    notes?: StringNullableFilter<"Prospect"> | string | null
    createdAt?: DateTimeFilter<"Prospect"> | Date | string
    updatedAt?: DateTimeFilter<"Prospect"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutTenantInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutTenantInput, ExamUncheckedUpdateWithoutTenantInput>
    create: XOR<ExamCreateWithoutTenantInput, ExamUncheckedCreateWithoutTenantInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutTenantInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutTenantInput, ExamUncheckedUpdateWithoutTenantInput>
  }

  export type ExamUpdateManyWithWhereWithoutTenantInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutTenantInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    tenantId?: StringFilter<"Exam"> | string
    campusId?: StringFilter<"Exam"> | string
    name?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    duration?: IntFilter<"Exam"> | number
    status?: StringFilter<"Exam"> | string
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    recipient?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    status?: StringFilter<"Notification"> | string
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    error?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TenantCreateWithoutCampusesInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCampusesInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCampusesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCampusesInput, TenantUncheckedCreateWithoutCampusesInput>
  }

  export type StudentCreateWithoutCampusInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStudentsInput
    parentRelations?: StudentParentCreateNestedManyWithoutStudentInput
    contracts?: ContractCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCampusInput = {
    id?: string
    tenantId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    contracts?: ContractUncheckedCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCampusInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput>
  }

  export type StudentCreateManyCampusInputEnvelope = {
    data: StudentCreateManyCampusInput | StudentCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutCampusInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutCampusInput = {
    id?: string
    tenantId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutCampusInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput>
  }

  export type ContractCreateManyCampusInputEnvelope = {
    data: ContractCreateManyCampusInput | ContractCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutCampusInput = {
    id?: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExamsInput
    sessions?: ExamSessionCreateNestedManyWithoutExamInput
    applications?: ExamApplicationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCampusInput = {
    id?: string
    tenantId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ExamSessionUncheckedCreateNestedManyWithoutExamInput
    applications?: ExamApplicationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCampusInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput>
  }

  export type ExamCreateManyCampusInputEnvelope = {
    data: ExamCreateManyCampusInput | ExamCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type ExamSessionCreateWithoutCampusInput = {
    id?: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    exam: ExamCreateNestedOneWithoutSessionsInput
    admissionTickets?: AdmissionTicketCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutCampusInput = {
    id?: string
    examId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    admissionTickets?: AdmissionTicketUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutCampusInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput>
  }

  export type ExamSessionCreateManyCampusInputEnvelope = {
    data: ExamSessionCreateManyCampusInput | ExamSessionCreateManyCampusInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutCampusesInput = {
    update: XOR<TenantUpdateWithoutCampusesInput, TenantUncheckedUpdateWithoutCampusesInput>
    create: XOR<TenantCreateWithoutCampusesInput, TenantUncheckedCreateWithoutCampusesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCampusesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCampusesInput, TenantUncheckedUpdateWithoutCampusesInput>
  }

  export type TenantUpdateWithoutCampusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCampusesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StudentUpsertWithWhereUniqueWithoutCampusInput = {
    where: StudentWhereUniqueInput
    update: XOR<StudentUpdateWithoutCampusInput, StudentUncheckedUpdateWithoutCampusInput>
    create: XOR<StudentCreateWithoutCampusInput, StudentUncheckedCreateWithoutCampusInput>
  }

  export type StudentUpdateWithWhereUniqueWithoutCampusInput = {
    where: StudentWhereUniqueInput
    data: XOR<StudentUpdateWithoutCampusInput, StudentUncheckedUpdateWithoutCampusInput>
  }

  export type StudentUpdateManyWithWhereWithoutCampusInput = {
    where: StudentScalarWhereInput
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyWithoutCampusInput>
  }

  export type ContractUpsertWithWhereUniqueWithoutCampusInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutCampusInput, ContractUncheckedUpdateWithoutCampusInput>
    create: XOR<ContractCreateWithoutCampusInput, ContractUncheckedCreateWithoutCampusInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutCampusInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutCampusInput, ContractUncheckedUpdateWithoutCampusInput>
  }

  export type ContractUpdateManyWithWhereWithoutCampusInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutCampusInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutCampusInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutCampusInput, ExamUncheckedUpdateWithoutCampusInput>
    create: XOR<ExamCreateWithoutCampusInput, ExamUncheckedCreateWithoutCampusInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutCampusInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutCampusInput, ExamUncheckedUpdateWithoutCampusInput>
  }

  export type ExamUpdateManyWithWhereWithoutCampusInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutCampusInput>
  }

  export type ExamSessionUpsertWithWhereUniqueWithoutCampusInput = {
    where: ExamSessionWhereUniqueInput
    update: XOR<ExamSessionUpdateWithoutCampusInput, ExamSessionUncheckedUpdateWithoutCampusInput>
    create: XOR<ExamSessionCreateWithoutCampusInput, ExamSessionUncheckedCreateWithoutCampusInput>
  }

  export type ExamSessionUpdateWithWhereUniqueWithoutCampusInput = {
    where: ExamSessionWhereUniqueInput
    data: XOR<ExamSessionUpdateWithoutCampusInput, ExamSessionUncheckedUpdateWithoutCampusInput>
  }

  export type ExamSessionUpdateManyWithWhereWithoutCampusInput = {
    where: ExamSessionScalarWhereInput
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyWithoutCampusInput>
  }

  export type ExamSessionScalarWhereInput = {
    AND?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
    OR?: ExamSessionScalarWhereInput[]
    NOT?: ExamSessionScalarWhereInput | ExamSessionScalarWhereInput[]
    id?: StringFilter<"ExamSession"> | string
    examId?: StringFilter<"ExamSession"> | string
    campusId?: StringFilter<"ExamSession"> | string
    room?: StringFilter<"ExamSession"> | string
    capacity?: IntFilter<"ExamSession"> | number
    startTime?: DateTimeFilter<"ExamSession"> | Date | string
    createdAt?: DateTimeFilter<"ExamSession"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutStudentsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutStudentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutStudentsInput, TenantUncheckedCreateWithoutStudentsInput>
  }

  export type CampusCreateWithoutStudentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCampusesInput
    contracts?: ContractCreateNestedManyWithoutCampusInput
    exams?: ExamCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutStudentsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutCampusInput
    exams?: ExamUncheckedCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutStudentsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
  }

  export type StudentParentCreateWithoutStudentInput = {
    isPrimary?: boolean
    createdAt?: Date | string
    parent: ParentCreateNestedOneWithoutStudentRelationsInput
  }

  export type StudentParentUncheckedCreateWithoutStudentInput = {
    parentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentCreateManyStudentInputEnvelope = {
    data: StudentParentCreateManyStudentInput | StudentParentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ContractCreateWithoutStudentInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutStudentInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutStudentInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput>
  }

  export type ContractCreateManyStudentInputEnvelope = {
    data: ContractCreateManyStudentInput | ContractCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ExamApplicationCreateWithoutStudentInput = {
    id?: string
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutApplicationsInput
    prospect?: ProspectCreateNestedOneWithoutExamApplicationsInput
    admissionTicket?: AdmissionTicketCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationUncheckedCreateWithoutStudentInput = {
    id?: string
    examId: string
    prospectId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionTicket?: AdmissionTicketUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationCreateOrConnectWithoutStudentInput = {
    where: ExamApplicationWhereUniqueInput
    create: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput>
  }

  export type ExamApplicationCreateManyStudentInputEnvelope = {
    data: ExamApplicationCreateManyStudentInput | ExamApplicationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutStudentsInput = {
    update: XOR<TenantUpdateWithoutStudentsInput, TenantUncheckedUpdateWithoutStudentsInput>
    create: XOR<TenantCreateWithoutStudentsInput, TenantUncheckedCreateWithoutStudentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutStudentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutStudentsInput, TenantUncheckedUpdateWithoutStudentsInput>
  }

  export type TenantUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampusUpsertWithoutStudentsInput = {
    update: XOR<CampusUpdateWithoutStudentsInput, CampusUncheckedUpdateWithoutStudentsInput>
    create: XOR<CampusCreateWithoutStudentsInput, CampusUncheckedCreateWithoutStudentsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutStudentsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutStudentsInput, CampusUncheckedUpdateWithoutStudentsInput>
  }

  export type CampusUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCampusesNestedInput
    contracts?: ContractUpdateManyWithoutCampusNestedInput
    exams?: ExamUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutCampusNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type StudentParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentScalarWhereInput = {
    AND?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    OR?: StudentParentScalarWhereInput[]
    NOT?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    createdAt?: DateTimeFilter<"StudentParent"> | Date | string
  }

  export type ContractUpsertWithWhereUniqueWithoutStudentInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutStudentInput, ContractUncheckedUpdateWithoutStudentInput>
    create: XOR<ContractCreateWithoutStudentInput, ContractUncheckedCreateWithoutStudentInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutStudentInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutStudentInput, ContractUncheckedUpdateWithoutStudentInput>
  }

  export type ContractUpdateManyWithWhereWithoutStudentInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamApplicationUpsertWithWhereUniqueWithoutStudentInput = {
    where: ExamApplicationWhereUniqueInput
    update: XOR<ExamApplicationUpdateWithoutStudentInput, ExamApplicationUncheckedUpdateWithoutStudentInput>
    create: XOR<ExamApplicationCreateWithoutStudentInput, ExamApplicationUncheckedCreateWithoutStudentInput>
  }

  export type ExamApplicationUpdateWithWhereUniqueWithoutStudentInput = {
    where: ExamApplicationWhereUniqueInput
    data: XOR<ExamApplicationUpdateWithoutStudentInput, ExamApplicationUncheckedUpdateWithoutStudentInput>
  }

  export type ExamApplicationUpdateManyWithWhereWithoutStudentInput = {
    where: ExamApplicationScalarWhereInput
    data: XOR<ExamApplicationUpdateManyMutationInput, ExamApplicationUncheckedUpdateManyWithoutStudentInput>
  }

  export type ExamApplicationScalarWhereInput = {
    AND?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
    OR?: ExamApplicationScalarWhereInput[]
    NOT?: ExamApplicationScalarWhereInput | ExamApplicationScalarWhereInput[]
    id?: StringFilter<"ExamApplication"> | string
    examId?: StringFilter<"ExamApplication"> | string
    prospectId?: StringNullableFilter<"ExamApplication"> | string | null
    studentId?: StringNullableFilter<"ExamApplication"> | string | null
    status?: StringFilter<"ExamApplication"> | string
    score?: FloatNullableFilter<"ExamApplication"> | number | null
    createdAt?: DateTimeFilter<"ExamApplication"> | Date | string
    updatedAt?: DateTimeFilter<"ExamApplication"> | Date | string
  }

  export type TenantCreateWithoutParentsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutParentsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutParentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutParentsInput, TenantUncheckedCreateWithoutParentsInput>
  }

  export type StudentParentCreateWithoutParentInput = {
    isPrimary?: boolean
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutParentRelationsInput
  }

  export type StudentParentUncheckedCreateWithoutParentInput = {
    studentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type StudentParentCreateOrConnectWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentCreateManyParentInputEnvelope = {
    data: StudentParentCreateManyParentInput | StudentParentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutParentsInput = {
    update: XOR<TenantUpdateWithoutParentsInput, TenantUncheckedUpdateWithoutParentsInput>
    create: XOR<TenantCreateWithoutParentsInput, TenantUncheckedCreateWithoutParentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutParentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutParentsInput, TenantUncheckedUpdateWithoutParentsInput>
  }

  export type TenantUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutParentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StudentParentUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutParentInput>
  }

  export type StudentCreateWithoutParentRelationsInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    contracts?: ContractCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentRelationsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentRelationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentRelationsInput, StudentUncheckedCreateWithoutParentRelationsInput>
  }

  export type ParentCreateWithoutStudentRelationsInput = {
    id?: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutParentsInput
  }

  export type ParentUncheckedCreateWithoutStudentRelationsInput = {
    id?: string
    tenantId: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateOrConnectWithoutStudentRelationsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutStudentRelationsInput, ParentUncheckedCreateWithoutStudentRelationsInput>
  }

  export type StudentUpsertWithoutParentRelationsInput = {
    update: XOR<StudentUpdateWithoutParentRelationsInput, StudentUncheckedUpdateWithoutParentRelationsInput>
    create: XOR<StudentCreateWithoutParentRelationsInput, StudentUncheckedCreateWithoutParentRelationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentRelationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentRelationsInput, StudentUncheckedUpdateWithoutParentRelationsInput>
  }

  export type StudentUpdateWithoutParentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    contracts?: ContractUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutStudentRelationsInput = {
    update: XOR<ParentUpdateWithoutStudentRelationsInput, ParentUncheckedUpdateWithoutStudentRelationsInput>
    create: XOR<ParentCreateWithoutStudentRelationsInput, ParentUncheckedCreateWithoutStudentRelationsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutStudentRelationsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutStudentRelationsInput, ParentUncheckedUpdateWithoutStudentRelationsInput>
  }

  export type ParentUpdateWithoutStudentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutParentsNestedInput
  }

  export type ParentUncheckedUpdateWithoutStudentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutProspectsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutProspectsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutProspectsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutProspectsInput, TenantUncheckedCreateWithoutProspectsInput>
  }

  export type InteractionCreateWithoutProspectInput = {
    id?: string
    type: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionUncheckedCreateWithoutProspectInput = {
    id?: string
    type: string
    content?: string | null
    createdAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutProspectInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput>
  }

  export type InteractionCreateManyProspectInputEnvelope = {
    data: InteractionCreateManyProspectInput | InteractionCreateManyProspectInput[]
    skipDuplicates?: boolean
  }

  export type ConversionCreateWithoutProspectInput = {
    id?: string
    studentId: string
    convertedAt?: Date | string
  }

  export type ConversionUncheckedCreateWithoutProspectInput = {
    id?: string
    studentId: string
    convertedAt?: Date | string
  }

  export type ConversionCreateOrConnectWithoutProspectInput = {
    where: ConversionWhereUniqueInput
    create: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput>
  }

  export type ConversionCreateManyProspectInputEnvelope = {
    data: ConversionCreateManyProspectInput | ConversionCreateManyProspectInput[]
    skipDuplicates?: boolean
  }

  export type ExamApplicationCreateWithoutProspectInput = {
    id?: string
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutApplicationsInput
    student?: StudentCreateNestedOneWithoutExamApplicationsInput
    admissionTicket?: AdmissionTicketCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationUncheckedCreateWithoutProspectInput = {
    id?: string
    examId: string
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionTicket?: AdmissionTicketUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationCreateOrConnectWithoutProspectInput = {
    where: ExamApplicationWhereUniqueInput
    create: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput>
  }

  export type ExamApplicationCreateManyProspectInputEnvelope = {
    data: ExamApplicationCreateManyProspectInput | ExamApplicationCreateManyProspectInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutProspectsInput = {
    update: XOR<TenantUpdateWithoutProspectsInput, TenantUncheckedUpdateWithoutProspectsInput>
    create: XOR<TenantCreateWithoutProspectsInput, TenantUncheckedCreateWithoutProspectsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutProspectsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutProspectsInput, TenantUncheckedUpdateWithoutProspectsInput>
  }

  export type TenantUpdateWithoutProspectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutProspectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InteractionUpsertWithWhereUniqueWithoutProspectInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutProspectInput, InteractionUncheckedUpdateWithoutProspectInput>
    create: XOR<InteractionCreateWithoutProspectInput, InteractionUncheckedCreateWithoutProspectInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutProspectInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutProspectInput, InteractionUncheckedUpdateWithoutProspectInput>
  }

  export type InteractionUpdateManyWithWhereWithoutProspectInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutProspectInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    prospectId?: StringFilter<"Interaction"> | string
    type?: StringFilter<"Interaction"> | string
    content?: StringNullableFilter<"Interaction"> | string | null
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
  }

  export type ConversionUpsertWithWhereUniqueWithoutProspectInput = {
    where: ConversionWhereUniqueInput
    update: XOR<ConversionUpdateWithoutProspectInput, ConversionUncheckedUpdateWithoutProspectInput>
    create: XOR<ConversionCreateWithoutProspectInput, ConversionUncheckedCreateWithoutProspectInput>
  }

  export type ConversionUpdateWithWhereUniqueWithoutProspectInput = {
    where: ConversionWhereUniqueInput
    data: XOR<ConversionUpdateWithoutProspectInput, ConversionUncheckedUpdateWithoutProspectInput>
  }

  export type ConversionUpdateManyWithWhereWithoutProspectInput = {
    where: ConversionScalarWhereInput
    data: XOR<ConversionUpdateManyMutationInput, ConversionUncheckedUpdateManyWithoutProspectInput>
  }

  export type ConversionScalarWhereInput = {
    AND?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    OR?: ConversionScalarWhereInput[]
    NOT?: ConversionScalarWhereInput | ConversionScalarWhereInput[]
    id?: StringFilter<"Conversion"> | string
    prospectId?: StringFilter<"Conversion"> | string
    studentId?: StringFilter<"Conversion"> | string
    convertedAt?: DateTimeFilter<"Conversion"> | Date | string
  }

  export type ExamApplicationUpsertWithWhereUniqueWithoutProspectInput = {
    where: ExamApplicationWhereUniqueInput
    update: XOR<ExamApplicationUpdateWithoutProspectInput, ExamApplicationUncheckedUpdateWithoutProspectInput>
    create: XOR<ExamApplicationCreateWithoutProspectInput, ExamApplicationUncheckedCreateWithoutProspectInput>
  }

  export type ExamApplicationUpdateWithWhereUniqueWithoutProspectInput = {
    where: ExamApplicationWhereUniqueInput
    data: XOR<ExamApplicationUpdateWithoutProspectInput, ExamApplicationUncheckedUpdateWithoutProspectInput>
  }

  export type ExamApplicationUpdateManyWithWhereWithoutProspectInput = {
    where: ExamApplicationScalarWhereInput
    data: XOR<ExamApplicationUpdateManyMutationInput, ExamApplicationUncheckedUpdateManyWithoutProspectInput>
  }

  export type ProspectCreateWithoutInteractionsInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProspectsInput
    conversions?: ConversionCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutInteractionsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversions?: ConversionUncheckedCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutInteractionsInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutInteractionsInput, ProspectUncheckedCreateWithoutInteractionsInput>
  }

  export type ProspectUpsertWithoutInteractionsInput = {
    update: XOR<ProspectUpdateWithoutInteractionsInput, ProspectUncheckedUpdateWithoutInteractionsInput>
    create: XOR<ProspectCreateWithoutInteractionsInput, ProspectUncheckedCreateWithoutInteractionsInput>
    where?: ProspectWhereInput
  }

  export type ProspectUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: ProspectWhereInput
    data: XOR<ProspectUpdateWithoutInteractionsInput, ProspectUncheckedUpdateWithoutInteractionsInput>
  }

  export type ProspectUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProspectsNestedInput
    conversions?: ConversionUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversions?: ConversionUncheckedUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectCreateWithoutConversionsInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProspectsInput
    interactions?: InteractionCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutConversionsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutProspectInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutConversionsInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutConversionsInput, ProspectUncheckedCreateWithoutConversionsInput>
  }

  export type ProspectUpsertWithoutConversionsInput = {
    update: XOR<ProspectUpdateWithoutConversionsInput, ProspectUncheckedUpdateWithoutConversionsInput>
    create: XOR<ProspectCreateWithoutConversionsInput, ProspectUncheckedCreateWithoutConversionsInput>
    where?: ProspectWhereInput
  }

  export type ProspectUpdateToOneWithWhereWithoutConversionsInput = {
    where?: ProspectWhereInput
    data: XOR<ProspectUpdateWithoutConversionsInput, ProspectUncheckedUpdateWithoutConversionsInput>
  }

  export type ProspectUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProspectsNestedInput
    interactions?: InteractionUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutConversionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type TenantCreateWithoutExamsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutExamsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutExamsInput, TenantUncheckedCreateWithoutExamsInput>
  }

  export type CampusCreateWithoutExamsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCampusesInput
    students?: StudentCreateNestedManyWithoutCampusInput
    contracts?: ContractCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutExamsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutExamsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutExamsInput, CampusUncheckedCreateWithoutExamsInput>
  }

  export type ExamSessionCreateWithoutExamInput = {
    id?: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    campus: CampusCreateNestedOneWithoutExamSessionsInput
    admissionTickets?: AdmissionTicketCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionUncheckedCreateWithoutExamInput = {
    id?: string
    campusId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    admissionTickets?: AdmissionTicketUncheckedCreateNestedManyWithoutSessionInput
  }

  export type ExamSessionCreateOrConnectWithoutExamInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput>
  }

  export type ExamSessionCreateManyExamInputEnvelope = {
    data: ExamSessionCreateManyExamInput | ExamSessionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamApplicationCreateWithoutExamInput = {
    id?: string
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    prospect?: ProspectCreateNestedOneWithoutExamApplicationsInput
    student?: StudentCreateNestedOneWithoutExamApplicationsInput
    admissionTicket?: AdmissionTicketCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationUncheckedCreateWithoutExamInput = {
    id?: string
    prospectId?: string | null
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    admissionTicket?: AdmissionTicketUncheckedCreateNestedOneWithoutApplicationInput
  }

  export type ExamApplicationCreateOrConnectWithoutExamInput = {
    where: ExamApplicationWhereUniqueInput
    create: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput>
  }

  export type ExamApplicationCreateManyExamInputEnvelope = {
    data: ExamApplicationCreateManyExamInput | ExamApplicationCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutExamsInput = {
    update: XOR<TenantUpdateWithoutExamsInput, TenantUncheckedUpdateWithoutExamsInput>
    create: XOR<TenantCreateWithoutExamsInput, TenantUncheckedCreateWithoutExamsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutExamsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutExamsInput, TenantUncheckedUpdateWithoutExamsInput>
  }

  export type TenantUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampusUpsertWithoutExamsInput = {
    update: XOR<CampusUpdateWithoutExamsInput, CampusUncheckedUpdateWithoutExamsInput>
    create: XOR<CampusCreateWithoutExamsInput, CampusUncheckedCreateWithoutExamsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutExamsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutExamsInput, CampusUncheckedUpdateWithoutExamsInput>
  }

  export type CampusUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCampusesNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
    contracts?: ContractUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type ExamSessionUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamSessionWhereUniqueInput
    update: XOR<ExamSessionUpdateWithoutExamInput, ExamSessionUncheckedUpdateWithoutExamInput>
    create: XOR<ExamSessionCreateWithoutExamInput, ExamSessionUncheckedCreateWithoutExamInput>
  }

  export type ExamSessionUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamSessionWhereUniqueInput
    data: XOR<ExamSessionUpdateWithoutExamInput, ExamSessionUncheckedUpdateWithoutExamInput>
  }

  export type ExamSessionUpdateManyWithWhereWithoutExamInput = {
    where: ExamSessionScalarWhereInput
    data: XOR<ExamSessionUpdateManyMutationInput, ExamSessionUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamApplicationUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamApplicationWhereUniqueInput
    update: XOR<ExamApplicationUpdateWithoutExamInput, ExamApplicationUncheckedUpdateWithoutExamInput>
    create: XOR<ExamApplicationCreateWithoutExamInput, ExamApplicationUncheckedCreateWithoutExamInput>
  }

  export type ExamApplicationUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamApplicationWhereUniqueInput
    data: XOR<ExamApplicationUpdateWithoutExamInput, ExamApplicationUncheckedUpdateWithoutExamInput>
  }

  export type ExamApplicationUpdateManyWithWhereWithoutExamInput = {
    where: ExamApplicationScalarWhereInput
    data: XOR<ExamApplicationUpdateManyMutationInput, ExamApplicationUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamCreateWithoutSessionsInput = {
    id?: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExamsInput
    campus: CampusCreateNestedOneWithoutExamsInput
    applications?: ExamApplicationCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutSessionsInput = {
    id?: string
    tenantId: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: ExamApplicationUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutSessionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutSessionsInput, ExamUncheckedCreateWithoutSessionsInput>
  }

  export type CampusCreateWithoutExamSessionsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCampusesInput
    students?: StudentCreateNestedManyWithoutCampusInput
    contracts?: ContractCreateNestedManyWithoutCampusInput
    exams?: ExamCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutExamSessionsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
    contracts?: ContractUncheckedCreateNestedManyWithoutCampusInput
    exams?: ExamUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutExamSessionsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutExamSessionsInput, CampusUncheckedCreateWithoutExamSessionsInput>
  }

  export type AdmissionTicketCreateWithoutSessionInput = {
    id?: string
    seatNumber: string
    application: ExamApplicationCreateNestedOneWithoutAdmissionTicketInput
  }

  export type AdmissionTicketUncheckedCreateWithoutSessionInput = {
    id?: string
    applicationId: string
    seatNumber: string
  }

  export type AdmissionTicketCreateOrConnectWithoutSessionInput = {
    where: AdmissionTicketWhereUniqueInput
    create: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput>
  }

  export type AdmissionTicketCreateManySessionInputEnvelope = {
    data: AdmissionTicketCreateManySessionInput | AdmissionTicketCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithoutSessionsInput = {
    update: XOR<ExamUpdateWithoutSessionsInput, ExamUncheckedUpdateWithoutSessionsInput>
    create: XOR<ExamCreateWithoutSessionsInput, ExamUncheckedCreateWithoutSessionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutSessionsInput, ExamUncheckedUpdateWithoutSessionsInput>
  }

  export type ExamUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExamsNestedInput
    campus?: CampusUpdateOneRequiredWithoutExamsNestedInput
    applications?: ExamApplicationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: ExamApplicationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type CampusUpsertWithoutExamSessionsInput = {
    update: XOR<CampusUpdateWithoutExamSessionsInput, CampusUncheckedUpdateWithoutExamSessionsInput>
    create: XOR<CampusCreateWithoutExamSessionsInput, CampusUncheckedCreateWithoutExamSessionsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutExamSessionsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutExamSessionsInput, CampusUncheckedUpdateWithoutExamSessionsInput>
  }

  export type CampusUpdateWithoutExamSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCampusesNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
    contracts?: ContractUpdateManyWithoutCampusNestedInput
    exams?: ExamUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutExamSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCampusNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type AdmissionTicketUpsertWithWhereUniqueWithoutSessionInput = {
    where: AdmissionTicketWhereUniqueInput
    update: XOR<AdmissionTicketUpdateWithoutSessionInput, AdmissionTicketUncheckedUpdateWithoutSessionInput>
    create: XOR<AdmissionTicketCreateWithoutSessionInput, AdmissionTicketUncheckedCreateWithoutSessionInput>
  }

  export type AdmissionTicketUpdateWithWhereUniqueWithoutSessionInput = {
    where: AdmissionTicketWhereUniqueInput
    data: XOR<AdmissionTicketUpdateWithoutSessionInput, AdmissionTicketUncheckedUpdateWithoutSessionInput>
  }

  export type AdmissionTicketUpdateManyWithWhereWithoutSessionInput = {
    where: AdmissionTicketScalarWhereInput
    data: XOR<AdmissionTicketUpdateManyMutationInput, AdmissionTicketUncheckedUpdateManyWithoutSessionInput>
  }

  export type AdmissionTicketScalarWhereInput = {
    AND?: AdmissionTicketScalarWhereInput | AdmissionTicketScalarWhereInput[]
    OR?: AdmissionTicketScalarWhereInput[]
    NOT?: AdmissionTicketScalarWhereInput | AdmissionTicketScalarWhereInput[]
    id?: StringFilter<"AdmissionTicket"> | string
    applicationId?: StringFilter<"AdmissionTicket"> | string
    sessionId?: StringFilter<"AdmissionTicket"> | string
    seatNumber?: StringFilter<"AdmissionTicket"> | string
  }

  export type ExamCreateWithoutApplicationsInput = {
    id?: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutExamsInput
    campus: CampusCreateNestedOneWithoutExamsInput
    sessions?: ExamSessionCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutApplicationsInput = {
    id?: string
    tenantId: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: ExamSessionUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutApplicationsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutApplicationsInput, ExamUncheckedCreateWithoutApplicationsInput>
  }

  export type ProspectCreateWithoutExamApplicationsInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutProspectsInput
    interactions?: InteractionCreateNestedManyWithoutProspectInput
    conversions?: ConversionCreateNestedManyWithoutProspectInput
  }

  export type ProspectUncheckedCreateWithoutExamApplicationsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutProspectInput
    conversions?: ConversionUncheckedCreateNestedManyWithoutProspectInput
  }

  export type ProspectCreateOrConnectWithoutExamApplicationsInput = {
    where: ProspectWhereUniqueInput
    create: XOR<ProspectCreateWithoutExamApplicationsInput, ProspectUncheckedCreateWithoutExamApplicationsInput>
  }

  export type StudentCreateWithoutExamApplicationsInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    parentRelations?: StudentParentCreateNestedManyWithoutStudentInput
    contracts?: ContractCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutExamApplicationsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    contracts?: ContractUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutExamApplicationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutExamApplicationsInput, StudentUncheckedCreateWithoutExamApplicationsInput>
  }

  export type AdmissionTicketCreateWithoutApplicationInput = {
    id?: string
    seatNumber: string
    session: ExamSessionCreateNestedOneWithoutAdmissionTicketsInput
  }

  export type AdmissionTicketUncheckedCreateWithoutApplicationInput = {
    id?: string
    sessionId: string
    seatNumber: string
  }

  export type AdmissionTicketCreateOrConnectWithoutApplicationInput = {
    where: AdmissionTicketWhereUniqueInput
    create: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
  }

  export type ExamUpsertWithoutApplicationsInput = {
    update: XOR<ExamUpdateWithoutApplicationsInput, ExamUncheckedUpdateWithoutApplicationsInput>
    create: XOR<ExamCreateWithoutApplicationsInput, ExamUncheckedCreateWithoutApplicationsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutApplicationsInput, ExamUncheckedUpdateWithoutApplicationsInput>
  }

  export type ExamUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExamsNestedInput
    campus?: CampusUpdateOneRequiredWithoutExamsNestedInput
    sessions?: ExamSessionUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ExamSessionUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ProspectUpsertWithoutExamApplicationsInput = {
    update: XOR<ProspectUpdateWithoutExamApplicationsInput, ProspectUncheckedUpdateWithoutExamApplicationsInput>
    create: XOR<ProspectCreateWithoutExamApplicationsInput, ProspectUncheckedCreateWithoutExamApplicationsInput>
    where?: ProspectWhereInput
  }

  export type ProspectUpdateToOneWithWhereWithoutExamApplicationsInput = {
    where?: ProspectWhereInput
    data: XOR<ProspectUpdateWithoutExamApplicationsInput, ProspectUncheckedUpdateWithoutExamApplicationsInput>
  }

  export type ProspectUpdateWithoutExamApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutProspectsNestedInput
    interactions?: InteractionUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutExamApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type StudentUpsertWithoutExamApplicationsInput = {
    update: XOR<StudentUpdateWithoutExamApplicationsInput, StudentUncheckedUpdateWithoutExamApplicationsInput>
    create: XOR<StudentCreateWithoutExamApplicationsInput, StudentUncheckedCreateWithoutExamApplicationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutExamApplicationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutExamApplicationsInput, StudentUncheckedUpdateWithoutExamApplicationsInput>
  }

  export type StudentUpdateWithoutExamApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parentRelations?: StudentParentUpdateManyWithoutStudentNestedInput
    contracts?: ContractUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutExamApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentRelations?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AdmissionTicketUpsertWithoutApplicationInput = {
    update: XOR<AdmissionTicketUpdateWithoutApplicationInput, AdmissionTicketUncheckedUpdateWithoutApplicationInput>
    create: XOR<AdmissionTicketCreateWithoutApplicationInput, AdmissionTicketUncheckedCreateWithoutApplicationInput>
    where?: AdmissionTicketWhereInput
  }

  export type AdmissionTicketUpdateToOneWithWhereWithoutApplicationInput = {
    where?: AdmissionTicketWhereInput
    data: XOR<AdmissionTicketUpdateWithoutApplicationInput, AdmissionTicketUncheckedUpdateWithoutApplicationInput>
  }

  export type AdmissionTicketUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    session?: ExamSessionUpdateOneRequiredWithoutAdmissionTicketsNestedInput
  }

  export type AdmissionTicketUncheckedUpdateWithoutApplicationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ExamApplicationCreateWithoutAdmissionTicketInput = {
    id?: string
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutApplicationsInput
    prospect?: ProspectCreateNestedOneWithoutExamApplicationsInput
    student?: StudentCreateNestedOneWithoutExamApplicationsInput
  }

  export type ExamApplicationUncheckedCreateWithoutAdmissionTicketInput = {
    id?: string
    examId: string
    prospectId?: string | null
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamApplicationCreateOrConnectWithoutAdmissionTicketInput = {
    where: ExamApplicationWhereUniqueInput
    create: XOR<ExamApplicationCreateWithoutAdmissionTicketInput, ExamApplicationUncheckedCreateWithoutAdmissionTicketInput>
  }

  export type ExamSessionCreateWithoutAdmissionTicketsInput = {
    id?: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
    exam: ExamCreateNestedOneWithoutSessionsInput
    campus: CampusCreateNestedOneWithoutExamSessionsInput
  }

  export type ExamSessionUncheckedCreateWithoutAdmissionTicketsInput = {
    id?: string
    examId: string
    campusId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
  }

  export type ExamSessionCreateOrConnectWithoutAdmissionTicketsInput = {
    where: ExamSessionWhereUniqueInput
    create: XOR<ExamSessionCreateWithoutAdmissionTicketsInput, ExamSessionUncheckedCreateWithoutAdmissionTicketsInput>
  }

  export type ExamApplicationUpsertWithoutAdmissionTicketInput = {
    update: XOR<ExamApplicationUpdateWithoutAdmissionTicketInput, ExamApplicationUncheckedUpdateWithoutAdmissionTicketInput>
    create: XOR<ExamApplicationCreateWithoutAdmissionTicketInput, ExamApplicationUncheckedCreateWithoutAdmissionTicketInput>
    where?: ExamApplicationWhereInput
  }

  export type ExamApplicationUpdateToOneWithWhereWithoutAdmissionTicketInput = {
    where?: ExamApplicationWhereInput
    data: XOR<ExamApplicationUpdateWithoutAdmissionTicketInput, ExamApplicationUncheckedUpdateWithoutAdmissionTicketInput>
  }

  export type ExamApplicationUpdateWithoutAdmissionTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutApplicationsNestedInput
    prospect?: ProspectUpdateOneWithoutExamApplicationsNestedInput
    student?: StudentUpdateOneWithoutExamApplicationsNestedInput
  }

  export type ExamApplicationUncheckedUpdateWithoutAdmissionTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionUpsertWithoutAdmissionTicketsInput = {
    update: XOR<ExamSessionUpdateWithoutAdmissionTicketsInput, ExamSessionUncheckedUpdateWithoutAdmissionTicketsInput>
    create: XOR<ExamSessionCreateWithoutAdmissionTicketsInput, ExamSessionUncheckedCreateWithoutAdmissionTicketsInput>
    where?: ExamSessionWhereInput
  }

  export type ExamSessionUpdateToOneWithWhereWithoutAdmissionTicketsInput = {
    where?: ExamSessionWhereInput
    data: XOR<ExamSessionUpdateWithoutAdmissionTicketsInput, ExamSessionUncheckedUpdateWithoutAdmissionTicketsInput>
  }

  export type ExamSessionUpdateWithoutAdmissionTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutSessionsNestedInput
    campus?: CampusUpdateOneRequiredWithoutExamSessionsNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutAdmissionTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutContractsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutContractsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutContractsInput, TenantUncheckedCreateWithoutContractsInput>
  }

  export type CampusCreateWithoutContractsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCampusesInput
    students?: StudentCreateNestedManyWithoutCampusInput
    exams?: ExamCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionCreateNestedManyWithoutCampusInput
  }

  export type CampusUncheckedCreateWithoutContractsInput = {
    id?: string
    tenantId: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentUncheckedCreateNestedManyWithoutCampusInput
    exams?: ExamUncheckedCreateNestedManyWithoutCampusInput
    examSessions?: ExamSessionUncheckedCreateNestedManyWithoutCampusInput
  }

  export type CampusCreateOrConnectWithoutContractsInput = {
    where: CampusWhereUniqueInput
    create: XOR<CampusCreateWithoutContractsInput, CampusUncheckedCreateWithoutContractsInput>
  }

  export type StudentCreateWithoutContractsInput = {
    id?: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutStudentsInput
    campus: CampusCreateNestedOneWithoutStudentsInput
    parentRelations?: StudentParentCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutContractsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parentRelations?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    examApplications?: ExamApplicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutContractsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutContractsInput, StudentUncheckedCreateWithoutContractsInput>
  }

  export type ContractItemCreateWithoutContractInput = {
    id?: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    feeItem: FeeItemCreateNestedOneWithoutContractItemsInput
  }

  export type ContractItemUncheckedCreateWithoutContractInput = {
    id?: string
    feeItemId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ContractItemCreateOrConnectWithoutContractInput = {
    where: ContractItemWhereUniqueInput
    create: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput>
  }

  export type ContractItemCreateManyContractInputEnvelope = {
    data: ContractItemCreateManyContractInput | ContractItemCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type InstallmentCreateWithoutContractInput = {
    id?: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentUncheckedCreateWithoutContractInput = {
    id?: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInstallmentInput
  }

  export type InstallmentCreateOrConnectWithoutContractInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput>
  }

  export type InstallmentCreateManyContractInputEnvelope = {
    data: InstallmentCreateManyContractInput | InstallmentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutContractInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installment?: InstallmentCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutContractInput = {
    id?: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutContractInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput>
  }

  export type PaymentCreateManyContractInputEnvelope = {
    data: PaymentCreateManyContractInput | PaymentCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ContractDiscountCreateWithoutContractInput = {
    id?: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ContractDiscountUncheckedCreateWithoutContractInput = {
    id?: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ContractDiscountCreateOrConnectWithoutContractInput = {
    where: ContractDiscountWhereUniqueInput
    create: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput>
  }

  export type ContractDiscountCreateManyContractInputEnvelope = {
    data: ContractDiscountCreateManyContractInput | ContractDiscountCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutContractsInput = {
    update: XOR<TenantUpdateWithoutContractsInput, TenantUncheckedUpdateWithoutContractsInput>
    create: XOR<TenantCreateWithoutContractsInput, TenantUncheckedCreateWithoutContractsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutContractsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutContractsInput, TenantUncheckedUpdateWithoutContractsInput>
  }

  export type TenantUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampusUpsertWithoutContractsInput = {
    update: XOR<CampusUpdateWithoutContractsInput, CampusUncheckedUpdateWithoutContractsInput>
    create: XOR<CampusCreateWithoutContractsInput, CampusUncheckedCreateWithoutContractsInput>
    where?: CampusWhereInput
  }

  export type CampusUpdateToOneWithWhereWithoutContractsInput = {
    where?: CampusWhereInput
    data: XOR<CampusUpdateWithoutContractsInput, CampusUncheckedUpdateWithoutContractsInput>
  }

  export type CampusUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCampusesNestedInput
    students?: StudentUpdateManyWithoutCampusNestedInput
    exams?: ExamUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type StudentUpsertWithoutContractsInput = {
    update: XOR<StudentUpdateWithoutContractsInput, StudentUncheckedUpdateWithoutContractsInput>
    create: XOR<StudentCreateWithoutContractsInput, StudentUncheckedCreateWithoutContractsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutContractsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutContractsInput, StudentUncheckedUpdateWithoutContractsInput>
  }

  export type StudentUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStudentsNestedInput
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parentRelations?: StudentParentUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentRelations?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ContractItemUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractItemWhereUniqueInput
    update: XOR<ContractItemUpdateWithoutContractInput, ContractItemUncheckedUpdateWithoutContractInput>
    create: XOR<ContractItemCreateWithoutContractInput, ContractItemUncheckedCreateWithoutContractInput>
  }

  export type ContractItemUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractItemWhereUniqueInput
    data: XOR<ContractItemUpdateWithoutContractInput, ContractItemUncheckedUpdateWithoutContractInput>
  }

  export type ContractItemUpdateManyWithWhereWithoutContractInput = {
    where: ContractItemScalarWhereInput
    data: XOR<ContractItemUpdateManyMutationInput, ContractItemUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractItemScalarWhereInput = {
    AND?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
    OR?: ContractItemScalarWhereInput[]
    NOT?: ContractItemScalarWhereInput | ContractItemScalarWhereInput[]
    id?: StringFilter<"ContractItem"> | string
    contractId?: StringFilter<"ContractItem"> | string
    feeItemId?: StringFilter<"ContractItem"> | string
    description?: StringNullableFilter<"ContractItem"> | string | null
    quantity?: IntFilter<"ContractItem"> | number
    unitAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFilter<"ContractItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"ContractItem"> | Date | string
  }

  export type InstallmentUpsertWithWhereUniqueWithoutContractInput = {
    where: InstallmentWhereUniqueInput
    update: XOR<InstallmentUpdateWithoutContractInput, InstallmentUncheckedUpdateWithoutContractInput>
    create: XOR<InstallmentCreateWithoutContractInput, InstallmentUncheckedCreateWithoutContractInput>
  }

  export type InstallmentUpdateWithWhereUniqueWithoutContractInput = {
    where: InstallmentWhereUniqueInput
    data: XOR<InstallmentUpdateWithoutContractInput, InstallmentUncheckedUpdateWithoutContractInput>
  }

  export type InstallmentUpdateManyWithWhereWithoutContractInput = {
    where: InstallmentScalarWhereInput
    data: XOR<InstallmentUpdateManyMutationInput, InstallmentUncheckedUpdateManyWithoutContractInput>
  }

  export type InstallmentScalarWhereInput = {
    AND?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    OR?: InstallmentScalarWhereInput[]
    NOT?: InstallmentScalarWhereInput | InstallmentScalarWhereInput[]
    id?: StringFilter<"Installment"> | string
    contractId?: StringFilter<"Installment"> | string
    sequenceNo?: IntFilter<"Installment"> | number
    amount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFilter<"Installment"> | Date | string
    status?: StringFilter<"Installment"> | string
    paidAmount?: DecimalFilter<"Installment"> | Decimal | DecimalJsLike | number | string
    paidAt?: DateTimeNullableFilter<"Installment"> | Date | string | null
    createdAt?: DateTimeFilter<"Installment"> | Date | string
    updatedAt?: DateTimeFilter<"Installment"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutContractInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutContractInput, PaymentUncheckedUpdateWithoutContractInput>
    create: XOR<PaymentCreateWithoutContractInput, PaymentUncheckedCreateWithoutContractInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutContractInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutContractInput, PaymentUncheckedUpdateWithoutContractInput>
  }

  export type PaymentUpdateManyWithWhereWithoutContractInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutContractInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    contractId?: StringFilter<"Payment"> | string
    installmentId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    providerName?: StringNullableFilter<"Payment"> | string | null
    providerTransactionId?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    providerResponse?: JsonNullableFilter<"Payment">
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ContractDiscountUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractDiscountWhereUniqueInput
    update: XOR<ContractDiscountUpdateWithoutContractInput, ContractDiscountUncheckedUpdateWithoutContractInput>
    create: XOR<ContractDiscountCreateWithoutContractInput, ContractDiscountUncheckedCreateWithoutContractInput>
  }

  export type ContractDiscountUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractDiscountWhereUniqueInput
    data: XOR<ContractDiscountUpdateWithoutContractInput, ContractDiscountUncheckedUpdateWithoutContractInput>
  }

  export type ContractDiscountUpdateManyWithWhereWithoutContractInput = {
    where: ContractDiscountScalarWhereInput
    data: XOR<ContractDiscountUpdateManyMutationInput, ContractDiscountUncheckedUpdateManyWithoutContractInput>
  }

  export type ContractDiscountScalarWhereInput = {
    AND?: ContractDiscountScalarWhereInput | ContractDiscountScalarWhereInput[]
    OR?: ContractDiscountScalarWhereInput[]
    NOT?: ContractDiscountScalarWhereInput | ContractDiscountScalarWhereInput[]
    id?: StringFilter<"ContractDiscount"> | string
    contractId?: StringFilter<"ContractDiscount"> | string
    type?: StringFilter<"ContractDiscount"> | string
    amount?: DecimalNullableFilter<"ContractDiscount"> | Decimal | DecimalJsLike | number | string | null
    percentage?: FloatNullableFilter<"ContractDiscount"> | number | null
    reason?: StringNullableFilter<"ContractDiscount"> | string | null
    createdAt?: DateTimeFilter<"ContractDiscount"> | Date | string
  }

  export type TenantCreateWithoutFeeItemsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutFeeItemsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutFeeItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutFeeItemsInput, TenantUncheckedCreateWithoutFeeItemsInput>
  }

  export type ContractItemCreateWithoutFeeItemInput = {
    id?: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    contract: ContractCreateNestedOneWithoutItemsInput
  }

  export type ContractItemUncheckedCreateWithoutFeeItemInput = {
    id?: string
    contractId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ContractItemCreateOrConnectWithoutFeeItemInput = {
    where: ContractItemWhereUniqueInput
    create: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput>
  }

  export type ContractItemCreateManyFeeItemInputEnvelope = {
    data: ContractItemCreateManyFeeItemInput | ContractItemCreateManyFeeItemInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutFeeItemsInput = {
    update: XOR<TenantUpdateWithoutFeeItemsInput, TenantUncheckedUpdateWithoutFeeItemsInput>
    create: XOR<TenantCreateWithoutFeeItemsInput, TenantUncheckedCreateWithoutFeeItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutFeeItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutFeeItemsInput, TenantUncheckedUpdateWithoutFeeItemsInput>
  }

  export type TenantUpdateWithoutFeeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutFeeItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContractItemUpsertWithWhereUniqueWithoutFeeItemInput = {
    where: ContractItemWhereUniqueInput
    update: XOR<ContractItemUpdateWithoutFeeItemInput, ContractItemUncheckedUpdateWithoutFeeItemInput>
    create: XOR<ContractItemCreateWithoutFeeItemInput, ContractItemUncheckedCreateWithoutFeeItemInput>
  }

  export type ContractItemUpdateWithWhereUniqueWithoutFeeItemInput = {
    where: ContractItemWhereUniqueInput
    data: XOR<ContractItemUpdateWithoutFeeItemInput, ContractItemUncheckedUpdateWithoutFeeItemInput>
  }

  export type ContractItemUpdateManyWithWhereWithoutFeeItemInput = {
    where: ContractItemScalarWhereInput
    data: XOR<ContractItemUpdateManyMutationInput, ContractItemUncheckedUpdateManyWithoutFeeItemInput>
  }

  export type ContractCreateWithoutItemsInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutItemsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutItemsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutItemsInput, ContractUncheckedCreateWithoutItemsInput>
  }

  export type FeeItemCreateWithoutContractItemsInput = {
    id?: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutFeeItemsInput
  }

  export type FeeItemUncheckedCreateWithoutContractItemsInput = {
    id?: string
    tenantId: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeItemCreateOrConnectWithoutContractItemsInput = {
    where: FeeItemWhereUniqueInput
    create: XOR<FeeItemCreateWithoutContractItemsInput, FeeItemUncheckedCreateWithoutContractItemsInput>
  }

  export type ContractUpsertWithoutItemsInput = {
    update: XOR<ContractUpdateWithoutItemsInput, ContractUncheckedUpdateWithoutItemsInput>
    create: XOR<ContractCreateWithoutItemsInput, ContractUncheckedCreateWithoutItemsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutItemsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutItemsInput, ContractUncheckedUpdateWithoutItemsInput>
  }

  export type ContractUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type FeeItemUpsertWithoutContractItemsInput = {
    update: XOR<FeeItemUpdateWithoutContractItemsInput, FeeItemUncheckedUpdateWithoutContractItemsInput>
    create: XOR<FeeItemCreateWithoutContractItemsInput, FeeItemUncheckedCreateWithoutContractItemsInput>
    where?: FeeItemWhereInput
  }

  export type FeeItemUpdateToOneWithWhereWithoutContractItemsInput = {
    where?: FeeItemWhereInput
    data: XOR<FeeItemUpdateWithoutContractItemsInput, FeeItemUncheckedUpdateWithoutContractItemsInput>
  }

  export type FeeItemUpdateWithoutContractItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutFeeItemsNestedInput
  }

  export type FeeItemUncheckedUpdateWithoutContractItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateWithoutDiscountsInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutDiscountsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutDiscountsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutDiscountsInput, ContractUncheckedCreateWithoutDiscountsInput>
  }

  export type ContractUpsertWithoutDiscountsInput = {
    update: XOR<ContractUpdateWithoutDiscountsInput, ContractUncheckedUpdateWithoutDiscountsInput>
    create: XOR<ContractCreateWithoutDiscountsInput, ContractUncheckedCreateWithoutDiscountsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutDiscountsInput, ContractUncheckedUpdateWithoutDiscountsInput>
  }

  export type ContractUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateWithoutInstallmentsInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    payments?: PaymentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    payments?: PaymentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutInstallmentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutInstallmentsInput, ContractUncheckedCreateWithoutInstallmentsInput>
  }

  export type PaymentCreateWithoutInstallmentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutPaymentsInput
    refunds?: RefundCreateNestedManyWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutInstallmentInput = {
    id?: string
    contractId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refunds?: RefundUncheckedCreateNestedManyWithoutPaymentInput
  }

  export type PaymentCreateOrConnectWithoutInstallmentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
  }

  export type PaymentCreateManyInstallmentInputEnvelope = {
    data: PaymentCreateManyInstallmentInput | PaymentCreateManyInstallmentInput[]
    skipDuplicates?: boolean
  }

  export type ContractUpsertWithoutInstallmentsInput = {
    update: XOR<ContractUpdateWithoutInstallmentsInput, ContractUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<ContractCreateWithoutInstallmentsInput, ContractUncheckedCreateWithoutInstallmentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutInstallmentsInput, ContractUncheckedUpdateWithoutInstallmentsInput>
  }

  export type ContractUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInstallmentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInstallmentInput, PaymentUncheckedUpdateWithoutInstallmentInput>
    create: XOR<PaymentCreateWithoutInstallmentInput, PaymentUncheckedCreateWithoutInstallmentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInstallmentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInstallmentInput, PaymentUncheckedUpdateWithoutInstallmentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInstallmentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInstallmentInput>
  }

  export type ContractCreateWithoutPaymentsInput = {
    id?: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContractsInput
    campus: CampusCreateNestedOneWithoutContractsInput
    student: StudentCreateNestedOneWithoutContractsInput
    items?: ContractItemCreateNestedManyWithoutContractInput
    installments?: InstallmentCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: ContractItemUncheckedCreateNestedManyWithoutContractInput
    installments?: InstallmentUncheckedCreateNestedManyWithoutContractInput
    discounts?: ContractDiscountUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutPaymentsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
  }

  export type InstallmentCreateWithoutPaymentsInput = {
    id?: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutInstallmentsInput
  }

  export type InstallmentUncheckedCreateWithoutPaymentsInput = {
    id?: string
    contractId: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallmentCreateOrConnectWithoutPaymentsInput = {
    where: InstallmentWhereUniqueInput
    create: XOR<InstallmentCreateWithoutPaymentsInput, InstallmentUncheckedCreateWithoutPaymentsInput>
  }

  export type RefundCreateWithoutPaymentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundUncheckedCreateWithoutPaymentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundCreateOrConnectWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundCreateManyPaymentInputEnvelope = {
    data: RefundCreateManyPaymentInput | RefundCreateManyPaymentInput[]
    skipDuplicates?: boolean
  }

  export type ContractUpsertWithoutPaymentsInput = {
    update: XOR<ContractUpdateWithoutPaymentsInput, ContractUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ContractCreateWithoutPaymentsInput, ContractUncheckedCreateWithoutPaymentsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutPaymentsInput, ContractUncheckedUpdateWithoutPaymentsInput>
  }

  export type ContractUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type InstallmentUpsertWithoutPaymentsInput = {
    update: XOR<InstallmentUpdateWithoutPaymentsInput, InstallmentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InstallmentCreateWithoutPaymentsInput, InstallmentUncheckedCreateWithoutPaymentsInput>
    where?: InstallmentWhereInput
  }

  export type InstallmentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InstallmentWhereInput
    data: XOR<InstallmentUpdateWithoutPaymentsInput, InstallmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstallmentUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUpsertWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    update: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
    create: XOR<RefundCreateWithoutPaymentInput, RefundUncheckedCreateWithoutPaymentInput>
  }

  export type RefundUpdateWithWhereUniqueWithoutPaymentInput = {
    where: RefundWhereUniqueInput
    data: XOR<RefundUpdateWithoutPaymentInput, RefundUncheckedUpdateWithoutPaymentInput>
  }

  export type RefundUpdateManyWithWhereWithoutPaymentInput = {
    where: RefundScalarWhereInput
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyWithoutPaymentInput>
  }

  export type RefundScalarWhereInput = {
    AND?: RefundScalarWhereInput | RefundScalarWhereInput[]
    OR?: RefundScalarWhereInput[]
    NOT?: RefundScalarWhereInput | RefundScalarWhereInput[]
    id?: StringFilter<"Refund"> | string
    paymentId?: StringFilter<"Refund"> | string
    amount?: DecimalFilter<"Refund"> | Decimal | DecimalJsLike | number | string
    reason?: StringNullableFilter<"Refund"> | string | null
    status?: StringFilter<"Refund"> | string
    createdAt?: DateTimeFilter<"Refund"> | Date | string
    updatedAt?: DateTimeFilter<"Refund"> | Date | string
  }

  export type PaymentCreateWithoutRefundsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutPaymentsInput
    installment?: InstallmentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutRefundsInput = {
    id?: string
    contractId: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutRefundsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
  }

  export type PaymentUpsertWithoutRefundsInput = {
    update: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
    create: XOR<PaymentCreateWithoutRefundsInput, PaymentUncheckedCreateWithoutRefundsInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutRefundsInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutRefundsInput, PaymentUncheckedUpdateWithoutRefundsInput>
  }

  export type PaymentUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutPaymentsNestedInput
    installment?: InstallmentUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutRefundsInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusCreateNestedManyWithoutTenantInput
    users?: UserCreateNestedManyWithoutTenantInput
    students?: StudentCreateNestedManyWithoutTenantInput
    parents?: ParentCreateNestedManyWithoutTenantInput
    contracts?: ContractCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemCreateNestedManyWithoutTenantInput
    prospects?: ProspectCreateNestedManyWithoutTenantInput
    exams?: ExamCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    domain: string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    campuses?: CampusUncheckedCreateNestedManyWithoutTenantInput
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    students?: StudentUncheckedCreateNestedManyWithoutTenantInput
    parents?: ParentUncheckedCreateNestedManyWithoutTenantInput
    contracts?: ContractUncheckedCreateNestedManyWithoutTenantInput
    feeItems?: FeeItemUncheckedCreateNestedManyWithoutTenantInput
    prospects?: ProspectUncheckedCreateNestedManyWithoutTenantInput
    exams?: ExamUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUpdateManyWithoutTenantNestedInput
    users?: UserUpdateManyWithoutTenantNestedInput
    students?: StudentUpdateManyWithoutTenantNestedInput
    parents?: ParentUpdateManyWithoutTenantNestedInput
    contracts?: ContractUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUpdateManyWithoutTenantNestedInput
    exams?: ExamUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    settings?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campuses?: CampusUncheckedUpdateManyWithoutTenantNestedInput
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    students?: StudentUncheckedUpdateManyWithoutTenantNestedInput
    parents?: ParentUncheckedUpdateManyWithoutTenantNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutTenantNestedInput
    feeItems?: FeeItemUncheckedUpdateManyWithoutTenantNestedInput
    prospects?: ProspectUncheckedUpdateManyWithoutTenantNestedInput
    exams?: ExamUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CampusCreateManyTenantInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email?: string | null
    phone: string
    passwordHash?: string | null
    role: string
    refreshToken?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentCreateManyTenantInput = {
    id?: string
    campusId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentCreateManyTenantInput = {
    id?: string
    tcNo: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    address?: string | null
    relationType: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateManyTenantInput = {
    id?: string
    campusId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeeItemCreateManyTenantInput = {
    id?: string
    schoolYear: string
    name: string
    amount: Decimal | DecimalJsLike | number | string
    category?: string | null
    isMandatory?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProspectCreateManyTenantInput = {
    id?: string
    firstName: string
    lastName: string
    phone: string
    email?: string | null
    status?: string
    source?: string | null
    score?: number | null
    stage?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyTenantInput = {
    id?: string
    campusId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    recipient: string
    type: string
    subject?: string | null
    content: string
    status?: string
    sentAt?: Date | string | null
    error?: string | null
    createdAt?: Date | string
  }

  export type CampusUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUpdateManyWithoutCampusNestedInput
    contracts?: ContractUpdateManyWithoutCampusNestedInput
    exams?: ExamUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentUncheckedUpdateManyWithoutCampusNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutCampusNestedInput
    exams?: ExamUncheckedUpdateManyWithoutCampusNestedInput
    examSessions?: ExamSessionUncheckedUpdateManyWithoutCampusNestedInput
  }

  export type CampusUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: CampusUpdateOneRequiredWithoutStudentsNestedInput
    parentRelations?: StudentParentUpdateManyWithoutStudentNestedInput
    contracts?: ContractUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentRelations?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentRelations?: StudentParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentRelations?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    relationType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeeItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractItems?: ContractItemUpdateManyWithoutFeeItemNestedInput
  }

  export type FeeItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractItems?: ContractItemUncheckedUpdateManyWithoutFeeItemNestedInput
  }

  export type FeeItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    isMandatory?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProspectUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutProspectNestedInput
    conversions?: ConversionUncheckedUpdateManyWithoutProspectNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutProspectNestedInput
  }

  export type ProspectUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: CampusUpdateOneRequiredWithoutExamsNestedInput
    sessions?: ExamSessionUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ExamSessionUncheckedUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipient?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateManyCampusInput = {
    id?: string
    tenantId: string
    schoolYear: string
    tcNo: string
    studentNo?: string | null
    firstName: string
    lastName: string
    birthDate: Date | string
    gender: string
    classLevel: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractCreateManyCampusInput = {
    id?: string
    tenantId: string
    schoolYear: string
    studentId: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyCampusInput = {
    id?: string
    tenantId: string
    name: string
    date: Date | string
    duration: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSessionCreateManyCampusInput = {
    id?: string
    examId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
  }

  export type StudentUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutStudentsNestedInput
    parentRelations?: StudentParentUpdateManyWithoutStudentNestedInput
    contracts?: ContractUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentRelations?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    contracts?: ContractUncheckedUpdateManyWithoutStudentNestedInput
    examApplications?: ExamApplicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateManyWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    tcNo?: StringFieldUpdateOperationsInput | string
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    classLevel?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    student?: StudentUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutExamsNestedInput
    sessions?: ExamSessionUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: ExamSessionUncheckedUpdateManyWithoutExamNestedInput
    applications?: ExamApplicationUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutSessionsNestedInput
    admissionTickets?: AdmissionTicketUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTickets?: AdmissionTicketUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateManyWithoutCampusInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyStudentInput = {
    parentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type ContractCreateManyStudentInput = {
    id?: string
    tenantId: string
    campusId: string
    schoolYear: string
    contractNo: string
    totalAmount: Decimal | DecimalJsLike | number | string
    discountAmount?: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    installmentCount: number
    status?: string
    signedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamApplicationCreateManyStudentInput = {
    id?: string
    examId: string
    prospectId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateWithoutStudentInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutStudentRelationsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContractsNestedInput
    campus?: CampusUpdateOneRequiredWithoutContractsNestedInput
    items?: ContractItemUpdateManyWithoutContractNestedInput
    installments?: InstallmentUpdateManyWithoutContractNestedInput
    payments?: PaymentUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: ContractItemUncheckedUpdateManyWithoutContractNestedInput
    installments?: InstallmentUncheckedUpdateManyWithoutContractNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutContractNestedInput
    discounts?: ContractDiscountUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    schoolYear?: StringFieldUpdateOperationsInput | string
    contractNo?: StringFieldUpdateOperationsInput | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    installmentCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    signedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamApplicationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutApplicationsNestedInput
    prospect?: ProspectUpdateOneWithoutExamApplicationsNestedInput
    admissionTicket?: AdmissionTicketUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTicket?: AdmissionTicketUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyParentInput = {
    studentId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type StudentParentUpdateWithoutParentInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutParentRelationsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentUncheckedUpdateManyWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateManyProspectInput = {
    id?: string
    type: string
    content?: string | null
    createdAt?: Date | string
  }

  export type ConversionCreateManyProspectInput = {
    id?: string
    studentId: string
    convertedAt?: Date | string
  }

  export type ExamApplicationCreateManyProspectInput = {
    id?: string
    examId: string
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUncheckedUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionUncheckedUpdateManyWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    convertedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamApplicationUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutApplicationsNestedInput
    student?: StudentUpdateOneWithoutExamApplicationsNestedInput
    admissionTicket?: AdmissionTicketUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTicket?: AdmissionTicketUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateManyWithoutProspectInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamSessionCreateManyExamInput = {
    id?: string
    campusId: string
    room: string
    capacity: number
    startTime: Date | string
    createdAt?: Date | string
  }

  export type ExamApplicationCreateManyExamInput = {
    id?: string
    prospectId?: string | null
    studentId?: string | null
    status?: string
    score?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamSessionUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campus?: CampusUpdateOneRequiredWithoutExamSessionsNestedInput
    admissionTickets?: AdmissionTicketUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTickets?: AdmissionTicketUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ExamSessionUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    campusId?: StringFieldUpdateOperationsInput | string
    room?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamApplicationUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    prospect?: ProspectUpdateOneWithoutExamApplicationsNestedInput
    student?: StudentUpdateOneWithoutExamApplicationsNestedInput
    admissionTicket?: AdmissionTicketUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admissionTicket?: AdmissionTicketUncheckedUpdateOneWithoutApplicationNestedInput
  }

  export type ExamApplicationUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    prospectId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdmissionTicketCreateManySessionInput = {
    id?: string
    applicationId: string
    seatNumber: string
  }

  export type AdmissionTicketUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
    application?: ExamApplicationUpdateOneRequiredWithoutAdmissionTicketNestedInput
  }

  export type AdmissionTicketUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type AdmissionTicketUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationId?: StringFieldUpdateOperationsInput | string
    seatNumber?: StringFieldUpdateOperationsInput | string
  }

  export type ContractItemCreateManyContractInput = {
    id?: string
    feeItemId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type InstallmentCreateManyContractInput = {
    id?: string
    sequenceNo: number
    amount: Decimal | DecimalJsLike | number | string
    dueDate: Date | string
    status?: string
    paidAmount?: Decimal | DecimalJsLike | number | string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyContractInput = {
    id?: string
    installmentId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractDiscountCreateManyContractInput = {
    id?: string
    type: string
    amount?: Decimal | DecimalJsLike | number | string | null
    percentage?: number | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ContractItemUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    feeItem?: FeeItemUpdateOneRequiredWithoutContractItemsNestedInput
  }

  export type ContractItemUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    feeItemId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallmentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInstallmentNestedInput
  }

  export type InstallmentUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    sequenceNo?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    paidAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installment?: InstallmentUpdateOneWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    installmentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractDiscountUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    percentage?: NullableFloatFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemCreateManyFeeItemInput = {
    id?: string
    contractId: string
    description?: string | null
    quantity?: number
    unitAmount: Decimal | DecimalJsLike | number | string
    totalAmount: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type ContractItemUpdateWithoutFeeItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutItemsNestedInput
  }

  export type ContractItemUncheckedUpdateWithoutFeeItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractItemUncheckedUpdateManyWithoutFeeItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInstallmentInput = {
    id?: string
    contractId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    providerName?: string | null
    providerTransactionId?: string | null
    status?: string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutPaymentsNestedInput
    refunds?: RefundUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refunds?: RefundUncheckedUpdateManyWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutInstallmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    providerTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    providerResponse?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyPaymentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    reason?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefundUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampusCountOutputTypeDefaultArgs instead
     */
    export type CampusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentCountOutputTypeDefaultArgs instead
     */
    export type ParentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProspectCountOutputTypeDefaultArgs instead
     */
    export type ProspectCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProspectCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamCountOutputTypeDefaultArgs instead
     */
    export type ExamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamSessionCountOutputTypeDefaultArgs instead
     */
    export type ExamSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractCountOutputTypeDefaultArgs instead
     */
    export type ContractCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeItemCountOutputTypeDefaultArgs instead
     */
    export type FeeItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallmentCountOutputTypeDefaultArgs instead
     */
    export type InstallmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentCountOutputTypeDefaultArgs instead
     */
    export type PaymentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CampusDefaultArgs instead
     */
    export type CampusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CampusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParentDefaultArgs instead
     */
    export type ParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentParentDefaultArgs instead
     */
    export type StudentParentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentParentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProspectDefaultArgs instead
     */
    export type ProspectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProspectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InteractionDefaultArgs instead
     */
    export type InteractionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InteractionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversionDefaultArgs instead
     */
    export type ConversionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConversionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamSessionDefaultArgs instead
     */
    export type ExamSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamApplicationDefaultArgs instead
     */
    export type ExamApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdmissionTicketDefaultArgs instead
     */
    export type AdmissionTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdmissionTicketDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDefaultArgs instead
     */
    export type ContractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeeItemDefaultArgs instead
     */
    export type FeeItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeeItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractItemDefaultArgs instead
     */
    export type ContractItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContractDiscountDefaultArgs instead
     */
    export type ContractDiscountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContractDiscountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallmentDefaultArgs instead
     */
    export type InstallmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefundDefaultArgs instead
     */
    export type RefundArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefundDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}